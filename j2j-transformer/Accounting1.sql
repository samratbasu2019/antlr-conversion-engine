create or replace PACKAGE BODY ACCOUNTING_PKG
AS
  /*$Header: */
  /****************************************************************************
  ***************************************
  
  * <------- Modified ---------> <---- Version ----> <--------- Reviewed
  --------> <--------- Modification-------> *
  * Date By Script By Date Type Details *
  * ----------- ---------------- -------- ---------- -----------------
    **************************************/
  --
  -- This variable holds the request id of the concurrent program
  --
  g_num_request_id NUMBER := fnd_global.conc_request_id;
  --
  -- This variable holds the user_id of the current user
  --
  g_num_user_id NUMBER := 1092;--fnd_global.user_id;
  --
  -- This variable holds the login_id of the current user
  --
  g_num_login_id   NUMBER := fnd_global.conc_login_id;
  g_num_program_id NUMBER := fnd_global.conc_program_id;
  --
  -- Variable to Hold Invoice default Values
  g_num_batch_source_id ra_batch_sources.batch_source_id%TYPE;
  g_batch_source_name ra_batch_sources.name%TYPE;
  g_term_name ra_terms.name%TYPE;
  g_term_id ra_terms.term_id%TYPE;
  g_cust_account_id hz_cust_accounts.cust_account_id%TYPE;
  g_cust_acc_site_id hz_cust_acct_sites.cust_acct_site_id%TYPE;
  g_receivables_trx_id ar_receivables_trx_all.receivables_trx_id%TYPE;
  g_recv_ccid ar_receivables_trx_all.code_combination_id%TYPE;
  g_payment_schedule_id ar_payment_schedules_all.payment_schedule_id%TYPE;
 -- g_num_org_id      NUMBER :=mo_global.get_current_org_id;
  g_num_org_id      NUMBER := fnd_profile.value('ORG_ID'); 
  g_Legal_Entity_Id NUMBER;
  -- Variable for Payables default Values
  g_vendor_id          NUMBER;
  g_vendor_site_id     NUMBER;
  g_adjustment_ccid    NUMBER;
  g_refd_ccid        NUMBER;
  g_pay_resp_id        NUMBER;
  g_pay_application_id NUMBER;
  g_rcpt_cnt           NUMBER :=0;
  V_RELAX_FLAG         VARCHAR(30);
  g_relax_flag         NUMBER :=0; --added for HF_176638 on 11-Apr-2018
  g_id_number             VARCHAR2(11); --//added kulasekhar ABC 2.0

  -- l_out_chr_errbuff VARCHAR2(3000); --400 commented 8 JAN13
  -- l_out_chr_retcode VARCHAR2(3); --400 commented 8 JAN13
  --+
  ------------------------------------------------------------------------------
  -- +
  --| Name : DEBUG |
  --| Description : used for printing detail messages when debug parameter is '
  -- Y' |
  --+
  ------------------------------------------------------------------------------
  -- +
  PROCEDURE write_debug(
      p_debug_flag IN VARCHAR2 ,
      p_message    IN VARCHAR2 )
  IS
    l_err_procedure VARCHAR2(250) := 'APPS.ACCOUNTING_PKG_2.write_debug';
  BEGIN
    IF p_debug_flag = 'Y' THEN
      FND_FILE.put_line (FND_FILE.LOG, SYSTIMESTAMP|| '-' || p_message);
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    NULL;
  END write_debug;
-- ***************** End of Function / Procedure **********************--
  FUNCTION is_numeric(
      in_chr_char IN VARCHAR2 )
    RETURN NUMBER
  IS
    l_num_number     NUMBER;
    l_num_first_val  NUMBER;
    l_chr_second_val VARCHAR2(20);
  BEGIN
    -- Validation for the whole text
    IF in_chr_char IS NULL OR LENGTH(in_chr_char) <> 25 --changed in Ver 4.1
      THEN
      RETURN 0;
    END IF;
    l_num_first_val           := SUBSTR(in_chr_char, 1, 19);
    IF LENGTH(l_num_first_val) < 19 THEN
      RETURN 0;
    ELSE
      l_num_number              := TO_NUMBER(l_num_first_val);
      l_chr_second_val          :=SUBSTR(in_chr_char, 21, 25);
      IF UPPER(l_chr_second_val) = 'XXCRA' THEN
        RETURN 1;
      ELSE
        RETURN 0;
      END IF;
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    RETURN 0;
  END is_numeric;
-- ***************** End of Function / Procedure **********************--
--+
------------------------------------------------------------------------------+
--| Name : Write_msg |
--| Description : Write messages in the Log or Out File based on request |
--+
------------------------------------------------------------------------------+
  PROCEDURE Write_msg(
      p_log_or_out_flg IN VARCHAR2 ,
      p_message        IN VARCHAR2 )
  IS
    l_err_procedure VARCHAR2(250) := 'APPS.ACCOUNTING_PKG_2.Write_msg';
  BEGIN
    IF p_log_or_out_flg = 'LOG' THEN
      FND_FILE.PUT_LINE(FND_FILE.log , systimestamp|| '-' || P_MESSAGE);
      --DBMS_output.put_line ( SYSTIMESTAMP|| '-' || p_message);
    ELSE -- IF p_log_or_out_flg = 'LOG' THEN
      FND_FILE.PUT_LINE(FND_FILE.OUTPUT, SYSTIMESTAMP|| '-' || p_message);
    END IF; -- IF p_log_or_out_flg = 'LOG' THEN
  EXCEPTION
  WHEN OTHERS THEN
    NULL;
  END Write_msg;
-- ***************** End of Function / Procedure **********************--
  FUNCTION derive_din(
      p_chr_processing_yr  IN VARCHAR2,
      p_chr__ayr  IN VARCHAR2,
      p_chr_major_head     IN VARCHAR2,
      p_num_dmd_seq_num IN NUMBER )
    RETURN VARCHAR2
    /****************************************************************************
    ****************************************
    * Type : FUNCTION *
    * Name : derive_DIN *
    * Input Parameters : *
    * Output Parameters : Number *
    * Purpose : To calculate the DIN *
    * *
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details *
    * ------------- ------------ -------- --------------- --------------
    ----------------- -------------------------- *
    *****************************************************************************
    ***************************************/
  IS
    l_num_dmd_seq_num NUMBER        := p_num_dmd_seq_num;
    l_num_checksum       NUMBER        := 0;
    l_chr_processing_yr  VARCHAR2 (10) := p_chr_processing_yr;
    l_chr_din            VARCHAR2 (20);
    l_chr_major_head     VARCHAR2 (10);
    l_stmt_processing    VARCHAR2(100);
    l_chr_proc_name      VARCHAR2(50) :='get_dmd_sequence_num';
    l_chr_exe_location   VARCHAR2(50) :='';
    CURSOR cur_get_dem_seq_num ( p_chr_processing_yr VARCHAR2)
    IS
      SELECT dmd_seq_num
      FROM xx_dmd_seq_ctrl
      WHERE processing_year = p_chr_processing_yr FOR UPDATE OF dmd_seq_num;
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    IF p_chr_major_head    = '0020' THEN
      l_chr_major_head    := 'C';
    ELSIF p_chr_major_head = '0021' THEN
      l_chr_major_head    := 'T';
    ELSIF p_chr_major_head = '0026' THEN
      l_chr_major_head    := 'F';
    ELSIF p_chr_major_head = '0032' THEN
      l_chr_major_head    := 'W';
    END IF;
    l_chr_exe_location := 'Der_din_0001';
    l_stmt_processing  :='Fetch dmd_seq_num from xx_dmd_seq_ctrl';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    OPEN cur_get_dem_seq_num(l_chr_processing_yr);
    FETCH cur_get_dem_seq_num INTO l_num_dmd_seq_num;
    IF cur_get_dem_seq_num%NOTFOUND THEN
      l_chr_exe_location := 'Der_din_0002';
      l_stmt_processing  :=' Deman Seq Not available creating dmd_seq_num ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      l_num_dmd_seq_num := 3699999999;
      INSERT
      INTO xx_dmd_seq_ctrl
        (
          processing_year ,
          dmd_seq_num
        )
        VALUES
        (
          l_chr_processing_yr ,
          l_num_dmd_seq_num
        );
    END IF;
    CLOSE cur_get_dem_seq_num;
    l_chr_exe_location := 'Der_din_0003';
    l_stmt_processing  :='Update dmd_seq_num in xx_dmd_seq_ctrl ';
    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
    UPDATE xx_dmd_seq_ctrl
    SET dmd_seq_num    = l_num_dmd_seq_num + 1
    WHERE processing_year = l_chr_processing_yr;
    COMMIT;
    l_chr_din := l_chr_processing_yr || p_chr__ayr || TO_CHAR ( l_num_dmd_seq_num);
    FOR i IN 1 .. LENGTH (l_chr_din)
    LOOP
      l_num_checksum := l_num_checksum + SUBSTR (l_chr_din, i, 1);
    END LOOP;
    l_num_checksum := MOD (l_num_checksum, 7);
    l_chr_din      := l_chr_din || TO_CHAR (l_num_checksum) || l_chr_major_head;
    RETURN l_chr_din;
  EXCEPTION
  WHEN OTHERS THEN
    l_chr_din := NULL;
    write_debug( g_debug_flag ,'Error in DIN derivation:' || SQLERRM );
    ROLLBACK;
    RETURN L_CHR_DIN;
  END derive_din;
/************************************************FUNCTION-ENDS*****************
************************************/
  PROCEDURE adjust_proc(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      in_chr_major_head      IN VARCHAR2,
      in_chr_assmt_year      IN VARCHAR2,
      in_num_customer_trx_id IN NUMBER,
      in_num_adjust_amount   IN NUMBER )
    /****************************************************************************
    ****************************************
    * Type : PROCEDURE *
    * Name : ADJUST_PROC *
    * Input Parameters : in_num_customer_trx_id, in_num_adjust_amount *
    * Output Parameters : p_out_chr_errbuff, p_out_chr_retcode *
    * Purpose : To perform adjustment in Invoice *
    * *
    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details *
    * ------------- ------------ -------- --------------- --------------
    ----------------- -------------------------- *
    *****************************************************************************
    ***************************************/
  AS
    custom_exception       EXCEPTION;
    l_payment_schedule_id  NUMBER;
    l_party_id             NUMBER;
    l_ccid                 NUMBER;
    l_receivables_trx_id   NUMBER;
    l_customer_trx_line_id NUMBER;
    p_count                NUMBER;
    v_validation_level     NUMBER (4) := fnd_api.g_valid_level_full;
    v_msg_count            NUMBER (4) DEFAULT NULL;
    v_msg_data             VARCHAR2 (1000);
    l_stmt_processing      VARCHAR2(200);
    v_return_status        VARCHAR2 (5);
    l_chr_exe_location     VARCHAR2(50)  :='';
    v_chk_approval_limits  VARCHAR2 (5)  := 'F';
    v_check_amount         VARCHAR2 (5)  := 'F';
    v_move_deferred_xx    VARCHAR2 (1)  := 'Y';
    v_called_from          VARCHAR2 (25) := 'ADJ-API';
    l_chr_proc_name        VARCHAR2(50)  :='adjust_proc';
    v_adj_rec ar_adjustments%ROWTYPE;
    v_new_adjust_number ar_adjustments.adjustment_number%TYPE;
    v_new_adjust_id ar_adjustments.adjustment_id%TYPE;
    v_old_adjust_id ar_adjustments.adjustment_id%TYPE;
    l_dte_irt_appr_dte DATE;
  BEGIN
    p_out_chr_errbuff  := ' ';
    p_out_chr_retcode  := g_chr_success_code;
    l_chr_exe_location := 'ADJP_0001';
    l_stmt_processing  := ' ADJUSTMENT PROCEDURE -STARTS ' ;
    write_debug( g_debug_flag ,l_stmt_processing );
	dbms_output.put_line(l_stmt_processing );
    write_debug( g_debug_flag ,'Program Request ID : ' || g_num_request_id );
    --Adjustment Trx id Fetch
    l_chr_exe_location := 'ADJP_0002';
    l_stmt_processing  := 'Adjustment Trx id Fetch ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    SELECT receivables_trx_id
    INTO l_receivables_trx_id
    FROM ar_receivables_trx_all
    WHERE TYPE = 'ADJUST'
    AND NAME   = 'Dmd Round'
    AND TRUNC (SYSDATE) BETWEEN NVL (start_date_active, SYSDATE - 1) AND NVL ( end_date_active, SYSDATE + 1);
    -- Payment schedule id Fetch
    l_chr_exe_location := 'ADJP_0003';
    l_stmt_processing  := 'Payment schedule id Fetch';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || '-' || in_num_customer_trx_id);
    SELECT payment_schedule_id
    INTO l_payment_schedule_id
    FROM ar_payment_schedules_all
    WHERE customer_trx_id = in_num_customer_trx_id;
    --Customer Trx Line id Fetch
    l_chr_exe_location := 'ADJP_0004';
    l_stmt_processing  := 'Customer Trx Line id Fetch';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    SELECT MIN (customer_trx_line_id) INTO l_customer_trx_line_id FROM ra_customer_trx_lines_all
    WHERE customer_trx_id = in_num_customer_trx_id;
    --Approval Date Fetch
    l_chr_exe_location := 'ADJP_0005';
    l_stmt_processing  := 'Approval Date Fetch';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    SELECT attribute3
    INTO l_dte_irt_appr_dte
    FROM ra_customer_trx_all
    WHERE customer_trx_id           = in_num_customer_trx_id;
    v_adj_rec.TYPE                 := 'LINE';
    v_adj_rec.adjustment_type      := 'M';
    v_adj_rec.payment_schedule_id  := l_payment_schedule_id;
    v_adj_rec.receivables_trx_id   := l_receivables_trx_id;
    v_adj_rec.customer_trx_id      := in_num_customer_trx_id;
    v_adj_rec.customer_trx_line_id := l_customer_trx_line_id;
    v_adj_rec.amount               := in_num_adjust_amount;
    v_adj_rec.apply_date           := TO_DATE (l_dte_irt_appr_dte, 'DD-MON-RRRR') ;
    v_adj_rec.gl_date              := g_dte_sys_date; --commented on 29-MAR-2019 for Backdated Accounting Hotfix_199485
    --  v_adj_rec.gl_date              := TO_DATE (l_dte_irt_appr_dte, 'DD-MON-RRRR'); --Added on 29-MAR-2019 for Backdated Accounting Hotfix_199485
    v_adj_rec.reason_code  := 'DMD ROUNDING OFF';
    v_adj_rec.comments     := 'DMD ROUNDING OFF';
    v_adj_rec.attribute1   := in_chr_major_head;
    v_adj_rec.attribute2   := in_chr_assmt_year;
    v_adj_rec.created_from := 'ADJ-API';
    l_chr_exe_location     := 'ADJP_0005';
    l_stmt_processing      := 'Calling create_adjustment API';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    ar_adjust_pub.create_adjustment (p_api_name => 'AR_ADJUST_PUB', p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit_flag => fnd_api.g_false, p_validation_level => v_validation_level, p_msg_count => v_msg_count, p_msg_data => v_msg_data, p_return_status => v_return_status, p_adj_rec => v_adj_rec, p_chk_approval_limits => v_chk_approval_limits, p_check_amount => v_check_amount, p_move_deferred_xx => v_move_deferred_xx, p_new_adjust_number => v_new_adjust_number, p_new_adjust_id => v_new_adjust_id, p_called_from => v_called_from, p_old_adjust_id => v_old_adjust_id, p_org_id => g_num_org_id );
    IF v_return_status    <> 'S' THEN
      p_out_chr_errbuff   :=p_out_chr_errbuff || 'Message ' || v_msg_count || 'Message Data ' || v_msg_data;
      IF v_msg_count       = 1 THEN
        p_out_chr_errbuff :=p_out_chr_errbuff || 'Message Data ' || v_msg_data;
      ELSIF v_msg_count    > 1 THEN
        LOOP
          p_count       := p_count + 1;
          v_msg_data    := fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false);
          IF v_msg_data IS NULL THEN
            EXIT;
          END IF;
          p_out_chr_errbuff :=p_out_chr_errbuff || 'Message' || p_count || '-'|| v_msg_data;
        END LOOP;
      END IF; -- IF v_msg_count = 1
      RAISE custom_exception;
    END IF;-- IF v_return_status <> 'S'
  EXCEPTION
  WHEN custom_exception THEN
    p_out_chr_retcode := g_chr_failure_code;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := ' Unexpected Error in Procedure - '|| l_chr_proc_name || '-' ||sqlerrm;
  END adjust_proc;
/************************************************PROCEDURE-ENDS****************
*************************************/
  FUNCTION delaymonth_calc(
      p_irt_due_date      IN DATE,
      p_customer_trx_date IN DATE )
    RETURN NUMBER
    /****************************************************************************
    ****************************************
    * Type : FUNCTION
    * Name : delaymonth_calc
    * Input Parameters :
    * Output Parameters : Number
    * Purpose : To calculate the interest for Refd
    *
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    -----------------------------------------
    *************************************************************************/
  IS
    l_no_of_months   NUMBER;
    l_due_months NUMBER := 0;
    l_irt_due_date   DATE;
    l_date_diff      NUMBER;
  BEGIN
    IF p_customer_trx_date > p_irt_due_date THEN
      SELECT DECODE (p_irt_due_date, LAST_DAY (p_irt_due_date), p_irt_due_date + 1, p_irt_due_date )
      INTO l_irt_due_date
      FROM DUAL;
      SELECT MONTHS_BETWEEN (TO_DATE (TO_CHAR (p_customer_trx_date,'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (l_irt_due_date,'MON-YYYY'), 'MON-YYYY') )+ 1,
        (p_customer_trx_date                                                                                                                            - p_irt_due_date)
      INTO l_due_months,
        l_date_diff
      FROM DUAL;
      IF l_due_months = 0 AND l_date_diff > 0 THEN
        l_due_months := 1;
      END IF; -- IF l_due_months = 0 AND l_date_diff > 0
    END IF;   -- IF p_customer_trx_date > p_irt_due_date
    RETURN (l_due_months);
  END delaymonth_calc;
-- ***************** End of Function / Procedure **********************--
  FUNCTION total_collect_calc(
      p_reference_id IN NUMBER)
    RETURN NUMBER
    /****************************************************************************
    ****************************************
    * Type : FUNCTION
    * Name : TOTAL_COLLECT_CALC
    * Input Parameters :
    * Output Parameters : Number
    * Purpose : To calculate the sum of collection of 100,200
    *
    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details *
    * ------------- ------------ -------- --------------- --------------
    ----------------- --------------------------
    *************************************************************************/
  IS
    l_total_collect_amt NUMBER := 0;
  BEGIN
    SELECT NVL (SUM (excess_receipt_amount), 0)
    INTO l_total_collect_amt
    FROM xx_refd_lines
    WHERE reference_id = p_reference_id
      --AND minor_head    IN ('100', '200', 'XCL'); --Commented as a Part of
      -- CR_HWSW_0552 - 14-JUN-2016
    AND minor_head IN ('100', '200', 'XCL','PMR','SPI','5A','OTH'); --Modified as a Part of CR_HWSW_0552--added PMR as part of CR#653 & CR#613 --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
    -- - 14-JUN-2016
    RETURN (l_total_collect_amt);
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    l_total_collect_amt := 0;
    RETURN (l_total_collect_amt);
  WHEN OTHERS THEN
    l_total_collect_amt := 0;
    RETURN (l_total_collect_amt);
  END total_collect_calc;
  FUNCTION total_300_collect_calc(
      P_REFERENCE_ID IN NUMBER)--, Commented for DDT-BBS changes on 08-JUN-2018 - CR - 690
    -- P_IN_SOURCE IN VARCHAR DEFAULT NULL) -- Added P_IN_SOURCE for CR - 690 on 18-MAY-2018--, Commented for DDT-BBS changes on 08-JUN-2018 - CR - 690
    RETURN NUMBER
    /****************************************************************************
    ****************************************
    * Type : FUNCTION
    * Name : TOTAL_COLLECT_CALC
    * Input Parameters :
    * Output Parameters : Number
    * Purpose : To calculate the sum of collection of 300
    *
    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details *
    * ------------- ------------ -------- --------------- --------------
    ----------------- 
    *************************************************************************/
  IS
    L_TOTAL_COLLECT_AMT NUMBER := 0;
  BEGIN

    SELECT NVL (SUM (EXCESS_RECEIPT_AMOUNT),0)
    INTO L_TOTAL_COLLECT_AMT
    FROM xx_REFD_LINES
    WHERE REFERENCE_ID = P_REFERENCE_ID
    AND MINOR_HEAD    IN ('100', '200', 'XCL','300','PMR','SPI','5A','OTH'); -- Added PMR as part of CR#653 & CR#613 --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
    -- Hotfix#120438 - 23-JUN-2016
    write_debug( g_debug_flag ,'l_total_collect_amt:  '||l_total_collect_amt);
    RETURN (l_total_collect_amt);
    --END IF; -- Commented on 08-JUN-2018 for DDT-BBS ABC changes - CR - 690
    --  write_debug( g_debug_flag ,'l_total_collect_amt:  '||l_total_collect_amt);
    --added for CR#690 on 07-May-18----End---
    --RETURN (l_total_collect_amt); on 08-JUN-2018 for DDT-BBS ABC changes - CR - 690
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    l_total_collect_amt := 0;
    RETURN (l_total_collect_amt);
  WHEN OTHERS THEN
    l_total_collect_amt := 0;
    RETURN (L_TOTAL_COLLECT_AMT);
  END total_300_collect_calc;
-- ***************** End of Function / Procedure **********************--
--Added by Sudha on 18-Jan-2018 for HF#171927 starts
  FUNCTION total_300_collect_calc_ref(
      p_reference_id IN NUMBER)
    RETURN NUMBER
    /********************************************************************************************************************
    *********************************************************************************************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification Type Modification Details *
    * ------------- ------------ -------- --------------- -------------- ----------------- --------------------------
    ********************************************************************************************************************/
  IS
    l_total_collect_amt NUMBER := 0;
  BEGIN
    SELECT NVL (SUM (excess_receipt_amount), 0)
    INTO l_total_collect_amt
    FROM xx_refd_lines
    WHERE REFERENCE_ID = P_REFERENCE_ID
    AND minor_head    IN ('300');
    RETURN (l_total_collect_amt);
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    l_total_collect_amt := 0;
    RETURN (l_total_collect_amt);
  WHEN OTHERS THEN
    l_total_collect_amt := 0;
    RETURN (L_TOTAL_COLLECT_AMT);
  END total_300_collect_calc_ref;
-- ***************** End of Function / Procedure **********************--

  FUNCTION intermonth_calc(
      p_code        IN NUMBER ,
      p_lookup_type IN VARCHAR2)
    RETURN NUMBER
    /****************************************************************************
    ****************************************
    * Type : FUNCTION
    * Name : INTERMONTH_CALC
    * Input Parameters :
    * Output Parameters : Number
    * Purpose : To calculate the interest for Dmd
    *
    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    *************************************************************************/
  IS
    l_interest_amt     NUMBER := 0;
    l_rate_of_interest NUMBER;
    l_no_of_months     NUMBER;
    l_date_diff        NUMBER;
    l_current_end_date VARCHAR2 (10);
    l_next_start_date  VARCHAR2 (10);
  BEGIN
    BEGIN
      SELECT TO_CHAR (TRUNC (NVL (end_date_active, SYSDATE)), 'MON-YYYY')
      INTO l_current_end_date
      FROM fnd_lookup_values
      WHERE lookup_type = p_lookup_type
      AND enabled_flag  = 'Y'
      AND lookup_code   = p_code;
    EXCEPTION
    WHEN OTHERS THEN
      RETURN -1;
    END;
    BEGIN
      SELECT TO_CHAR (start_date_active, 'MON-YYYY')
      INTO l_next_start_date
      FROM fnd_lookup_values
      WHERE lookup_type = p_lookup_type
      AND enabled_flag  = 'Y'
      AND lookup_code   = p_code + 1;
    EXCEPTION
    WHEN OTHERS THEN
      RETURN 1;
    END;
    BEGIN
      IF l_current_end_date = l_next_start_date THEN
        RETURN 0;
      ELSE -- IF l_current_end_date = l_next_start_date
        RETURN 1;
      END IF; -- IF l_current_end_date = l_next_start_date
    EXCEPTION
    WHEN OTHERS THEN
      RETURN -3;
    END;
    RETURN 0;
  END intermonth_calc;
-- ***************** End of Function / Procedure **********************--
  FUNCTION Customer_type_chk(
      p_irt_id IN NUMBER)
    RETURN NUMBER
    /****************************************************************************
    ****************************************
    * Type : FUNCTION
    * Name :xx_Customer_type_chk
    * Input Parameters :
    * Output Parameters : Number
    * Purpose : To check the type of Customer
    *

    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    ----------------- --------------------------
    *****************************************************************************
    ***************************************/
  IS
    --l_status_nc NUMBER :=0; --commented for SR #179493 on 27-APR-2018
    l_status_nc1 NUMBER := 0; --Added for SR #179493 on 27-APR-2018
    l_status_nc2 NUMBER := 0; --Added for SR #179493 on 27-APR-2018
    l_status_co  NUMBER := 0;
  BEGIN
    /*Added for SR #179493 on 27-APR-2018*/
    -- START
    SELECT COUNT (1)
    INTO l_status_nc1
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM ,
      "efile"."irt_personal_info"@psql_process_fas ITP
      -- ,fas_master.id_master_mv pmv --Commented for Hotfix No. 77338
    WHERE PCM."irt_id" = ITP."irt_id"
    AND PCM."irt_id"   = P_IRT_ID
      -- AND ITP.id_number = PMV.id_number --Commented for Hotfix No. 77338
      -- AND pcm.id_number = pmv.id_number --Commented for Hotfix No. 77338
    AND pcm."form_type_code"             <> 6
    AND ITP."fs_residential_status_cd" = 'NRI'
    AND ITP."pi_Customer_type_cd"      IN('I','A','H') --added for SR #179493 on 27-APR-2018
      -- OR PMV.IND_CTZN_FLAG = 'N' --Commented for Hotfix No. 77338
      ;
    --added for SR #179493 on 27-APR-2018 
    SELECT COUNT (1)
    INTO l_status_nc2
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM ,
      "efile"."irt_personal_info"@psql_process_fas ITP
      -- ,fas_master.id_master_mv pmv --Commented for Hotfix No. 77338
    WHERE pcm."irt_id" = itp."irt_id"
    AND pcm."irt_id"   = P_IRT_ID
      -- AND ITP.id_number = PMV.id_number --Commented for Hotfix No. 77338
      -- AND pcm.id_number = pmv.id_number --Commented for Hotfix No. 77338
    AND pcm."form_type_code"                      <> 6
    AND ITP."fs_residential_status_cd"          = 'NRI'
    AND NVL(ITP."pi_Customer_type_cd", 'X') NOT IN('I','A','H') ;
    -- OR PMV.IND_CTZN_FLAG = 'N' --Commented for Hotfix No. 77338
    /*Added for SR #179493 on 27-APR-2018*/
    -- END
    SELECT COUNT (1)
    INTO l_status_co
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM,
      "efile"."irt_personal_info"@psql_process_fas ITP
      -- ,fas_master.id_master_mv pmv
    WHERE pcm."irt_id" = itp."irt_id"
    AND pcm."irt_id"   = p_irt_id
      -- AND itp.id_number                  = pmv.id_number  --Commented for Hotfix No.
      -- 77338
      -- AND pcm.id_number                  = pmv.id_number  --Commented for Hotfix No.
      -- 77338
    AND pcm."form_type_code"             = 6
    AND ( ITP."pi_domestic_compy_flag" = 'N'
      --OR pmv.ind_ctzn_flag            = 'N' --Commented for Hotfix No. 77338
    OR ITP."fs_residential_status_cd"='NRI' );----Added for CR_HWSW_0177
    -- Changed domestic flag as N as per the latest changes in 5 to 6 code
    IF l_status_nc1 > 0 THEN -- if Customer type is 'Individual/HUF/AOP/BOI' in NC category --added for SR #179493 on 27-APR-2018
      RETURN (1);
    ELSIF l_status_co > 0 THEN
      RETURN (2);
    ELSIF l_status_nc2 > 0 THEN -- if Customer type is 'Other than Individual/HUF/AOP/BOI' in NC category --added for SR #179493 on 27-APR-2018
      RETURN (3);
    ELSE
      RETURN (0);
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    fnd_file.put_line (fnd_file.LOG, 'Error in Customer type check ' || SQLERRM ) ;
    RETURN (3);
  END Customer_type_chk;
-- ***************** End of Function / Procedure **********************--
  FUNCTION month_interest_calc(
      p_start_date  IN DATE,
      p_end_date    IN DATE,
      p_lookup_type IN VARCHAR2 )
    RETURN NUMBER
    /****************************************************************************
    ****************************************
    * Type : FUNCTION
    * Name : MONTH_INTEREST_CALC
    * Input Parameters :
    * Output Parameters : Number
    * Purpose : To calculate the minimum value

    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    ----------------- --------------------------
    *************************************************************************/
  IS
    l_int_month    NUMBER := 0;
    l_no_of_months NUMBER;
    l_end_date     DATE;
    l_start_date   DATE;
    l_count        NUMBER;
  BEGIN
    write_debug( g_debug_flag , ' month_interest_calc p_start_date' || p_start_date );
    write_debug( g_debug_flag , ' p_end_date ' ||p_end_date);
    write_debug( g_debug_flag , ' p_lookup_type ' ||p_lookup_type);
    BEGIN
      SELECT COUNT (1)
      INTO l_count
      FROM fnd_lookup_values
      WHERE lookup_type = p_lookup_type
      AND enabled_flag  = 'Y'
      AND ( ( p_start_date BETWEEN start_date_active AND NVL (end_date_active, SYSDATE) )
      OR ( p_start_date < start_date_active ) )
      AND ( ( p_end_date BETWEEN start_date_active AND NVL (end_date_active, SYSDATE) )
      OR ( p_end_date > NVL (end_date_active, SYSDATE) ) );
    EXCEPTION
    WHEN OTHERS THEN
      RETURN -3;
    END;
    write_debug( g_debug_flag , ' l_count ' ||l_count );
    FOR j IN
    (SELECT TO_NUMBER (lookup_code) code ,
      TO_NUMBER (description) interest ,
      start_date_active ,
      TRUNC (NVL (end_date_active, SYSDATE)) end_date_active ,
      TO_CHAR (start_date_active, 'DD-MON-YYYY') start_date ,
      TO_CHAR (TRUNC (NVL (end_date_active, SYSDATE)),'DD-MON-YYYY') end_date ,
      MONTHS_BETWEEN (TO_DATE (TO_CHAR (TRUNC (NVL (end_date_active, SYSDATE)), 'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (start_date_active, 'MON-YYYY' ),'MON-YYYY') ) + intermonth_calc (TO_NUMBER (lookup_code),p_lookup_type) months,
      DECODE (intermonth_calc (TO_NUMBER (lookup_code),p_lookup_type),0,                                                                                                  -1,1) temp
    FROM fnd_lookup_values
    WHERE lookup_type = p_lookup_type
    AND enabled_flag  = 'Y'
    AND ( ( p_start_date BETWEEN start_date_active AND NVL (end_date_active, SYSDATE) )
    OR ( p_start_date < start_date_active ) )
    AND ( ( p_end_date BETWEEN start_date_active AND NVL (end_date_active, SYSDATE) )
    OR ( p_end_date > NVL (end_date_active, SYSDATE) ) )
    )
    LOOP
      write_debug( g_debug_flag , ' p_start_date ' || p_start_date );
      write_debug( g_debug_flag , ' j.start_date_active ' || j.start_date_active );
      write_debug( g_debug_flag , ' j.end_date_active ' || j.end_date_active );
      write_debug( g_debug_flag , ' p_end_date ' || p_end_date );
      IF p_start_date BETWEEN j.start_date_active AND j.end_date_active THEN
        l_start_date := p_start_date;
      ELSE -- IF p_start_date BETWEEN j.start_date_active AND j.end_date_active
        l_start_date := j.start_date_active;
      END IF; -- IF p_start_date BETWEEN j.start_date_active AND
      -- j.end_date_active
      IF p_end_date BETWEEN j.start_date_active AND j.end_date_active THEN
        l_end_date := p_end_date;
      ELSE -- IF p_end_date BETWEEN j.start_date_active AND j.end_date_active
        l_end_date := j.end_date_active;
      END IF; -- IF p_end_date BETWEEN j.start_date_active AND j.end_date_active
      l_no_of_months := MONTHS_BETWEEN (TO_DATE (TO_CHAR (TRUNC (NVL (l_end_date, SYSDATE) ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (l_start_date, 'MON-YYYY'), 'MON-YYYY')) + intermonth_calc (TO_NUMBER (j.code), p_lookup_type);
      write_debug( g_debug_flag , ' l_no_of_months ' ||l_no_of_months );
      IF l_no_of_months   = 0 AND l_end_date > l_start_date THEN
        IF l_count        = 1 THEN
          l_no_of_months := 1;
        ELSE -- IF l_count = 1
          l_no_of_months := 1 + j.temp;
        END IF; -- IF l_count = 1
      END IF;   -- IF l_no_of_months = 0 AND l_end_date > l_start_date
      l_int_month := l_int_month + (l_no_of_months * j.interest);
      --l_int_month := l_int_month + l_no_of_months;
      write_debug( g_debug_flag , ' l_int_month ' ||l_int_month || ' l_no_of_months' || l_no_of_months);
    END LOOP; -- FOR j IN
    write_debug( g_debug_flag , l_int_month );
    RETURN l_int_month;
  EXCEPTION -- Including the exception as there should be exception block
  WHEN OTHERS THEN
    write_msg( g_write_logfile , ' Others so -3 ' );
    RETURN -3;
  END month_interest_calc;
-- ***************** End of Function / Procedure **********************--
-- Added function refd_interest_calc_new to calculate interest out of 100/200 - HF#171927 on 8-May-2018 - starts
  FUNCTION refd_interest_calc_new(
      P_IN_IRT_ID         IN VARCHAR2,
      p_reference_id      IN NUMBER,
      p_irt_assmt_year    IN VARCHAR2,
      P_RECEIPT_AMOUNT    IN NUMBER,
      P_REFD_APR_DATE   IN DATE,  -- refd_identified_date
      P_IRT_DUE_DATE      IN DATE,  -- original_due_date
      p_customer_trx_date IN DATE ) -- original_filing_date
    RETURN NUMBER
    /********************************************************************************************************************
    * Type : FUNCTION
    * Name : refd_interest_calc_new
    * Input Parameters :
    * Output Parameters : Number
    * Purpose : To calculate the interest for Refd
    *********************************************************************************************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification Type Modification Details
    * ------------- ------------ -------- --------------- -------------- ----------------- --------------------------
    ,.............................................********************************************************************************************************************/
  IS
    L_START_MONTH VARCHAR2 (11);
    L_VAL_FILING_STATUS_CD  "process_store"."irt_process_control_mstr"."x_val_filing_status_cd"@psql_process_fas%TYPE;
    l_current_filing_dt  DATE;
    L_AT_TS_INT_MONTHS  NUMBER := 0;
    L_DELAY_MONTHS_100   NUMBER := 0;
    L_TOT_INT_MONTHS_100 NUMBER := 0;
    L_DELAY_MONTHS_AO IRT_STDCMP.INTEREST_ON_REFD.DELAY_ATTRIBUTABLE%TYPE;
    L_DELAY_FLAG IRT_STDCMP.INTEREST_ON_REFD.DELAY_FLAG%TYPE;
    L_REC_INTEREST_AMT NUMBER := 0;
    CUSTOM_EXCEPTION   EXCEPTION;
    L_IRTV_EVC_VALIDATED_DATE IRT_STDCMP.INTEREST_ON_REFD.IRTV_EVC_VALIDATED_DATE%TYPE;
    L_TYPE_OF_RETURN IRT_STDCMP.INTEREST_ON_REFD.TYPE_OF_RETURN%type;
    L_DEFECTIVE_COMM_SENT_DT IRT_STDCMP.INTEREST_ON_REFD.DEFECTIVE_COMM_SENT_DT%TYPE;
    L_CORRECTIVE_FILIING_DATE IRT_STDCMP.INTEREST_ON_REFD.CORRECTIVE_FILIING_DATE%TYPE;
    l_start_filing_mon NUMBER :=0;
    l_evc_app_mon      NUMBER :=0;
    l_fil_evc_mon      NUMBER :=0;
    L_DEF_EVC_MON      NUMBER :=0;
    L_COR_DEF_MON      NUMBER :=0;
    L_COR_APP_MON      NUMBER :=0;
    L_GEO_FLAG IRT_STDCMP.INTEREST_ON_REFD.GEO_FLAG%type;
    L_GEO_DATE IRT_STDCMP.INTEREST_ON_REFD.GEO_ORDER_PASS_DT%type;
    L_GEO_LAST_DATE DATE;
    L_GEO_MONTHS    NUMBER := 0;
    L_REC_GEO_INT   NUMBER := 0;
  BEGIN
    write_debug( g_debug_flag , ' p_reference_id ' || p_reference_id );
    write_debug( g_debug_flag , ' p_irt_assmt_year ' ||p_irt_assmt_year );
    write_debug( g_debug_flag , ' p_receipt_amount ' ||p_receipt_amount );
    write_debug( g_debug_flag , ' p_customer_trx_date ' ||p_customer_trx_date );
    write_debug( g_debug_flag , ' p_irt_due_date ' || p_irt_due_date );
    write_debug( g_debug_flag , ' p_refd_apr_date ' ||p_refd_apr_date );
    l_start_month := '01-APR-' || SUBSTR(p_irt_assmt_year,3,4); --Modified as a Part of CR_HWSW_0552
    write_debug( g_debug_flag , 'Finding x_val_filing_status_cd For irt_id: '||P_IN_IRT_ID);
    BEGIN
      SELECT "x_val_filing_status_cd"
      INTO L_VAL_FILING_STATUS_CD
      FROM "process_store"."irt_process_control_mstr"@PSQL_PROCESS_FAS
      WHERE TO_CHAR("irt_id") = P_IN_IRT_ID;
      write_debug( g_debug_flag , 'Finding L_VAL_FILING_STATUS_CD: '||L_VAL_FILING_STATUS_CD);
    END;
    write_debug( g_debug_flag , 'Finding current filing date');
    BEGIN
      IF L_VAL_FILING_STATUS_CD IN ('O','R','A','P') THEN
        SELECT "x_e_ack_recpt_dt"
        INTO l_current_filing_dt
        FROM "process_store"."irt_process_control_mstr"@psql_process_fas
        WHERE "irt_id"              = P_IN_IRT_ID;
      ELSIF L_VAL_FILING_STATUS_CD = 'T' THEN
        SELECT "rect_file_dt"
        INTO l_current_filing_dt
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id" = P_IN_IRT_ID;
      END IF;
      write_debug( g_debug_flag , 'l_current_filing_dt: '||l_current_filing_dt);
    END;
    write_debug( g_debug_flag , 'Finding delay_flag and delay_attributable');
    BEGIN
      SELECT "irtv_evc_validated_date",
        "type_of_return",
        "defective_comm_sent_dt",
        "corrective_filiing_date",
        "delay_attributable",
        "delay_flag"
      INTO L_IRTV_EVC_VALIDATED_DATE,
        L_TYPE_OF_RETURN,
        L_DEFECTIVE_COMM_SENT_DT,
        L_CORRECTIVE_FILIING_DATE,
        L_DELAY_MONTHS_AO,
        L_DELAY_FLAG
      FROM "process_store"."interest_on_refd"@psql_process_fas
      WHERE "irt_id" =P_IN_IRT_ID;
      write_debug( g_debug_flag , 'L_IRTV_EVC_VALIDATED_DATE: '||L_IRTV_EVC_VALIDATED_DATE);
      write_debug( g_debug_flag , 'L_TYPE_OF_RETURN: '||L_TYPE_OF_RETURN);
      write_debug( g_debug_flag , 'L_DEFECTIVE_COMM_SENT_DT: '||L_DEFECTIVE_COMM_SENT_DT);
      WRITE_DEBUG( G_DEBUG_FLAG , 'L_CORRECTIVE_FILIING_DATE: '||L_CORRECTIVE_FILIING_DATE);
      write_debug( g_debug_flag , 'L_DELAY_FLAG: '||L_DELAY_FLAG);
      write_debug( g_debug_flag , 'L_DELAY_MONTHS_AO: '||L_DELAY_MONTHS_AO);
    END;
    write_debug( g_debug_flag , 'Interest calculation starts');
    IF L_VAL_FILING_STATUS_CD = 'O' THEN
      IF p_customer_trx_date <= P_IRT_DUE_DATE THEN -- within due date
        IF L_TYPE_OF_RETURN   = 'CORRECTED' THEN
          WRITE_DEBUG( G_DEBUG_FLAG , ' Inside Corrected : ');
          L_START_FILING_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_current_filing_dt),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_START_MONTH), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_START_FILING_MON : '|| L_START_FILING_MON);
          L_DEF_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
          WRITE_DEBUG( G_DEBUG_FLAG , ' L_DEF_EVC_MON : '||L_DEF_EVC_MON);
          L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( p_customer_trx_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
          WRITE_DEBUG( G_DEBUG_FLAG , ' L_COR_APP_MON : '||L_COR_APP_MON);
          L_FIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (l_current_filing_dt), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_FIL_EVC_MON : '||L_FIL_EVC_MON);
          L_COR_DEF_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_DEFECTIVE_COMM_SENT_DT), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_COR_DEF_MON : '||L_COR_DEF_MON);
          IF L_FIL_EVC_MON       =0 AND L_COR_DEF_MON = 0 THEN
            l_at_ts_int_months := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) -2;
          ELSIF ((l_fil_evc_mon  = 0 AND l_cor_def_mon > 0) OR ( l_fil_evc_mon > 0 AND l_cor_def_mon = 0 ) ) THEN
            l_at_ts_int_months := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) - 1;
          ELSE
            L_AT_TS_INT_MONTHS := ((L_START_FILING_MON+1)+(L_DEF_EVC_MON+1)+( L_COR_APP_MON +1));
          END IF;
          WRITE_DEBUG( G_DEBUG_FLAG , ' l_at_ts_int_months : '||L_AT_TS_INT_MONTHS);
        ELSIF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
          L_AT_TS_INT_MONTHS  := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))))+1;
          WRITE_DEBUG( G_DEBUG_FLAG , ' l_at_ts_int_months : '||L_AT_TS_INT_MONTHS);
        END IF;
      ELSIF p_customer_trx_date > P_IRT_DUE_DATE THEN -- after due date/belated return
        IF L_TYPE_OF_RETURN     = 'CORRECTED' THEN
          L_DEF_EVC_MON        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
          L_COR_APP_MON        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( p_customer_trx_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
          L_COR_DEF_MON        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_DEF_EVC_MON1 : '||L_DEF_EVC_MON);
          write_debug( g_debug_flag , ' L_COR_APP_MON2 : '||L_COR_APP_MON);
          write_debug( g_debug_flag , ' L_COR_DEF_MON3 : '||L_COR_DEF_MON);
          IF l_cor_def_mon       = 0 THEN
            L_AT_TS_INT_MONTHS := (l_def_evc_mon+1)+(l_cor_app_mon+1)-1;
          ELSE
            L_AT_TS_INT_MONTHS := (L_DEF_EVC_MON+1)+(L_COR_APP_MON+1);
          END IF;
        ELSIF L_TYPE_OF_RETURN      <> 'CORRECTED' THEN
          IF p_customer_trx_date     < '01-JUN-2016' THEN
            L_AT_TS_INT_MONTHS     := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))))+1;
            L_DELAY_MONTHS_100      := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (p_customer_trx_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (p_irt_due_date), 'DD-MON-YYYY'))));
          ELSIF p_customer_trx_date >= '01-JUN-2016' THEN
            L_AT_TS_INT_MONTHS     := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (p_refd_apr_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (p_customer_trx_date), 'DD-MON-YYYY'))))+1;
          END IF;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG , ' l_at_ts_int_months : '||L_AT_TS_INT_MONTHS);
        WRITE_DEBUG( G_DEBUG_FLAG , ' L_DELAY_MONTHS_100 : '||L_DELAY_MONTHS_100);
      END IF;
    ELSIF L_VAL_FILING_STATUS_CD IN ('R','T') THEN
      IF p_customer_trx_date      <= p_irt_due_date THEN -- within due date
        L_AT_TS_INT_MONTHS       := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (p_refd_apr_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))))+1;
        L_DELAY_MONTHS_100        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_current_filing_dt),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY')))) ;
      ELSIF p_customer_trx_date    > p_irt_due_date THEN -- after due date/belated return
        IF p_customer_trx_date     < '01-JUN-2016' THEN
          L_AT_TS_INT_MONTHS     := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (p_refd_apr_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY')))) +1;
          L_DELAY_MONTHS_100      := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_current_filing_dt),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (p_irt_due_date), 'DD-MON-YYYY'))));
        ELSIF p_customer_trx_date >= '01-JUN-2016' THEN
          L_AT_TS_INT_MONTHS     := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (p_refd_apr_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (p_customer_trx_date), 'DD-MON-YYYY'))))+1;
          L_DELAY_MONTHS_100      := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_current_filing_dt),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (p_customer_trx_date), 'DD-MON-YYYY')))) ;
        END IF;
      END IF;
      WRITE_DEBUG( G_DEBUG_FLAG , ' l_at_ts_int_months : '||L_AT_TS_INT_MONTHS);
      WRITE_DEBUG( G_DEBUG_FLAG , ' L_DELAY_MONTHS_100 : '||L_DELAY_MONTHS_100);
    ELSE
      write_debug( g_debug_flag , 'Invalid x_val_filing_status_cd: '||L_VAL_FILING_STATUS_CD);
    END IF;
    L_TOT_INT_MONTHS_100 := L_AT_TS_INT_MONTHS - L_DELAY_MONTHS_100;
    L_REC_INTEREST_AMT   := (P_RECEIPT_AMOUNT   * L_TOT_INT_MONTHS_100 * .5)/100;
    WRITE_DEBUG( G_DEBUG_FLAG , ' L_TOT_INT_MONTHS_100 : '||L_TOT_INT_MONTHS_100);
    write_debug( g_debug_flag , 'L_REC_INTEREST_AMT: '||L_REC_INTEREST_AMT);
    IF L_REC_INTEREST_AMT < 0 THEN
      L_REC_INTEREST_AMT := 0;
    END IF;
	 /*Added for 244A requirement Anjali*/
  UPDATE xx_REFD_LINES
            set ATTRIBUTE4     =ROUND(L_REC_INTEREST_AMT,0),
			  attribute12 	   =L_AT_TS_INT_MONTHS,
              attribute14      = L_DELAY_MONTHS_100, -- Added to store delay value due to 100 payment 
              attribute15      = L_DELAY_MONTHS_100  --  Added to store delay value due to 100 payment 
            WHERE REFERENCE_ID =p_reference_id
			and minor_head IN ('100', '200', 'XCL','PMR','SPI','5A','OTH');
	FND_FILE.PUT_LINE(FND_FILE.log,'Update Successful for records: '|| SQL%ROWCOUNT);
  write_debug( g_debug_flag , 'L_REC_INTEREST_AMT: '||L_REC_INTEREST_AMT);--Added for 244A requirement Anjali
    RETURN L_REC_INTEREST_AMT;
  EXCEPTION
  WHEN CUSTOM_EXCEPTION THEN
    L_REC_INTEREST_AMT :=-1;
    RETURN (L_REC_INTEREST_AMT);
    --Added as a Part of CR_HWSW_0552 - Ends Here - 22-JUN-2016
  END REFD_INTEREST_CALC_NEW;
-- ***************** End of Function / Procedure **********************--
-- Added function refd_interest_calc_new to calculate interest out of 100/200 - HF#171927 on 8-May-2018 - ends
  FUNCTION refd_interest_calc(
      P_IN_IRT_ID         IN VARCHAR2, --Added as a Part of Delay Interest Calculation
      p_reference_id      IN NUMBER,
      p_irt_assmt_year    IN VARCHAR2,
      p_receipt_amount    IN NUMBER,
      p_refd_apr_date   IN DATE,
      p_irt_due_date      IN DATE,
      p_customer_trx_date IN DATE )
    RETURN NUMBER
    /****************************************************************************
    ****************************************
    * Type                         : FUNCTION
    * Name                         : REFD_INTEREST_CALC
    * Input Parameters             :
    * Output Parameters             : Number
    * Purpose                     : To calculate the interest for Refd
    * Created Date                 : 12-Jan-2012
    * Last Reviewed By             :
    * Last Reviewed Date             :
    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    ----------------- --------------------------
    *****************************************************************************
    ***************************************/
  IS
    l_interest_amt      NUMBER := 0;
    l_total_receipt_amt NUMBER := 0;
    l_rate_of_interest  NUMBER;
    l_refd            NUMBER;
    l_no_of_months      NUMBER;
    l_due_months    NUMBER := 0;
    l_total_xx_comp    NUMBER;
    l_start_month       VARCHAR2 (11);
    l_date_diff         NUMBER;
    l_int_months        NUMBER;
    l_minus_int_months  NUMBER := 0;
    l_irt_due_date      DATE;
    --Declarations For Delayed Interest Calculation - Starts Here
    L_FILING_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DT%TYPE;
    L_FILING_DUE_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DUE_DT%TYPE;
    L_REVISED_FILING_DT IRT_STDCMP.INTEREST_ON_REFD.REVISED_FILING_DT%TYPE;
    L_IRTV_EVC_VALIDATED_DATE IRT_STDCMP.INTEREST_ON_REFD.IRTV_EVC_VALIDATED_DATE%TYPE;
    L_VAL_FILING_STATUS_CD IRT_STDCMP.INTEREST_ON_REFD.VAL_FILING_STATUS_CD%TYPE;
    L_TYPE_OF_RETURN IRT_STDCMP.INTEREST_ON_REFD.TYPE_OF_RETURN%type;
    L_ORIG_IRT_ID IRT_STDCMP.INTEREST_ON_REFD.ORIG_IRT_ID%TYPE;
    L_DEFECTIVE_COMM_SENT_DT IRT_STDCMP.INTEREST_ON_REFD.DEFECTIVE_COMM_SENT_DT%TYPE;
    L_CORRECTIVE_FILIING_DATE IRT_STDCMP.INTEREST_ON_REFD.CORRECTIVE_FILIING_DATE%TYPE;
    v_x_mode_of_filing_cd "process_store"."irt_process_control_mstr"."x_mode_of_filling_cd"@psql_process_fas%TYPE;
    --v_x_mode_of_filing_cd "process_store"."irt_process_control_mstr"."x_mode_of_filing_cd"@psql_process_fas%TYPE;
    L_REV_PRCSS_COUNT  NUMBER :=0;
    L_REV_PRCSS_COUNT1 NUMBER :=0;
    l_start_filing_mon NUMBER :=0;
    l_evc_app_mon      NUMBER :=0;
    l_fil_evc_mon      NUMBER :=0;
    l_def_evc_mon      NUMBER :=0;
    l_cor_def_mon      NUMBER :=0;
    l_tot_months       NUMBER :=0;
    l_start_revfil_mon NUMBER :=0;
    L_REVFIL_EVC_MON   NUMBER :=0;
    L_COR_APP_MON      NUMBER :=0;
    l_start_appr_mon   NUMBER :=0;
    L_FIL_DILDUE_MON   NUMBER :=0;
    L_REC_COUNT        NUMBER :=0;
    l_rect_chk         NUMBER :=0;
    L_DELAY_MONTH      NUMBER :=0;
    L_ORIGINAL_CHECK   NUMBER :=0;
    L_INPUT_ERR_FLAG   VARCHAR2 (11);                              --hotfix#158813
    L_RECT_FILE_DT IRT_STDCMP.INTEREST_ON_REFD.RECT_FILE_DT%type;--
    -- hotfix#158813
    CUSTOM_EXCEPTION   EXCEPTION;
    L_INP_ERR_FLG      VARCHAR2(100);
    LV_ID_NO          VARCHAR2(100);
    LV__ayr   VARCHAR2(100);
    L_PREV_INP_ERR_FLG VARCHAR2(100);
    LV_LOOP_ERR_FLG    VARCHAR2(100);
    L_ORIG_FILE_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DT%type;--hotfix#158813
  TYPE TMP_REC
IS
  RECORD
  (
    ORIG_IRT_ID VARCHAR2(100) );
TYPE TMP_TAB
IS
  TABLE OF TMP_REC;
  LV_TMP_TAB TMP_TAB;
  --Declarations For Delayed Interest Calculation - Ends Here
BEGIN
  write_debug( g_debug_flag , ' p_reference_id ' || p_reference_id );
  write_debug( g_debug_flag , ' p_irt_assmt_year ' ||p_irt_assmt_year );
  write_debug( g_debug_flag , ' p_receipt_amount ' ||p_receipt_amount );
  write_debug( g_debug_flag , ' p_customer_trx_date ' ||p_customer_trx_date );
  write_debug( g_debug_flag , ' p_irt_due_date ' || p_irt_due_date );
  write_debug( g_debug_flag , ' p_refd_apr_date ' ||p_refd_apr_date );
  L_START_MONTH := '01-APR-' || SUBSTR(P_IRT_ASSMT_YEAR,3,4);
  /*THIS CHECK IS ADDED BECAUSE FROM REFD_INTEREST IRT_ID
  ARE COMING WHICH CAN HAVE ACCOUNTING BEFORE
  INSERT WAS DONE IN THE  REFD TABLE*/
  --SELECT COUNT(1)
  --INTO L_ORIGINAL_CHECK
  --FROM "process_store"."irt_process_control_mstr"@psql_process_fas where IRT_ID=P_IN_IRT_ID
  --AND nvl(TRUNC(ACCT_COMPLETION_DT),'01-APR-2016') <'01-JUN-2016' and
  -- PROCESS_STATUS_CODE=65;  --Commented As part of HOTFIX#155618
  SELECT COUNT(1)
  INTO L_ORIGINAL_CHECK
 FROM "process_store"."irt_process_control_mstr"@psql_process_fas
  WHERE ( "id_number","assessment_year") IN
    (SELECT "id_number",
      "assessment_year"
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id"= P_IN_IRT_ID
    )
  AND "x_val_filing_status_cd"     ='O'
  AND TRUNC("x_acct_completion_dt") <'01-JUN-2016'
  AND "process_status_code"            =65;
  write_debug( g_debug_flag , ' Greater than Zer coming ' ||L_ORIGINAL_CHECK );
  IF(L_ORIGINAL_CHECK >0)--TO CHECK FOR ORIGINALS PROCESSED BEFORE INSERT INTO
    -- TABLE.--MASTER
    THEN
    BEGIN
      l_start_month := '01-APR-' || p_irt_assmt_year;
      l_int_months  := month_interest_calc (TO_DATE (l_start_month, 'DD-MON-YYYY'), p_refd_apr_date, 'xx_REFD_INTEREST_RATE' );
      write_debug( g_debug_flag , ' iNTEREST mONTH ' ||l_int_months );
      IF p_customer_trx_date > p_irt_due_date THEN
        BEGIN
          SELECT DECODE (p_irt_due_date, LAST_DAY (p_irt_due_date), p_irt_due_date + 1, p_irt_due_date )
          INTO l_irt_due_date
          FROM DUAL;
        END;
        l_minus_int_months := month_interest_calc (l_irt_due_date, p_customer_trx_date, 'xx_REFD_INTEREST_RATE' );
        write_msg( g_write_logfile , ' l_minus_int_months ' || l_minus_int_months );
      END IF;
      l_interest_amt :=((p_receipt_amount * (l_int_months - l_minus_int_months) ) / 100);--.5 is removed.--
      -- HOTFIX#155618
      write_debug( g_debug_flag , ' Refd Interest Computed is ' || l_interest_amt);
      RETURN (L_INTEREST_AMT);
    END;
  ELSE--MASTER IF (IF ANY THING IS COMING HERE IT HAS TO BE ACCOUNTED AFTER 1st
    -- June 2016)(THERE 0.5 is required)
    SELECT "filing_dt",
      "filing_due_dt",
      "revised_filing_dt",
      "irtv_evc_validated_date",
      "val_filing_status_cd",
      "orig_irt_id",
      "type_of_return",
      "defective_comm_sent_dt",
      "corrective_filiing_date"
    INTO L_FILING_DT,
      L_FILING_DUE_DT,
      L_REVISED_FILING_DT,
      L_IRTV_EVC_VALIDATED_DATE,
      L_VAL_FILING_STATUS_CD,
      L_ORIG_IRT_ID,
      L_TYPE_OF_RETURN,
      L_DEFECTIVE_COMM_SENT_DT,
      L_CORRECTIVE_FILIING_DATE
    FROM "process_store"."interest_on_refd"@psql_process_fas
    WHERE "irt_id"=P_IN_IRT_ID;
    BEGIN
      SELECT "x_mode_of_filling_cd"
      INTO V_X_MODE_OF_FILING_CD
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE "irt_id"                                                          =P_IN_IRT_ID;
      IF (V_X_MODE_OF_FILING_CD IN ('ED','PC') AND L_IRTV_EVC_VALIDATED_DATE IS NULL) THEN
        L_IRTV_EVC_VALIDATED_DATE                                          :=L_FILING_DT;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      RAISE CUSTOM_EXCEPTION;
    END;
    --Commented as a Part of Hotfix#135218 - On 17-Oct-2016 - Starts Here
    /*
    IF L_FILING_DT > L_FILING_DUE_DT THEN
    L_TOT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (
    P_REFD_APR_DATE),'DD-MON-YYYY')),
    LAST_DAY(TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))))+1;
    ELSE
    */
    --Commented as a Part of Hotfix#135218 - On 17-Oct-2016 - Ends Here
    --l_tot_months :=MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(P_REFD_APR_DATE )
    -- ,'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (l_start_month, 'MON-YYYY'),
    -- 'MON-YYYY'));
    L_TOT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_START_MONTH), 'DD-MON-YYYY'))))+1;
    --END IF; --Commented as a Part of Hotfix#135218 - On 17-Oct-2016
    BEGIN
      SELECT "x_mode_of_filling_cd"
      INTO V_X_MODE_OF_FILING_CD
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE "irt_id"                                                          =P_IN_IRT_ID;
      IF (V_X_MODE_OF_FILING_CD IN ('ED','PC') AND L_IRTV_EVC_VALIDATED_DATE IS NULL) THEN
        L_IRTV_EVC_VALIDATED_DATE                                          :=L_FILING_DT;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
      RAISE CUSTOM_EXCEPTION;
    END;
    write_debug( g_debug_flag , ' L_TOT_MONTHS : ' || L_TOT_MONTHS );
    write_debug( g_debug_flag , ' L_VAL_FILING_STATUS_CD : ' || L_VAL_FILING_STATUS_CD );
    WRITE_DEBUG( G_DEBUG_FLAG , ' L_TYPE_OF_RETURN : ' || L_TYPE_OF_RETURN );
    WRITE_DEBUG( G_DEBUG_FLAG , ' L_IRTV_EVC_VALIDATED_DATE : ' || L_IRTV_EVC_VALIDATED_DATE );
    WRITE_DEBUG( G_DEBUG_FLAG , ' V_X_MODE_OF_FILING_CD : ' || V_X_MODE_OF_FILING_CD );
    WRITE_DEBUG( G_DEBUG_FLAG , ' IRT_ID : ' || P_IN_IRT_ID );
    IF L_VAL_FILING_STATUS_CD = 'O' THEN
      IF L_FILING_DT         <= L_FILING_DUE_DT THEN
        IF L_TYPE_OF_RETURN  <> 'CORRECTED' THEN
          --l_start_filing_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_FILING_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- l_start_month, 'MON-YYYY'), 'MON-YYYY'));
          L_START_FILING_MON := TRUNC(MONTHS_BETWEEN(LAST_DAY( TO_DATE (TO_CHAR (L_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_START_MONTH), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_START_FILING_MON : ' || L_START_FILING_MON );
          -- l_evc_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
          L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_EVC_APP_MON : ' || L_EVC_APP_MON );
          --l_fil_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_IRTV_EVC_VALIDATED_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
          -- TO_CHAR (L_FILING_DT, 'MON-YYYY'), 'MON-YYYY'));
          L_FIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_FILING_DT), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_FIL_EVC_MON : ' || L_FIL_EVC_MON );
          IF l_fil_evc_mon > 0 THEN --Filing & Verification Happens in
            -- Different Months
            l_int_months := l_start_filing_mon+l_evc_app_mon+2;
          ELSE --Filing & Verification Happens in Same Months
            l_int_months := l_start_filing_mon+l_evc_app_mon+1;
          END IF;
          write_debug( g_debug_flag , ' l_int_months : ' || l_int_months );
          l_interest_amt := (p_receipt_amount * l_int_months * 0.5)/100;
          write_debug( g_debug_flag , ' l_interest_amt : ' || l_interest_amt );
        ELSE --IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
          write_debug( g_debug_flag , ' Inside Corrected : ');
          -- l_start_filing_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_FILING_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- l_start_month, 'MON-YYYY'), 'MON-YYYY'));
          L_START_FILING_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_START_MONTH), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_START_FILING_MON : '|| L_START_FILING_MON);
          --l_def_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
          -- TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
          L_DEF_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_DEF_EVC_MON : '||L_DEF_EVC_MON);
          --l_cor_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
          L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_COR_APP_MON : '||L_COR_APP_MON);
          --l_fil_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_IRTV_EVC_VALIDATED_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
          -- TO_CHAR (L_FILING_DT, 'MON-YYYY'), 'MON-YYYY'));
          L_FIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_FILING_DT), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_FIL_EVC_MON : '||L_FIL_EVC_MON);
          --l_cor_def_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
          -- TO_CHAR (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
          L_COR_DEF_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_DEFECTIVE_COMM_SENT_DT), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , ' L_COR_DEF_MON : '||L_COR_DEF_MON);
          IF l_fil_evc_mon      =0 AND l_cor_def_mon = 0 THEN
            l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) -2;
          ELSIF ((l_fil_evc_mon = 0 AND l_cor_def_mon > 0) OR ( l_fil_evc_mon > 0 AND l_cor_def_mon = 0 ) ) THEN
            l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) - 1;
          ELSE
            l_int_months := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1));
          END IF;
          write_debug( g_debug_flag , ' l_int_months : '||l_int_months);
          L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
          write_debug( g_debug_flag , ' L_INTEREST_AMT : '||L_INTEREST_AMT);
        END IF;
      ELSE --IF L_FILING_DT <= L_FILING_DUE_DT THEN
        IF L_FILING_DT         > L_FILING_DUE_DT THEN
          IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
            -- l_evc_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
            -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
            -- L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
            L_EVC_APP_MON  := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
            l_int_months   := l_evc_app_mon     +1;
            l_interest_amt := (p_receipt_amount * l_int_months * 0.5)/100;
          ELSE
            --l_def_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
            -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
            -- TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
            L_DEF_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
            -- l_cor_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
            -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
            -- L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
            L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
            --l_cor_def_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
            -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
            -- TO_CHAR (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
            L_COR_DEF_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
            write_debug( g_debug_flag , ' L_DEF_EVC_MON1 : '||L_DEF_EVC_MON);
            write_debug( g_debug_flag , ' L_COR_APP_MON2 : '||L_COR_APP_MON);
            write_debug( g_debug_flag , ' L_COR_DEF_MON3 : '||L_COR_DEF_MON);
            IF l_cor_def_mon = 0 THEN
              l_int_months  := (l_def_evc_mon+1)+(l_cor_app_mon+1)-1;
            ELSE
              l_int_months := (l_def_evc_mon+1)+(l_cor_app_mon+1);
            END IF;
            l_interest_amt := (p_receipt_amount * l_int_months * 0.5)/100;
            write_debug( g_debug_flag , ' l_interest_amt4 : '||l_interest_amt);
          END IF;
        END IF;
      END IF;
      /*START OF HOTFIX#137819*/
    ELSIF L_VAL_FILING_STATUS_CD = 'R' THEN --IF L_VAL_FILING_STATUS_CD = 'O'
      -- THEN
      L_REV_PRCSS_COUNT :=0;
      SELECT COUNT(1)
      INTO L_REV_PRCSS_COUNT
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE ( "id_number","assessment_year") IN
        (SELECT "id_number",
          "assessment_year"
        FROM "process_store"."irt_process_control_mstr"@psql_process_fas
        WHERE "irt_id"=P_IN_IRT_ID
        )
      AND "x_val_filing_status_cd"      ='O'
      AND TRUNC("x_acct_completion_dt") <'01-JUN-2016'
      AND "process_status_code"            =65;
      IF L_REV_PRCSS_COUNT          > 0 -- ORIGINAL WAS PROCESSED BEFORE 1st
        -- JUNE SO no delay calculation normal flow.
        THEN
        --Added to handle revised records and its original processed before 01-
        -- JUN-2016 - starts here
        L_INT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_START_MONTH), 'DD-MON-YYYY'))))+1;
        write_debug( g_debug_flag , ' iNTEREST mONTH ' ||l_int_months );
        IF p_customer_trx_date > p_irt_due_date THEN
          BEGIN
            SELECT DECODE (p_irt_due_date, LAST_DAY (p_irt_due_date), p_irt_due_date + 1, p_irt_due_date )
            INTO l_irt_due_date
            FROM DUAL;
          END;
          l_minus_int_months := month_interest_calc (to_date(l_irt_due_date, 'DD-MON-RRRR'), to_date(p_customer_trx_date,'DD-MON-RRRR'), 'xx_REFD_INTEREST_RATE' )*2;
          write_msg( g_write_logfile , ' l_minus_int_months ' || l_minus_int_months );
        END IF;
        l_interest_amt :=((p_receipt_amount * (l_int_months -
        l_minus_int_months))                / 100);--  Uncommented as part of
        -- HOTFIX#137109
        --    l_interest_amt :=((p_receipt_amount * (l_int_months -
        -- l_minus_int_months-l_delay_month)) *.5/ 100); --Modified as a Part
        -- of Delayed attribute
        WRITE_DEBUG( G_DEBUG_FLAG , ' Refd Interest Computed is ' || L_INTEREST_AMT);
        --Added to handle revised records and its original processed before 01-
        -- JUN-2016 - Ends here
      ELSE                                     -- ORIGINAL IS PROCESSED AFTER 1st June Delay Calculation.
        IF L_FILING_DT         <= L_FILING_DUE_DT THEN --1
          IF L_TYPE_OF_RETURN  <> 'CORRECTED' THEN     --2
            L_START_REVFIL_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_REVISED_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))));
            L_EVC_APP_MON      :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
            L_REVFIL_EVC_MON   := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_REVISED_FILING_DT), 'DD-MON-YYYY'))));
            IF l_revfil_evc_mon > 0 THEN --Filing & Verification Happens in
              -- Different Months
              l_int_months := l_start_revfil_mon+l_evc_app_mon+2;
            ELSE --Filing & Verification Happens in Same Months
              l_int_months := l_start_revfil_mon+l_evc_app_mon+1;
            END IF;
            --   l_interest_amt := (p_receipt_amount * (l_int_months-
            -- l_delay_month) * 0.5)/100;
            l_interest_amt := (p_receipt_amount * (l_int_months) * 0.5)/100;--
            -- Delay Month is commented as calculation takes care of delay
            -- months.
            WRITE_DEBUG( G_DEBUG_FLAG , ' Refd Interest Computed is ' || L_INTEREST_AMT);
          ELSE --IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
            L_START_FILING_MON   := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_REVISED_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))));
            L_DEF_EVC_MON        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
            L_COR_APP_MON        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
            L_FIL_EVC_MON        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_REVISED_FILING_DT), 'DD-MON-YYYY'))));
            L_COR_DEF_MON        := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
            IF l_fil_evc_mon      =0 AND l_cor_def_mon = 0 THEN
              l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) -2;
            ELSIF ((l_fil_evc_mon = 0 AND l_cor_def_mon > 0) OR ( l_fil_evc_mon > 0 AND l_cor_def_mon = 0 ) ) THEN
              l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) - 1;
            ELSE
              l_int_months := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1));
            END IF;
            -- l_interest_amt := (p_receipt_amount * (l_int_months-
            -- l_delay_month) * 0.5)/100; Commented as part of Hotfix#137109
            l_interest_amt := (p_receipt_amount * (l_int_months) * 0.5)/100;
            WRITE_DEBUG( G_DEBUG_FLAG , ' Refd Interest Computed is ' || L_INTEREST_AMT);
            /*l_int_months takes care of delay also*/
          END IF;                              --2
        ELSE                                   --IF L_FILING_DT <= L_FILING_DUE_DT THEN--1
          IF L_FILING_DT         > L_FILING_DUE_DT THEN--3
            IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN    --4
              L_EVC_APP_MON     := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
              L_INT_MONTHS      := L_EVC_APP_MON     +1;
              l_interest_amt    := (p_receipt_amount * l_int_months * 0.5)/100;
              WRITE_DEBUG( G_DEBUG_FLAG , ' Refd Interest Computed is ' || L_INTEREST_AMT);
            ELSE
              L_DEF_EVC_MON   := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
              L_COR_APP_MON   := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
              L_COR_DEF_MON   := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
              IF l_cor_def_mon = 0 THEN
                l_int_months  := (l_def_evc_mon+1)+(l_cor_app_mon+1)-1;
              ELSE
                l_int_months := (l_def_evc_mon+1)+(l_cor_app_mon+1);
              END IF;
              l_interest_amt := (p_receipt_amount * l_int_months * 0.5)/100;
              WRITE_DEBUG( G_DEBUG_FLAG , ' Refd Interest Computed is ' || L_INTEREST_AMT);
            END IF;--4
          END IF;  --3
        END IF;    --1
      END IF;      --ORIGINAL WAS PROCESSED BEFORE 1st JUNE SO no delay
      -- calculation normal flow.
      /*END OF HOTFIX#137819*/
    ELSE
      IF L_VAL_FILING_STATUS_CD = 'T' THEN
        SELECT COUNT(1)
        INTO L_REC_COUNT
        FROM "process_store"."irt_process_control_mstr"@psql_process_fas
        WHERE ( "id_number","assessment_year" ) IN
          (SELECT "id_number",
            "assessment_year"
          FROM "process_store"."irt_process_control_mstr"@psql_process_fas
          WHERE "irt_id"=P_IN_IRT_ID
          )
        AND "x_val_filing_status_cd"       ='O'
        AND TRUNC("x_acct_completion_dt") >='01-JUN-2016'
        AND "process_status_code"             =65;
        write_debug( g_debug_flag , ' L_REC_COUNT ' ||L_REC_COUNT );
        IF L_REC_COUNT > 0 THEN
          SELECT "input_err_flag",
            "id_cd",
            "assment_year",
            "orig_irt_id"
          INTO L_INP_ERR_FLG,
            LV_ID_NO,
            LV__ayr,
            L_ORIG_IRT_ID
          FROM "process_store"."interest_on_refd"@psql_process_fas
          WHERE "irt_id" = P_IN_IRT_ID;
          WRITE_DEBUG( G_DEBUG_FLAG , ' P_IN_IRT_ID ' ||P_IN_IRT_ID );
          write_debug( g_debug_flag , ' L_INP_ERR_FLG ' ||L_INP_ERR_FLG );
          write_debug( g_debug_flag , ' LV_ID_NO ' ||LV_ID_NO );
          write_debug( g_debug_flag , ' LV__ayr ' ||LV__ayr ) ;
          write_debug( g_debug_flag , ' L_ORIG_IRT_ID ' ||L_ORIG_IRT_ID );
          IF L_INP_ERR_FLG = 'N' THEN
            SELECT NVL("input_err_flag",'N')
            INTO L_PREV_INP_ERR_FLG
            FROM "process_store"."interest_on_refd"@psql_process_fas
            WHERE "irt_id" = L_ORIG_IRT_ID;
            write_debug( g_debug_flag , ' L_PREV_INP_ERR_FLG ' || L_PREV_INP_ERR_FLG );
            IF L_PREV_INP_ERR_FLG = 'Y' THEN
              SELECT "orig_irt_id" BULK COLLECT
              INTO LV_TMP_TAB
              FROM "process_store"."interest_on_refd"@psql_process_fas
              WHERE "id_cd"     = LV_ID_NO
              AND "assment_year" = LV__ayr
              AND "orig_irt_id"  < L_ORIG_IRT_ID
              ORDER BY "orig_irt_id" DESC;
              FOR I IN 1.. LV_TMP_TAB.LAST
              LOOP
                SELECT NVL("input_err_flag",'N')
                INTO LV_LOOP_ERR_FLG
                FROM "process_store"."interest_on_refd"@psql_process_fas
                WHERE "irt_id" = LV_TMP_TAB(I).ORIG_IRT_ID;
                WRITE_DEBUG( G_DEBUG_FLAG , ' LV_LOOP_ERR_FLG ' || LV_LOOP_ERR_FLG );
                WRITE_DEBUG( G_DEBUG_FLAG , ' L_INP_ERR_FLG ' ||L_INP_ERR_FLG ) ;
                -- DBMS_OUTPUT.PUT_LINE('LV_TMP_TAB(I).IRT_ID'||LV_TMP_TAB(I)
                -- .IRT_ID);
                IF LV_LOOP_ERR_FLG = 'N' THEN
                  L_ORIG_IRT_ID   := LV_TMP_TAB(I).ORIG_IRT_ID;
                  WRITE_DEBUG( G_DEBUG_FLAG , ' L_ORIG_IRT_ID assignment' || L_ORIG_IRT_ID );
                  EXIT;
                END IF;
              END LOOP;
            ELSE
              L_ORIG_IRT_ID := L_ORIG_IRT_ID;
            END IF;
          END IF;
          ----------------------------------------------------CHANGES END
          --------------------------------
          l_minus_int_months :=0;
          SELECT COUNT(1)
          INTO L_RECT_CHK
          FROM "process_store"."interest_on_refd"@psql_process_fas
          WHERE "irt_id"        =L_ORIG_IRT_ID
          AND "delayed_months" IS NOT NULL;
          write_debug( g_debug_flag , ' L_RECT_CHK if delayed months is not null' ||L_RECT_CHK );
          IF L_RECT_CHK > 0 THEN
            BEGIN
              SELECT "delayed_months"
              INTO l_delay_month
              FROM "process_store"."interest_on_refd"@psql_process_fas
              WHERE "irt_id"=L_ORIG_IRT_ID;
            EXCEPTION
            WHEN OTHERS THEN
              RAISE CUSTOM_EXCEPTION;
            END;
            write_debug( g_debug_flag , ' L_DELAY_MONTH calculated' || L_DELAY_MONTH );
            /*HOTFIX#158813 Start*/
            BEGIN
              SELECT "rect_file_dt",
                "input_err_flag"
              INTO L_RECT_FILE_DT,
                L_INPUT_ERR_FLAG
              FROM "process_store"."interest_on_refd"@psql_process_fas
              WHERE "irt_id" = P_IN_IRT_ID;
              WRITE_DEBUG( G_DEBUG_FLAG , ' L_RECT_FILE_DT ' ||L_RECT_FILE_DT || ' L_INPUT_ERR_FLAG ' ||L_INPUT_ERR_FLAG );
              IF P_CUSTOMER_TRX_DATE > P_IRT_DUE_DATE AND L_INP_ERR_FLG = 'N' THEN
                SELECT "irt_id"
                INTO L_ORIG_IRT_ID
                FROM "process_store"."irt_process_control_mstr"@psql_process_fas
                WHERE ( "id_number","assessment_year" ) IN
                  (SELECT "id_number",
                    "assessment_year"
                  FROM "process_store"."irt_process_control_mstr"@psql_process_fas
                  WHERE "irt_id"=P_IN_IRT_ID
                  )
                AND "x_val_filing_status_cd"       ='O'
                AND TRUNC("x_acct_completion_dt") >='01-JUN-2016'
                AND "process_status_code"             =65;
                SELECT "filing_dt"
                INTO L_ORIG_FILE_DT
                FROM "process_store"."interest_on_refd"@psql_process_fas
                WHERE "irt_id"   =L_ORIG_IRT_ID;
                L_START_MONTH := L_ORIG_FILE_DT;
                L_DELAY_MONTH :=0;
                WRITE_DEBUG( G_DEBUG_FLAG , ' L_DELAY_MONTH  INSIDE THE NEW COND' ||L_DELAY_MONTH );
                WRITE_DEBUG( G_DEBUG_FLAG , ' L_START_MONTH ' ||L_START_MONTH ) ;
              END IF;
              IF (L_RECT_FILE_DT IS NULL) OR ( L_INPUT_ERR_FLAG IS NULL ) THEN
                RAISE CUSTOM_EXCEPTION;
              END IF;
            EXCEPTION
            WHEN OTHERS THEN
              DBMS_OUTPUT.PUT_LINE( 'L_RECT_FILE_DT,L_INPUT_ERR_FLAG :- NOT PROPER');
              RAISE CUSTOM_EXCEPTION;
            END;
            IF(L_INPUT_ERR_FLAG = 'Y') THEN
              -- DBMS_OUTPUT.PUT_LINE('Since Input Flag is enabled we will give
              -- interest from rect_file_dt till accnt_completion of rect');
              WRITE_DEBUG( G_DEBUG_FLAG , 'Since Input Flag is enabled we will give interest from rect_file_dt till accnt_completion of rect' );
              L_START_MONTH := L_RECT_FILE_DT;
              L_DELAY_MONTH :=0;
              --   L_DELAY_MONTH := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (
              -- TO_CHAR (L_RECT_FILE_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (
              -- TO_CHAR (p_customer_trx_date), 'DD-MON-YYYY'))));
              --  DBMS_OUTPUT.PUT_LINE('L_DELAY_MONTH:-+'||L_DELAY_MONTH);
              WRITE_DEBUG( G_DEBUG_FLAG , ' L_DELAY_MONTH ' ||L_DELAY_MONTH );
              WRITE_DEBUG( G_DEBUG_FLAG , ' L_START_MONTH ' ||L_DELAY_MONTH );
              -- DBMS_OUTPUT.PUT_LINE('L_START_MONTH:-+'||L_START_MONTH);
            END IF; --IF(L_INPUT_ERR_FLAG = 'Y') THEN
            ----------------------------------------------------------------------
            ------  End Of Hotfix#158813 ---------------
          ELSE--L_RECT_CHK
            RAISE CUSTOM_EXCEPTION;
          END IF;
        ELSE
          l_delay_month         :=0;
          IF P_CUSTOMER_TRX_DATE > P_IRT_DUE_DATE THEN
            WRITE_MSG( G_WRITE_LOGFILE , ' l_minus_int_months inside the loop vishnu ' ||L_MINUS_INT_MONTHS );
            WRITE_MSG( G_WRITE_LOGFILE , ' l_minus_int_months inside the loop vishnu ' ||P_IRT_DUE_DATE );
            WRITE_MSG( G_WRITE_LOGFILE , ' l_minus_int_months inside the loop vishnu ' ||P_CUSTOMER_TRX_DATE );
            WRITE_MSG( G_WRITE_LOGFILE , ' l_minus_int_months inside the loop vishnu ' ||L_START_MONTH );
            WRITE_MSG( G_WRITE_LOGFILE , ' l_minus_int_months inside the loop vishnu ' ||P_IN_IRT_ID );
            BEGIN
              SELECT DECODE (p_irt_due_date, LAST_DAY (p_irt_due_date), p_irt_due_date + 1, p_irt_due_date )
              INTO l_irt_due_date
              FROM DUAL;
            END;
            l_minus_int_months := month_interest_calc (to_date(l_irt_due_date, 'DD-MON-RRRR'), to_date(p_customer_trx_date,'DD-MON-RRRR'), 'xx_REFD_INTEREST_RATE' )*2;
            /*L_MINUS_INT_MONTHS := TRUNC(MONTHS_BETWEEN( TO_DATE (TO_CHAR (
            P_CUSTOMER_TRX_DATE),'DD-MON-YYYY'),
            TO_DATE (TO_CHAR (L_IRT_DUE_DATE), 'DD-MON-YYYY')));*/
            WRITE_MSG( G_WRITE_LOGFILE , ' l_minus_int_months1111 ' || L_MINUS_INT_MONTHS );
          END IF;
        END IF; --IF L_REC_COUNT        > 0 THEN
        --l_int_months := month_interest_calc (TO_DATE (l_start_month, 'DD-MON-
        -- YYYY'), p_refd_apr_date, 'xx_REFD_INTEREST_RATE' );
        WRITE_DEBUG( G_DEBUG_FLAG , ' P_REFD_APR_DATE ' ||P_REFD_APR_DATE ) ;
        write_debug( g_debug_flag , ' L_START_MONTH ' ||L_START_MONTH );
        write_debug( g_debug_flag , ' L_INT_MONTHS ' ||l_int_months );
        WRITE_DEBUG( G_DEBUG_FLAG , ' L_MINUS_INT_MONTHS ' ||L_MINUS_INT_MONTHS );
        WRITE_DEBUG( G_DEBUG_FLAG , ' L_DELAY_MONTH ' ||L_DELAY_MONTH );
        WRITE_DEBUG( G_DEBUG_FLAG , ' P_RECEIPT_AMOUNT is ' || P_RECEIPT_AMOUNT );
        L_INT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( P_REFD_APR_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_START_MONTH), 'DD-MON-YYYY'))))+1;
        write_debug( g_debug_flag , ' iNTEREST mONTH1111111 ' ||l_int_months );
        --l_interest_amt :=((p_receipt_amount * (l_int_months -
        -- l_minus_int_months)) / 100);
        L_INTEREST_AMT :=((P_RECEIPT_AMOUNT * (L_INT_MONTHS -
        L_MINUS_INT_MONTHS                  -L_DELAY_MONTH)) *.5/ 100); --
        -- Modified as a Part of Delayed attribute .5 cannot be removed as
        -- l_minus_int_months will never come as master if should not allow it.
        WRITE_DEBUG( G_DEBUG_FLAG , ' P_RECEIPT_AMOUNT is ' || P_RECEIPT_AMOUNT );
        --WRITE_DEBUG( G_DEBUG_FLAG , ' L_MINUS_INT_MONTHS is ' ||
        -- L_MINUS_INT_MONTHS);
        -- write_debug( g_debug_flag , ' L_DELAY_MONTH is ' || L_DELAY_MONTH);
        write_debug( g_debug_flag , ' Refd Interest Computed is ' || l_interest_amt);
      END IF;
    END IF;
    --write_debug( g_debug_flag , 'l_int_months : ' || l_int_months);
    --  WRITE_DEBUG( G_DEBUG_FLAG , 'l_tot_months : ' || L_TOT_MONTHS);
    -- write_debug( g_debug_flag , 'l_start_month : ' || l_start_month);
    RETURN (L_INTEREST_AMT);
  END IF; --MASTER IF
EXCEPTION
WHEN CUSTOM_EXCEPTION THEN
  L_INTEREST_AMT :=-1;
  RETURN (L_INTEREST_AMT);
END refd_interest_calc;
PROCEDURE DELAY_ATTRIBUTE_CALC(
    P_OUT_CHR_ERRBUFF OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2 ,
    P_IN_IRT_ID      IN VARCHAR2, --Added as a Part of Delay Interest Calculation
    P_IRT_ASSMT_YEAR IN VARCHAR2 )
  /****************************************************************************
  ****************************************
  * Type                         : FUNCTION
  * Name                         : REFD_INTEREST_CALC
  * Input Parameters             :
  * Output Parameters             : Number
  * Purpose                     : To calculate the interest for Refd
  *
  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  *****************************************************************************
  ***************************************/
IS
  l_interest_amt      NUMBER := 0;
  l_total_receipt_amt NUMBER := 0;
  l_rate_of_interest  NUMBER;
  l_refd            NUMBER;
  l_no_of_months      NUMBER;
  l_due_months    NUMBER := 0;
  l_total_xx_comp    NUMBER;
  l_start_month       VARCHAR2 (11);
  l_date_diff         NUMBER;
  l_int_months        NUMBER;
  l_minus_int_months  NUMBER := 0;
  L_IRT_DUE_DATE      DATE;
  l_chr_proc_name     VARCHAR2(150) :='';
  --Declarations For Delayed Interest Calculation - Starts Here
  L_FILING_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DT%TYPE;
  L_ORIG_FILING_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DT%TYPE; --Added for
  -- Hotfix 158813
  L_ORIG_DUE_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DUE_DT%TYPE; --Added for
  -- Hotfix 158813
  L_FILING_DUE_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DUE_DT%TYPE;
  L_REVISED_FILING_DT IRT_STDCMP.INTEREST_ON_REFD.REVISED_FILING_DT%TYPE;
  L_IRTV_EVC_VALIDATED_DATE IRT_STDCMP.INTEREST_ON_REFD.IRTV_EVC_VALIDATED_DATE%TYPE;
  L_VAL_FILING_STATUS_CD IRT_STDCMP.INTEREST_ON_REFD.VAL_FILING_STATUS_CD%TYPE;
  L_ORIG_IRT_ID IRT_STDCMP.INTEREST_ON_REFD.ORIG_IRT_ID%TYPE;
  L_TYPE_OF_RETURN IRT_STDCMP.INTEREST_ON_REFD.TYPE_OF_RETURN%TYPE;
  L_DEFECTIVE_COMM_SENT_DT IRT_STDCMP.INTEREST_ON_REFD.DEFECTIVE_COMM_SENT_DT%TYPE;
  L_CORRECTIVE_FILIING_DATE IRT_STDCMP.INTEREST_ON_REFD.CORRECTIVE_FILIING_DATE%TYPE;
  V_MODE_OF_FILING_CD IRT_STDCMP.INTEREST_ON_REFD.MODE_OF_FILING%TYPE;
  L_REV_PRCSS_COUNT   NUMBER :=0;
  L_REV_PRCSS_COUNT1  NUMBER :=0;
  l_start_filing_mon  NUMBER :=0;
  l_evc_app_mon       NUMBER :=0;
  l_fil_evc_mon       NUMBER :=0;
  l_def_evc_mon       NUMBER :=0;
  l_cor_def_mon       NUMBER :=0;
  l_tot_months        NUMBER :=0;
  l_start_revfil_mon  NUMBER :=0;
  L_REVFIL_EVC_MON    NUMBER :=0;
  L_COR_APP_MON       NUMBER :=0;
  l_start_appr_mon    NUMBER :=0;
  L_FIL_DILDUE_MON    NUMBER :=0;
  L_REC_COUNT         NUMBER :=0;
  l_rect_chk          NUMBER :=0;
  L_DELAY_MONTH       NUMBER :=0;
  CUSTOM_EXCEPTION    EXCEPTION;
  P_CUSTOMER_TRX_DATE DATE;
  P_IRT_DUE_DATE      DATE;
  L_CHR_ERRBUFF       VARCHAR2(150) :='';
  L_CHR_RETCODE       NUMBER;
  L_REF_CNT           NUMBER :=0;                                --Added as a Part of Hotfix#135218
  L_INPUT_ERR_FLAG    VARCHAR2 (11);                             --hotfix#158813
  L_RECT_FILE_DT IRT_STDCMP.INTEREST_ON_REFD.RECT_FILE_DT%type;--
  -- hotfix#158813
  --Declarations For Delayed Interest Calculation - Ends Here
  l_irt_approval_date xx_ar_trans_stg.irt_approval_date%type; --Added for Hotfix_199485 on 13-MAR-2019
  l_num_irt   Number;  
BEGIN
l_num_irt := to_number(P_IN_IRT_ID);   --Added for ABC-2.0 Bhagya
  write_debug( g_debug_flag , ' coming inside ' ||p_irt_assmt_year );
  --write_debug( g_debug_flag , ' p_reference_id DAC' || p_reference_id );
  write_debug( g_debug_flag , ' p_irt_assmt_year DAC' ||p_irt_assmt_year );
  --write_debug( g_debug_flag , ' p_receipt_amount DAC' ||p_receipt_amount );
  -- write_debug( g_debug_flag , ' p_customer_trx_date DAC' ||
  -- p_customer_trx_date );
  --write_debug( g_debug_flag , ' p_irt_due_date DAC' || p_irt_due_date );
  -- write_debug( g_debug_flag , ' p_refd_apr_date DAC' ||p_refd_apr_date )
  -- ;
  write_debug( g_debug_flag , 'irt_id : DAC'||P_IN_IRT_ID);
  l_chr_proc_name :='DELAY_ATTRIBUTE_CALC';
  l_start_month   := '01-APR-' || SUBSTR(p_irt_assmt_year,3,4);
  SELECT "filing_dt",
    "filing_due_dt",
    "revised_filing_dt",
    "irtv_evc_validated_date",
    "val_filing_status_cd",
    "orig_irt_id",
    "type_of_return",
    "defective_comm_sent_dt",
    "corrective_filiing_date"
  INTO L_FILING_DT,
    L_FILING_DUE_DT,
    L_REVISED_FILING_DT,
    L_IRTV_EVC_VALIDATED_DATE,
    L_VAL_FILING_STATUS_CD,
    L_ORIG_IRT_ID,
    L_TYPE_OF_RETURN,
    L_DEFECTIVE_COMM_SENT_DT,
    L_CORRECTIVE_FILIING_DATE
  FROM "process_store"."interest_on_refd"@psql_process_fas
  WHERE "irt_id"=TO_CHAR(P_IN_IRT_ID);
  BEGIN
    SELECT "x_mode_of_filling_cd"
    INTO V_MODE_OF_FILING_CD
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id"                 =P_IN_IRT_ID;
    IF (V_MODE_OF_FILING_CD      ='ED' AND L_IRTV_EVC_VALIDATED_DATE IS NULL) THEN
      L_IRTV_EVC_VALIDATED_DATE :=L_FILING_DT;
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    RAISE CUSTOM_EXCEPTION;
  END;
  P_CUSTOMER_TRX_DATE :=L_FILING_DT;
  p_irt_due_date      :=L_FILING_DUE_DT;
  write_debug( g_debug_flag , 'L_FILING_DT : '||L_FILING_DT);
  write_debug( g_debug_flag , 'L_FILING_DUE_DT : '||L_FILING_DUE_DT);
  write_debug( g_debug_flag , 'L_TYPE_OF_RETURN : '||L_TYPE_OF_RETURN);
  write_debug( g_debug_flag , 'L_START_MONTH : '||L_START_MONTH);
  --L_TOT_MONTHS :=MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(P_REFD_APR_DATE),'
  -- MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (L_START_MONTH, 'MON-YYYY'), '
  -- MON-YYYY'));
  --Added for Hotfix_199485 on 13-MAR-2019--START--
  BEGIN
    SELECT DISTINCT IRT_APPROVAL_DATE
    INTO l_irt_approval_date
    FROM xx_ar_trans_stg
    WHERE TRANSACTION_NUMBER=p_in_irt_id;
  EXCEPTION
  WHEN OTHERS THEN
    RAISE CUSTOM_EXCEPTION;
  END;
  --Added for Hotfix_199485 on 13-MAR-2019--END--
  --L_TOT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (SYSDATE), 'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY')))) +1;  --Commented for Hotfix_199485 on 13-MAR-2019
  L_TOT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date), 'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY')))) +1; --Added for Hotfix_199485 on 13-MAR-2019
  write_debug( g_debug_flag , 'L_TOT_MONTHS : '||L_TOT_MONTHS);
  write_debug( g_debug_flag , 'L_VAL_FILING_STATUS_CD : '|| L_VAL_FILING_STATUS_CD);
  IF L_VAL_FILING_STATUS_CD = 'O' THEN
    IF L_FILING_DT         <= L_FILING_DUE_DT THEN
      IF L_TYPE_OF_RETURN  <> 'CORRECTED' THEN
        --    L_START_FILING_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR ((
        -- L_FILING_DT ),'MON-YYYY')), TO_DATE (TO_CHAR (L_START_MONTH, 'MON-
        -- YYYY')));
        L_START_FILING_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH) , 'DD-MON-YYYY'))));
        write_debug( g_debug_flag , 'l_start_filing_mon : '||L_START_FILING_MON );
        --L_EVC_APP_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR ((P_REFD_APR_DATE
        -- ),'MON-YYYY')), TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-
        -- YYYY')));
        --L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Commented for Hotfix_199485 on 13-MAR-2019
        L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
        write_debug( g_debug_flag , 'l_evc_app_mon : '||L_EVC_APP_MON);
        --L_FIL_EVC_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR ((
        -- L_IRTV_EVC_VALIDATED_DATE ),'MON-YYYY')), TO_DATE (TO_CHAR (
        -- L_FILING_DT, 'MON-YYYY')));
        L_FIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_FILING_DT), 'DD-MON-YYYY'))));
        write_debug( g_debug_flag , 'L_FIL_EVC_MON : '||L_FIL_EVC_MON);
        IF l_fil_evc_mon > 0 THEN --Filing & Verification Happens in Different
          -- Months
          l_int_months := l_start_filing_mon+l_evc_app_mon+2;
        ELSE --Filing & Verification Happens in Same Months
          l_int_months := l_start_filing_mon+l_evc_app_mon+1;
        END IF;
        write_debug( g_debug_flag , 'l_int_months : '||L_INT_MONTHS);
        --    L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
        write_debug( g_debug_flag , 'L_INTEREST_AMT : '||L_INTEREST_AMT);
      ELSE --IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
        write_debug( g_debug_flag , 'L_VAL_FILING_STATUS_CD : '|| L_VAL_FILING_STATUS_CD);
        write_debug( g_debug_flag , 'IF L_TYPE_OF_RETURN CORRECTED THEN');
        --l_start_filing_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- L_FILING_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
        -- l_start_month, 'MON-YYYY'), 'MON-YYYY'));
        L_START_FILING_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH) , 'DD-MON-YYYY'))));
        --l_def_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
        -- TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
        L_DEF_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
        --l_cor_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
        -- L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
        --L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));  --Commented for Hotfix_199485 on 13-MAR-2019
        L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));--Added for Hotfix_199485 on 13-MAR-2019
        --l_fil_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- L_IRTV_EVC_VALIDATED_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
        -- TO_CHAR (L_FILING_DT, 'MON-YYYY'), 'MON-YYYY'));
        L_FIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_FILING_DT), 'DD-MON-YYYY'))));
        --l_cor_def_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
        -- TO_CHAR (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
        L_COR_DEF_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT), 'DD-MON-YYYY'))));
        write_debug( g_debug_flag , 'l_start_filing_mon : '||l_start_filing_mon );
        write_debug( g_debug_flag , 'l_def_evc_mon : '||l_def_evc_mon);
        write_debug( g_debug_flag , 'l_cor_app_mon : '||l_cor_app_mon);
        write_debug( g_debug_flag , 'l_fil_evc_mon : '||l_fil_evc_mon);
        write_debug( g_debug_flag , 'l_cor_def_mon : '||l_cor_def_mon);
        IF l_fil_evc_mon      =0 AND l_cor_def_mon = 0 THEN
          l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) -2;
        ELSIF ((l_fil_evc_mon = 0 AND l_cor_def_mon > 0) OR ( l_fil_evc_mon > 0 AND l_cor_def_mon = 0 ) ) THEN
          l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) - 1;
        ELSE
          l_int_months := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1));
        END IF;
        write_debug( g_debug_flag , 'l_int_months : '||L_INT_MONTHS);
        --L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
        write_debug( g_debug_flag , 'L_TYPE_OF_RETURN CORRECTED L_INTEREST_AMT : '||L_INTEREST_AMT);
      END IF;
    ELSE --IF L_FILING_DT <= L_FILING_DUE_DT THEN
      write_debug( g_debug_flag , 'IF L_FILING_DT <= L_FILING_DUE_DT THEN....') ;
      write_debug( g_debug_flag , 'L_VAL_FILING_STATUS_CD : '|| L_VAL_FILING_STATUS_CD);
      write_debug( g_debug_flag , 'L_TYPE_OF_RETURN : '||L_TYPE_OF_RETURN);
      IF L_FILING_DT         > L_FILING_DUE_DT THEN
        IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
          --L_EVC_APP_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
          --L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));--Commented for Hotfix_199485 on 13-MAR-2019
          L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
          write_debug( g_debug_flag , 'L_EVC_APP_MON : '||L_EVC_APP_MON);
          L_INT_MONTHS := L_EVC_APP_MON+1;
          write_debug( g_debug_flag , 'L_INT_MONTHS : '||L_INT_MONTHS);
          --    L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
          write_debug( g_debug_flag , 'L_INTEREST_AMT : '||L_INTEREST_AMT);
        ELSE
          --l_def_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
          -- TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
          L_DEF_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
          --l_cor_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
          --L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));  --Commented for Hotfix_199485 on 13-MAR-2019
          L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
          --l_cor_def_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
          -- TO_CHAR (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
          L_COR_DEF_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
          write_debug( g_debug_flag , 'l_def_evc_mon : '||l_def_evc_mon);
          write_debug( g_debug_flag , 'l_cor_app_mon : '||l_cor_app_mon);
          write_debug( g_debug_flag , 'l_cor_def_mon : '||l_cor_def_mon);
          IF l_cor_def_mon = 0 THEN
            l_int_months  := (l_def_evc_mon+1)+(l_cor_app_mon+1)-1;
          ELSE
            l_int_months := (l_def_evc_mon+1)+(l_cor_app_mon+1);
          END IF;
          write_debug( g_debug_flag , 'l_int_months : '||L_INT_MONTHS);
          --L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
          write_debug( g_debug_flag , 'L_INTEREST_AMT : '||L_INTEREST_AMT);
        END IF;
      END IF;
    END IF;
  ELSIF L_VAL_FILING_STATUS_CD = 'R' THEN --IF L_VAL_FILING_STATUS_CD = 'O'
    -- THEN
    L_REV_PRCSS_COUNT :=0;
    fnd_file.put_line(fnd_file.log,'L_VAL_FILING_STATUS_CD : '|| L_VAL_FILING_STATUS_CD);
    SELECT COUNT(1)
    INTO L_REV_PRCSS_COUNT
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id"                   =L_ORIG_IRT_ID
    AND "process_status_code"             =65
    AND TRUNC("x_acct_completion_dt") >='01-JUN-2016';
    fnd_file.put_line(fnd_file.log,'L_REV_PRCSS_COUNT : '||L_REV_PRCSS_COUNT);
    fnd_file.put_line(fnd_file.log,'L_TYPE_OF_RETURN : '||L_TYPE_OF_RETURN);
    IF L_REV_PRCSS_COUNT   > 0 THEN
      IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
        --L_EVC_APP_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
        -- L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
        --L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));  --Commented for Hotfix_199485 on 13-MAR-2019
        L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
        fnd_file.put_line(fnd_file.log,'L_EVC_APP_MON : '||L_EVC_APP_MON);
        L_INT_MONTHS := L_EVC_APP_MON+1;
        fnd_file.put_line(fnd_file.log,'L_INT_MONTHS : '||L_INT_MONTHS);
        --L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
        fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '||L_INTEREST_AMT);
      ELSE
        --l_start_revfil_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- L_REVISED_FILING_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
        -- l_start_month, 'MON-YYYY'), 'MON-YYYY'));
        L_START_REVFIL_MON := TRUNC(MONTHS_BETWEEN(LAST_DAY( TO_DATE (TO_CHAR ( L_REVISED_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_START_MONTH), 'DD-MON-YYYY'))));
        --l_evc_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
        -- L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
        --L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));--Commented for Hotfix_199485 on 13-MAR-2019
        L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
        --l_revfil_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- L_IRTV_EVC_VALIDATED_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
        -- TO_CHAR (L_REVISED_FILING_DT, 'MON-YYYY'), 'MON-YYYY'));
        L_REVFIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_REVISED_FILING_DT), 'DD-MON-YYYY'))));
        fnd_file.put_line(fnd_file.log,'l_start_revfil_mon : '|| l_start_revfil_mon);
        fnd_file.put_line(fnd_file.log,'l_evc_app_mon : '||l_evc_app_mon);
        fnd_file.put_line(fnd_file.log,'l_revfil_evc_mon : '||l_revfil_evc_mon) ;
        IF l_revfil_evc_mon > 0 THEN --Filing & Verification Happens in
          -- Different Months
          l_int_months := l_start_revfil_mon+l_evc_app_mon+2;
        ELSE --Filing & Verification Happens in Same Months
          l_int_months := l_start_revfil_mon+l_evc_app_mon+1;
        END IF;
        fnd_file.put_line(fnd_file.log,'L_INT_MONTHS : '||L_INT_MONTHS);
        --L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
        fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '||L_INTEREST_AMT);
      END IF;
    ELSIF L_REV_PRCSS_COUNT = 0 THEN
      SELECT COUNT(1)
      INTO L_REV_PRCSS_COUNT1
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE "irt_id"                  =L_ORIG_IRT_ID
      AND "process_status_code"            =65
      AND TRUNC("x_acct_completion_dt") <'01-JUN-2016';
      fnd_file.put_line(fnd_file.log,'L_REV_PRCSS_COUNT1 : '|| L_REV_PRCSS_COUNT1);
      fnd_file.put_line(fnd_file.log,'L_FILING_DT : '||L_FILING_DT);
      fnd_file.put_line(fnd_file.log,'L_FILING_DUE_DT : '||L_FILING_DUE_DT);
      IF L_REV_PRCSS_COUNT1 > 0 THEN
        IF L_FILING_DT     <= L_FILING_DUE_DT THEN
          --L_START_APPR_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- L_START_MONTH, 'MON-YYYY'), 'MON-YYYY'));
          --L_START_APPR_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))));  --Commented for Hotfix_199485 on 13-MAR-2019
          L_START_APPR_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
          fnd_file.put_line(fnd_file.log,'L_START_APPR_MON : '|| L_START_APPR_MON);
          L_INT_MONTHS := L_START_APPR_MON+1;
          fnd_file.put_line(fnd_file.log,'L_INT_MONTHS : '||L_INT_MONTHS);
          --    L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
          fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '||L_INTEREST_AMT);
        ELSE
          IF L_FILING_DT > L_FILING_DUE_DT THEN
            --l_start_appr_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
            -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
            -- l_start_month, 'MON-YYYY'), 'MON-YYYY'));
            --L_START_APPR_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH ), 'DD-MON-YYYY'))));  --Commented for Hotfix_199485 on 13-MAR-2019
            L_START_APPR_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH ), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
            --L_FIL_DILDUE_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
            -- L_FILING_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
            -- L_FILING_DUE_DT, 'MON-YYYY'), 'MON-YYYY'));
            L_FIL_DILDUE_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_FILING_DUE_DT), 'DD-MON-YYYY'))));
            fnd_file.put_line(fnd_file.log,'l_start_appr_mon : '|| l_start_appr_mon);
            fnd_file.put_line(fnd_file.log,'L_FIL_DILDUE_MON : '|| L_FIL_DILDUE_MON);
            L_INT_MONTHS := (L_START_APPR_MON+1)-(L_FIL_DILDUE_MON+1);
            fnd_file.put_line(fnd_file.log,'L_INT_MONTHS : '||L_INT_MONTHS);
            --    L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100
            -- ;
            fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '||L_INTEREST_AMT) ;
          END IF;
        END IF;
      ELSE
        IF L_REV_PRCSS_COUNT1 = 0 THEN
          IF L_FILING_DT     <= L_FILING_DUE_DT THEN
            fnd_file.put_line(fnd_file.log, 'if L_FILING_DT <= L_FILING_DUE_DT then ');
            IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
              --l_start_revfil_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- L_REVISED_FILING_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
              -- TO_CHAR (l_start_month, 'MON-YYYY'), 'MON-YYYY'));
              L_START_REVFIL_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_REVISED_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))));
              --l_evc_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR
              -- (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
              --L_EVC_APP_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Commented for Hotfix_199485 on 13-MAR-2019
              L_EVC_APP_MON :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
              --l_revfil_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- L_IRTV_EVC_VALIDATED_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE
              -- (TO_CHAR (L_REVISED_FILING_DT, 'MON-YYYY'), 'MON-YYYY'));
              L_REVFIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY( TO_DATE (TO_CHAR (L_REVISED_FILING_DT), 'DD-MON-YYYY'))));
              fnd_file.put_line(fnd_file.log,'l_start_revfil_mon : '|| l_start_revfil_mon);
              fnd_file.put_line(fnd_file.log,'l_evc_app_mon : '||l_evc_app_mon) ;
              fnd_file.put_line(fnd_file.log,'l_revfil_evc_mon : '|| l_revfil_evc_mon);
              IF L_REVFIL_EVC_MON > 0 THEN --Filing & Verification Happens in
                -- Different Months
                l_int_months := l_start_revfil_mon+l_evc_app_mon+2-( l_revfil_evc_mon +1);
              ELSE --Filing & Verification Happens in Same Months
                l_int_months := l_start_revfil_mon+l_evc_app_mon+1-
                l_revfil_evc_mon;
              END IF;
              fnd_file.put_line(fnd_file.log,'l_int_months : '||L_INT_MONTHS);
              --L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
              fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '|| L_INTEREST_AMT);
            ELSE --IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
              --l_start_filing_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- L_REVISED_FILING_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
              -- TO_CHAR (l_start_month, 'MON-YYYY'), 'MON-YYYY'));
              L_START_FILING_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_REVISED_FILING_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))));
              --l_def_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
              -- TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'));
              L_DEF_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));
              --l_cor_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR
              -- (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
              --L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY')))); --Commented for Hotfix_199485 on 13-MAR-2019
              L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
              --l_fil_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- L_IRTV_EVC_VALIDATED_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE
              -- (TO_CHAR (L_REVISED_FILING_DT, 'MON-YYYY'), 'MON-YYYY'));
              L_FIL_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_REVISED_FILING_DT), 'DD-MON-YYYY'))));
              --l_cor_def_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
              -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
              -- TO_CHAR (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'));
              L_COR_DEF_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE ( TO_CHAR (L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));
              fnd_file.put_line(fnd_file.log,'l_start_filing_mon : '|| l_start_filing_mon);
              fnd_file.put_line(fnd_file.log,'l_def_evc_mon : '||l_def_evc_mon) ;
              fnd_file.put_line(fnd_file.log,'l_cor_app_mon : '||l_cor_app_mon) ;
              fnd_file.put_line(fnd_file.log,'l_fil_evc_mon : '||l_fil_evc_mon) ;
              fnd_file.put_line(fnd_file.log,'l_cor_def_mon : '||l_cor_def_mon) ;
              IF l_fil_evc_mon      =0 AND l_cor_def_mon = 0 THEN
                l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) -2;
              ELSIF ((l_fil_evc_mon = 0 AND l_cor_def_mon > 0) OR ( l_fil_evc_mon > 0 AND l_cor_def_mon = 0 ) ) THEN
                l_int_months       := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1)) - 1;
              ELSE
                l_int_months := ((l_start_filing_mon+1)+(l_def_evc_mon+1)+( l_cor_app_mon +1));
              END IF;
              fnd_file.put_line(fnd_file.log,'l_int_months : '||L_INT_MONTHS);
              --L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)/100;
              fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '|| L_INTEREST_AMT);
            END IF;
          ELSE --IF L_FILING_DT <= L_FILING_DUE_DT THEN
            IF L_FILING_DT         > L_FILING_DUE_DT THEN
              IF L_TYPE_OF_RETURN <> 'CORRECTED' THEN
                --L_EVC_APP_MON := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
                -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
                -- TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY')
                -- );
                --L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY'))));--Commented for Hotfix_199485 on 13-MAR-2019
                L_EVC_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
                fnd_file.put_line(fnd_file.log,'L_EVC_APP_MON : '|| L_EVC_APP_MON);
                L_INT_MONTHS := L_EVC_APP_MON+1;
                fnd_file.put_line(fnd_file.log,'L_INT_MONTHS : '||L_INT_MONTHS) ;
                --    L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)
                -- /100;
                fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '|| L_INTEREST_AMT);
              ELSE
                --l_def_evc_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
                -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE
                -- (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE, 'MON-YYYY'), 'MON-YYYY'
                -- ));
                L_DEF_EVC_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY( TO_DATE (TO_CHAR (L_IRTV_EVC_VALIDATED_DATE), 'DD-MON-YYYY')))) ;
                --l_cor_app_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
                -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
                -- TO_CHAR (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY')
                -- );
                --L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (SYSDATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY'))));  --Commented for Hotfix_199485 on 13-MAR-2019
                L_COR_APP_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (l_irt_approval_date),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY')))); --Added for Hotfix_199485 on 13-MAR-2019
                --l_cor_def_mon := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
                -- L_DEFECTIVE_COMM_SENT_DT ),'MON-YYYY'), 'MON-YYYY'), TO_DATE
                -- (TO_CHAR (L_CORRECTIVE_FILIING_DATE, 'MON-YYYY'), 'MON-YYYY'
                -- ));
                L_COR_DEF_MON := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_DEFECTIVE_COMM_SENT_DT),'DD-MON-YYYY')), LAST_DAY( TO_DATE (TO_CHAR (L_CORRECTIVE_FILIING_DATE), 'DD-MON-YYYY')))) ;
                fnd_file.put_line(fnd_file.log,'l_def_evc_mon : '|| l_def_evc_mon);
                fnd_file.put_line(fnd_file.log,'l_cor_app_mon : '|| l_cor_app_mon);
                fnd_file.put_line(fnd_file.log,'l_cor_def_mon : '|| l_cor_def_mon);
                IF l_cor_def_mon = 0 THEN
                  l_int_months  := (l_def_evc_mon+1)+(l_cor_app_mon+1)-1;
                ELSE
                  l_int_months := (l_def_evc_mon+1)+(l_cor_app_mon+1);
                END IF;
                fnd_file.put_line(fnd_file.log,'L_INT_MONTHS : '||L_INT_MONTHS) ;
                --    L_INTEREST_AMT := (P_RECEIPT_AMOUNT * L_INT_MONTHS * 0.5)
                -- /100;
                fnd_file.put_line(fnd_file.log,'L_INTEREST_AMT : '|| L_INTEREST_AMT);
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  ELSE
    IF L_VAL_FILING_STATUS_CD = 'T' THEN
      fnd_file.put_line(fnd_file.log,'L_VAL_FILING_STATUS_CD : '|| L_VAL_FILING_STATUS_CD);
      SELECT COUNT(1)
      INTO L_REC_COUNT
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE ( "id_number","assessment_year" ) IN
        (SELECT "id_number",
          "assessment_year"
        FROM "process_store"."irt_process_control_mstr"@psql_process_fas
        WHERE "irt_id"=P_IN_IRT_ID
        )
      AND "x_val_filing_status_cd"       ='O'
      AND TRUNC("x_acct_completion_dt") >='01-JUN-2016'
      AND "process_status_code"             =65;
      FND_FILE.PUT_LINE(FND_FILE.log,'L_REC_COUNT : '||L_REC_COUNT);
      FND_FILE.PUT_LINE(FND_FILE.log,'P_IN_IRT_ID : '||P_IN_IRT_ID);
      FND_FILE.PUT_LINE(FND_FILE.log,'P_CUSTOMER_TRX_DATE :1111 '|| P_CUSTOMER_TRX_DATE);
      IF L_REC_COUNT        > 0 THEN
        l_minus_int_months :=0;
        SELECT COUNT(1)
        INTO l_rect_chk
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id"        =L_ORIG_IRT_ID
        AND "delayed_months" IS NOT NULL;

        BEGIN
          SELECT DISTINCT TO_DATE (rat.attribute14, 'DD-MON-YYYY'),
            TO_DATE (rat.attribute13, 'DD-MON-YYYY')
          INTO P_CUSTOMER_TRX_DATE,
            P_IRT_DUE_DATE
          FROM ra_customer_trx_all rat
          WHERE rat.attribute11=P_IN_IRT_ID;
          fnd_file.put_line(fnd_file.log,'P_CUSTOMER_TRX_DATE : '|| P_CUSTOMER_TRX_DATE);
          fnd_file.put_line(fnd_file.log,'P_IRT_DUE_DATE : '||P_IRT_DUE_DATE);
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
          L_CHR_RETCODE     :=G_CHR_FAILURE_CODE;
          l_chr_errbuff     :='DATA IS NOT THERE IN RA_CUSTOMER_TRX_ALL';
          p_out_chr_errbuff := 'DATA IS NOT THERE IN RA_CUSTOMER_TRX_ALL' || l_chr_proc_name ||'-' || '-' ||SUBSTR(sqlerrm,1,255);
          WRITE_MSG( G_WRITE_LOGFILE ,P_OUT_CHR_ERRBUFF );
        END;
        /* END OF HOTFIX #138195*/
        IF p_customer_trx_date > p_irt_due_date THEN
          BEGIN
            SELECT DECODE (p_irt_due_date, LAST_DAY (p_irt_due_date), p_irt_due_date + 1, p_irt_due_date )
            INTO l_irt_due_date
            FROM DUAL;
          END;
          --L_MINUS_INT_MONTHS := ACCOUNTING_PKG.MONTH_INTEREST_CALC
          -- (TO_DATE(L_IRT_DUE_DATE,'DD-MON-RRRR'), TO_DATE(
          -- P_CUSTOMER_TRX_DATE,'DD-MON-RRRR'), 'xx_REFD_INTEREST_RATE' )
          -- ;
          --L_MINUS_INT_MONTHS :=MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
          -- P_CUSTOMER_TRX_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
          -- L_IRT_DUE_DATE, 'MON-YYYY'), 'MON-YYYY'));
          l_minus_int_months := month_interest_calc (to_date(l_irt_due_date, 'DD-MON-RRRR'), to_date(p_customer_trx_date,'DD-MON-RRRR'), 'xx_REFD_INTEREST_RATE' )*2;
          fnd_file.put_line(fnd_file.log,'L_MINUS_INT_MONTHS : '|| L_MINUS_INT_MONTHS);
          --    write_msg( g_write_logfile , ' l_minus_int_months ' ||
          -- l_minus_int_months );
        END IF;
      END IF;
      fnd_file.put_line(fnd_file.log,'l_delay_month : '||l_delay_month);
      --L_INT_MONTHS := ACCOUNTING_PKG.MONTH_INTEREST_CALC (TO_DATE (
      -- L_START_MONTH, 'DD-MON-YYYY'), P_REFD_APR_DATE, '
      -- xx_REFD_INTEREST_RATE' );
      --L_INT_MONTHS := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
      -- P_REFD_APR_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (
      -- L_START_MONTH, 'MON-YYYY'), 'MON-YYYY'));
      --L_INT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (SYSDATE) ,'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))))+1;  --Commented for Hotfix_199485 on 13-MAR-2019
      L_INT_MONTHS := TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (l_irt_approval_date) ,'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_START_MONTH), 'DD-MON-YYYY'))))+1; --Added for Hotfix_199485 on 13-MAR-2019
      fnd_file.put_line(fnd_file.log,'L_INT_MONTHS : '||L_INT_MONTHS);
      --write_debug( g_debug_flag , ' iNTEREST mONTH ' ||l_int_months );
      --l_interest_amt :=((p_receipt_amount * (l_int_months -
      -- l_minus_int_months)) / 100);
      --    l_interest_amt :=((p_receipt_amount * (l_int_months -
      -- l_minus_int_months-l_delay_month)) / 100); --Modified as a Part of
      -- Delayed attribute
      --    write_debug( g_debug_flag , ' Refd Interest Computed is ' ||
      -- l_interest_amt);
      ---changed accordingly for hot fix 158813 starts---
      BEGIN
        SELECT "rect_file_dt",
          NVL("input_err_flag",'X')
        INTO L_RECT_FILE_DT,
          L_INPUT_ERR_FLAG
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id"        = P_IN_IRT_ID;
        IF (L_RECT_FILE_DT IS NULL OR L_INPUT_ERR_FLAG = 'X') THEN
          RAISE CUSTOM_EXCEPTION;
        END IF;
      EXCEPTION
      WHEN CUSTOM_EXCEPTION THEN
        raise CUSTOM_EXCEPTION;
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('L_RECT_FILE_DT,L_INPUT_ERR_FLAG :- NOT PROPER');
        RAISE CUSTOM_EXCEPTION;
      END;
      ---changed accordingly for hot fix 158813  ends---
    END IF;
  END IF;
  L_REF_CNT :=0;
  SELECT COUNT(1)
  INTO L_REF_CNT
  FROM xx_REFD_HEADERS
  WHERE IRT_ID =P_IN_IRT_ID;
  IF L_REF_CNT > 0 THEN
    ----**** Start of Changes added for Hotfix 158813 ******-----
    IF L_INPUT_ERR_FLAG = 'Y' THEN
      BEGIN
        SELECT "filing_dt",
          "filing_due_dt"
        INTO L_ORIG_FILING_DT,
          L_ORIG_DUE_DT
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "id_cd" =
          (SELECT "id_cd"
          FROM "process_store"."interest_on_refd"@psql_process_fas
          WHERE "irt_id" = P_IN_IRT_ID
          AND ROWNUM   = 1
          )
        AND "assment_year"        = P_IRT_ASSMT_YEAR
        AND "val_filing_status_cd" = 'O'
        AND ROWNUM               = 1;
      EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error deriving L_ORIG_FILING_DT,L_ORIG_DUE_DT: ' ||L_ORIG_FILING_DT||L_ORIG_DUE_DT);
        RAISE CUSTOM_EXCEPTION;
      END;
      IF (L_ORIG_FILING_DT < L_ORIG_DUE_DT) OR ( L_ORIG_FILING_DT = L_ORIG_DUE_DT ) THEN
        UPDATE xx_REFD_HEADERS
        SET IRT_FILING_DELAY_MNTHS = TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_RECT_FILE_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( '01-APR-'
          || SUBSTR(P_IRT_ASSMT_YEAR,3,4)), 'DD-MON-YYYY'))))
        WHERE IRT_ID = P_IN_IRT_ID;
        WRITE_DEBUG( G_DEBUG_FLAG , 'IRT_FILING_DELAY_MNTHS vishnu if : ' || L_RECT_FILE_DT||---||TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (
        -- L_RECT_FILE_DT),'DD-MON-YYYY')),
        LAST_DAY(TO_DATE (TO_CHAR ('01-APR-' || SUBSTR(P_IRT_ASSMT_YEAR,3,4)), 'DD-MON-YYYY')));
      ELSE
        UPDATE xx_REFD_HEADERS
        SET IRT_FILING_DELAY_MNTHS = TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE ( TO_CHAR (L_RECT_FILE_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ( L_FILING_DT), 'DD-MON-YYYY'))))
        WHERE IRT_ID               = P_IN_IRT_ID;
        WRITE_DEBUG( G_DEBUG_FLAG , 'IRT_FILING_DELAY_MNTHS vishnu else : ' || L_RECT_FILE_DT||---||TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (
        -- L_RECT_FILE_DT),'DD-MON-YYYY')),
        LAST_DAY(TO_DATE (TO_CHAR ('01-APR-' || SUBSTR(P_IRT_ASSMT_YEAR,3,4)), 'DD-MON-YYYY')));
      END IF;
      ----**** End of Changes added for Hotfix 158813 ******-----
    ELSE
      UPDATE xx_REFD_HEADERS
      SET
        --IRT_FILING_DELAY_MNTHS = (DECODE(L_VAL_FILING_STATUS_CD,'T',(
        -- L_MINUS_INT_MONTHS+L_DELAY_MONTH),'R',(L_TOT_MONTHS-(L_INT_MONTHS+
        -- L_DELAY_MONTH)),L_TOT_MONTHS-L_INT_MONTHS)) --Commented as a Part of
        -- Hotfix#135218 on 17-Oct-2016
        --IRT_FILING_DELAY_MNTHS = (DECODE(L_VAL_FILING_STATUS_CD,'T',(
        -- L_MINUS_INT_MONTHS+NVL(L_DELAY_MONTH,0)),'R',(L_TOT_MONTHS-(
        -- L_INT_MONTHS+NVL(L_DELAY_MONTH,0))),L_TOT_MONTHS-L_INT_MONTHS)) --
        -- Commented as a Part of Hotfix#135218 On 17-Oct-2016
        IRT_FILING_DELAY_MNTHS = (DECODE(L_VAL_FILING_STATUS_CD,'T',( L_MINUS_INT_MONTHS+NVL(L_DELAY_MONTH,0)),L_TOT_MONTHS-L_INT_MONTHS)) --
        -- Modified as a Part of Hotfix#135218 On 17-Oct-2016
      WHERE IRT_ID = P_IN_IRT_ID;
      WRITE_DEBUG( G_DEBUG_FLAG , 'IRT_FILING_DELAY_MNTHS vishnu : ' || 'update' );
    END IF;
  END IF;
  write_debug( g_debug_flag , 'l_int_months : ' || l_int_months);
  write_debug( g_debug_flag , 'l_tot_months : ' || l_tot_months);
  WRITE_DEBUG( G_DEBUG_FLAG , 'l_start_month : ' || L_START_MONTH);
  ----**** Start of Changes added for Hotfix 158813 ******-----
  IF L_INPUT_ERR_FLAG = 'Y' THEN
    BEGIN
      SELECT "filing_dt",
        "filing_due_dt"
      INTO L_ORIG_FILING_DT,
        L_ORIG_DUE_DT
      FROM "process_store"."interest_on_refd"@psql_process_fas
      WHERE "id_cd" =
        (SELECT "id_cd"
        FROM"process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id" = P_IN_IRT_ID
        AND ROWNUM   = 1
        )
      AND "assment_year"        = P_IRT_ASSMT_YEAR
      AND "val_filing_status_cd" = 'O'
      AND ROWNUM               = 1;
    EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error deriving L_ORIG_FILING_DT,L_ORIG_DUE_DT: '|| L_ORIG_FILING_DT||L_ORIG_DUE_DT);
      RAISE CUSTOM_EXCEPTION;
    END;	
    IF (L_ORIG_FILING_DT < L_ORIG_DUE_DT) OR ( L_ORIG_FILING_DT = L_ORIG_DUE_DT ) THEN	
      UPDATE "process_store"."interest_on_refd"@psql_process_fas
      SET "no_of_months"    =l_int_months,
        "total_no_of_mnths" =l_tot_months,
        "assment_start_date"=l_start_month,
        "delayed_months" = TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_RECT_FILE_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR ('01-APR-'
        || SUBSTR(P_IRT_ASSMT_YEAR,3,4)), 'DD-MON-YYYY'))))
      WHERE "irt_id" =l_num_irt;--P_IN_IRT_ID;
    ELSE
      UPDATE "process_store"."interest_on_refd"@psql_process_fas
      SET "no_of_months"    =l_int_months,
        "total_no_of_mnths" =l_tot_months,
        "assment_start_date"=l_start_month,
        "delayed_months" = TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR ( L_RECT_FILE_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (L_FILING_DT ), 'DD-MON-YYYY'))))
      WHERE "irt_id"    =l_num_irt;--P_IN_IRT_ID;

    END IF;
    ----**** End of Changes added for Hotfix 158813 ******-----
  ELSE
    UPDATE "process_store"."interest_on_refd"@psql_process_fas
    SET "no_of_months"    =l_int_months,
      "total_no_of_mnths" =l_tot_months,
      "assment_start_date"=l_start_month,
      "delayed_months"=(DECODE("val_filing_status_cd",'T',(l_minus_int_months+NVL( l_delay_month,0)),(l_tot_months - l_int_months))) --Modified as a Part of Hotfix#135218 On 17-Oct-2016
    WHERE "irt_id"    =l_num_irt;--P_IN_IRT_ID;
    --RETURN (L_INTEREST_AMT);
  END IF;
EXCEPTION
WHEN CUSTOM_EXCEPTION THEN
  P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
  L_CHR_RETCODE     :=G_CHR_FAILURE_CODE;
  l_chr_errbuff     :='No Entry in Refd Interest Table';
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || '-' || SUBSTR(sqlerrm,1,255);
  WRITE_MSG( G_WRITE_LOGFILE ,P_OUT_CHR_ERRBUFF );
  --Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode =>
  -- l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => 'DL_100' ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL ,p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff);
    END IF;
  END IF;
END DELAY_ATTRIBUTE_CALC;
-- ***************** End of Function / Procedure **********************--
FUNCTION dmd_interest_calc(
    p_receipt_date     IN DATE,
    p_dmd_serv_date IN DATE,
    p_apply_amount     IN NUMBER,
    p_irt_assmt_year   IN VARCHAR2 )
  RETURN NUMBER
  /****************************************************************************
  ****************************************
  * Type : FUNCTION
  * Name : DMD_INTEREST_CALC
  * Input Parameters :
  * Output Parameters : Number
  * Purpose : To calculate the interest for Dmd
  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  *****************************************************************************
  ***************************************/
IS
  l_interest_amt     NUMBER := 0;
  l_rate_of_interest NUMBER;
  l_no_of_months     NUMBER;
  l_date_diff        NUMBER;
  l_int_month        NUMBER := 0;
  l_end_date         DATE;
  l_start_date       DATE;
  l_count            NUMBER;
BEGIN
  BEGIN
    l_int_month := month_interest_calc (p_dmd_serv_date, p_receipt_date, 'xx_DMD_INTEREST_RATE' );
  EXCEPTION
  WHEN OTHERS THEN
    RETURN -5;
  END;
  l_interest_amt := ((p_apply_amount * l_int_month) / 100);
  write_debug( g_debug_flag , ' Dmd Interest Computed is ' || l_interest_amt );
  RETURN (ROUND (L_INTEREST_AMT, 0));
END dmd_interest_calc;
-- ***************** End of Function / Procedure **********************--
PROCEDURE insert_odd_details_proc(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_overdue_amt       IN NUMBER,
    p_in_curr_overdue_amt  IN NUMBER,
    p_in_dem_due_date      IN DATE,
    p_in_last_int_calc_dte IN DATE,
    p_in_cust_trx_id       IN NUMBER,
    p_in_irt_id            IN VARCHAR2 )
AS
  /****************************************************************************
  ****************************************
  * Type : Procedure
  * Name : INSERT_ODD_DETAILS_PROC
  * Input Parameters : None
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Input Parameters : p_in_overdue_amt
  * p_in_curr_overdue_amt
  * p_in_dem_due_date
  * p_in_last_int_calc_dte
  * Purpose : Procedure to Insert in Over Due Dmd Details

  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  ----------------- ---------------------
  *****************************************************************************
  */
  --
  l_num_odd_seq_num NUMBER;
BEGIN
  p_out_chr_retcode := g_chr_success_code;
  SELECT xx_odd_seq_num.NEXTVAL INTO l_num_odd_seq_num FROM DUAL;
  INSERT
  INTO xx_overdue_dem_details
    (
      l_sequence_no,
      overdue_dem_amt,
      curr_overdue_amt,
      dem_due_date,
      int_calc_to_month,
      customer_trx_id,
      created_by,
      creation_date,
      last_update_login,
      last_updated_by,
      request_id,
      irt_id
    )
    VALUES
    (
      l_num_odd_seq_num,
      p_in_overdue_amt,
      p_in_curr_overdue_amt,
      p_in_dem_due_date,
      p_in_last_int_calc_dte,
      p_in_cust_trx_id,
      g_num_user_id,
      g_dte_sys_date,
      g_num_user_id,
      g_num_user_id,
      g_num_request_id,
      p_in_irt_id
    );
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error In Insert ODD Details Proc ' || SUBSTR ( SQLERRM, 1, 180 ) ;
  write_msg ( g_write_logfile ,'Error in insert_odd_details_proc:'|| SUBSTR (SQLERRM, 1, 180) ) ;
END insert_odd_details_proc;
-- ***************** End of Function / Procedure **********************--
FUNCTION get_irt_trx_id
  (
    p_cash_receipt_id IN NUMBER,
    p_customer_number IN VARCHAR2,
    p_assmt_year      IN VARCHAR2,
    p_major_head      IN VARCHAR2,
    p_minor_head      IN VARCHAR2,
    P_TRX_TYPE        IN VARCHAR2,
    p_in_irt_sch_type IN VARCHAR2 -- Added for 661
  )
  RETURN NUMBER
  /****************************************************************************
  ****************************************
  * Type : FUNCTION
  * Name : Get_IRT_TRX_ID
  * Input Parameters :
  * Output Parameters : Number
  * Purpose : To return the Receivables Transaction id for the collection
  *
  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  ----------------- --------------------------
  *****************************************************************************
  ***************************************/
IS
  l_num_customer_trx_id NUMBER;
  l_trx_type            VARCHAR2 ( 20 ) := p_trx_type;
  l_assmt_year          NUMBER;
BEGIN
  IF l_trx_type = 'TS' THEN
    SELECT MAX (TO_NUMBER (attribute4))
    INTO l_assmt_year
    FROM ra_customer_trx_all
    WHERE attribute9     = 'PCM CLOSED'
    AND attribute5       = p_customer_number
    AND ( ( p_major_head = '0020'
    AND attribute1       = p_major_head
      --AND DECODE (attribute7, 'DDT', '106', 'IT', '-1', '-1') = DECODE (
      -- p_minor_head, '106', '106', '-1' ) )
    AND DECODE (attribute7, 'DDT', '106','BBS','107', 'IT', '-1', '-1') = DECODE (p_minor_head, '106', '106','107','107', '-1' ) ) --Modified for BBS
    OR ( p_major_head                                                  <> '0020'
    AND attribute1                                                      = p_major_head ) );
    SELECT customer_trx_id
    INTO l_num_customer_trx_id
    FROM ra_customer_trx_all
    WHERE attribute9                                                    = 'PCM CLOSED'
    AND TO_NUMBER (attribute4)                                          = l_assmt_year
    AND attribute5                                                      = p_customer_number
    AND ( ( p_major_head                                                = '0020'
    AND attribute1                                                      = p_major_head
    AND DECODE (attribute7, 'DDT', '106','BBS','107', 'IT', '-1', '-1') = DECODE (p_minor_head, '106', '106','107','107', '-1' ) ) --Modified for BBS
    OR ( p_major_head                                                  <> '0020'
    AND attribute1                                                      = p_major_head ) );
  ELSE
    BEGIN
      SELECT customer_trx_id
      INTO l_num_customer_trx_id
      FROM ra_customer_trx_all
      WHERE attribute5     = p_customer_number
      AND attribute4       = p_assmt_year
      AND attribute9       = 'PCM CLOSED'
      AND ( ( p_major_head = '0020'
      AND attribute1       = p_major_head
        --AND DECODE (attribute7, 'DDT', '106', 'IT', '-1', '-1' ) = DECODE
        -- (p_minor_head, '106', '106', '-1' ) )
      AND DECODE (attribute7, 'DDT', '106','BBS','107', 'IT', '-1', '-1' ) = DECODE (p_minor_head, '106', '106','107','107', '-1' ) ) --Modified for BBS
      OR ( p_major_head                                                   <> '0020'
      AND attribute1                                                       = p_major_head ) )
      AND attribute7                                                       = p_in_irt_sch_type; -- Added for 661
    EXCEPTION
    WHEN OTHERS THEN
      RETURN -1;
    END;
  END IF;
  WRITE_DEBUG( G_DEBUG_FLAG , 'l_num_customer_trx_id: '||l_num_customer_trx_id);
  RETURN l_num_customer_trx_id;
END get_irt_trx_id;
--********************** End of Function / Procedure **********************
-----------
PROCEDURE interest_recpt_proc(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    in_num_reference_id   IN NUMBER,
    in_num_receipt_amount IN NUMBER,
    in_chr_flag           IN VARCHAR2,
    in_chr_irt_id         IN VARCHAR2 )
  /****************************************************************************
  ****************************************
  * Type : PROCEDURE
  * Name : INTEREST_RECPT_PROC
  * Input Parameters : in_num_reference_id , in_num_receipt_amount ,in_chr_flag
  , in_chr_irt_id
  * Output Parameters : out_chr_errbuff, out_chr_retcode
  * Purpose : To create receipt on refd interest
  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  ---------------- ------------------------
  *************************************************************************/
AS
  l_chr_proc_name       VARCHAR2 (50);
  l_chr_exe_location    VARCHAR2 (10);
  l_stmt_processing     VARCHAR2 (50);
  t_output              VARCHAR2 (2000);
  t_msg_dummy           VARCHAR2 (2000);
  l_chr_major_head      VARCHAR2 (150);
  l_chr_customer_number VARCHAR2 (150);
  l_chr_assmt_year      VARCHAR2 (150);
  l_return_status       VARCHAR2 (1000);
  l_msg_data            VARCHAR2 (1000);
  l_receipt_attributes ar_receipt_api_pub.attribute_rec_type;
  l_global_attributes ar_receipt_api_pub.global_attribute_rec_type;
  l_approval_date     DATE;
  l_msg_count         NUMBER;
  l_customer_trx_id   NUMBER;
  l_cash_receipt_id   NUMBER;
  l_receipt_method_id NUMBER;
  l_num_customer_id   NUMBER;
  l_num_bank_acct_id  NUMBER;
BEGIN
  l_chr_proc_name    := 'xx_interest_recpt_proc';
  t_output           := NULL;
  t_msg_dummy        := NULL;
  p_out_chr_retcode  := g_chr_success_code;
  p_out_chr_errbuff  := ' ';
  l_chr_exe_location := 'IRP_0001';
  l_stmt_processing  := 'Interest_recpt_proc Starts ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  l_chr_exe_location := 'IRP_0002';
  l_stmt_processing  := 'Customer info Fetch ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- customer info Fetch
  SELECT id_number,
    irt_ay,
    major_head,
    customer_trx_id,
    NVL (approval_date, SYSDATE)
  INTO l_chr_customer_number,
    l_chr_assmt_year,
    l_chr_major_head,
    l_customer_trx_id,
    l_approval_date
  FROM xx_refd_headers
  WHERE reference_id  = in_num_reference_id;
  l_chr_exe_location := 'IRP_0003';
  l_stmt_processing  := 'Customer Id Fetch' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  --customer Id Fetch
  SELECT bill_to_customer_id
  INTO l_num_customer_id
  FROM ra_customer_trx_all
  WHERE customer_trx_id = l_customer_trx_id;
  l_chr_exe_location   := 'IRP_0004';
  l_stmt_processing    := 'Receipt method id Fetch' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- receipt method id Fetch
  SELECT receipt_method_id
  INTO l_receipt_method_id
  FROM ar_receipt_methods
  WHERE attribute1    = l_chr_major_head
  AND attribute2      = in_chr_flag;
  l_chr_exe_location := 'IRP_0005';
  l_stmt_processing  := 'Bank account id Fetch ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  --Bank account id Fetch
  SELECT remit_bank_acct_use_id
  INTO l_num_bank_acct_id
  FROM ar_receipt_method_accounts_all
  WHERE receipt_method_id = l_receipt_method_id;
  l_chr_exe_location     := 'IRP_0006';
  l_stmt_processing      := 'Cash receipt api ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  l_receipt_attributes.attribute1 := l_chr_major_head; --major head
  l_receipt_attributes.attribute2 := in_chr_flag;      --'IRF';
  -- minor head
  l_receipt_attributes.attribute4  := l_chr_assmt_year;      -- assmt year
  l_receipt_attributes.attribute5  := l_chr_customer_number; -- Id
  l_receipt_attributes.attribute12 := in_chr_irt_id;
  l_receipt_attributes.attribute15 := 'REFD IN PROCESS';
  -- Calling the Receipt API for creating interest receipt
  --AR_RECEIPT_API_PUB.CREATE_CASH (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_currency_code => 'INR', p_amount => in_num_receipt_amount, p_receipt_number => in_chr_flag || '_' || l_chr_customer_number || '_' || l_chr_assmt_year || '_' || l_chr_major_head, p_receipt_date => TRUNC (l_approval_date ), p_gl_date => TRUNC (SYSDATE), p_customer_id => l_num_customer_id, p_remittance_bank_account_id => l_num_bank_acct_id, p_receipt_method_id => l_receipt_method_id, p_attribute_rec => l_receipt_attributes, p_global_attribute_rec => l_global_attributes, p_org_id => g_num_org_id, p_cr_id => l_cash_receipt_id ) ;  --Commented for Hotfix_199485 Backdated Changes on 13-MAR-2019
  AR_RECEIPT_API_PUB.CREATE_CASH (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_currency_code => 'INR', p_amount => in_num_receipt_amount, p_receipt_number => in_chr_flag || '_' || l_chr_customer_number || '_' || l_chr_assmt_year || '_' || l_chr_major_head, p_receipt_date => TRUNC (l_approval_date ), p_gl_date => TRUNC (l_approval_date ), p_customer_id => l_num_customer_id, p_remittance_bank_account_id => l_num_bank_acct_id, p_receipt_method_id => l_receipt_method_id, p_attribute_rec => l_receipt_attributes, p_global_attribute_rec => l_global_attributes, p_org_id => g_num_org_id, p_cr_id => l_cash_receipt_id ) ; --Added for Hotfix_199485 Backdated Changes on 13-MAR-2019
  IF l_return_status    = fnd_api.g_ret_sts_success THEN
    l_chr_exe_location := 'IRP_0007';
    l_stmt_processing  := 'Insert into xx_refd_lines as API is Success' ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    INSERT
    INTO xx_refd_lines
      (
        reference_id ,
        cash_receipt_id ,
        receipt_ay ,
        minor_head ,
        excess_receipt_amount ,
        receipt_date ,
        last_updated_by ,
        last_update_date ,
        last_update_login ,
        created_by ,
        creation_date ,
        refd_roundoff_amount ,
        net_refd_amount ,
        refd_adjustment_amount ,
        refd_crossadjust_amount
      )
      VALUES
      (
        in_num_reference_id ,
        l_cash_receipt_id ,
        l_chr_assmt_year ,
        in_chr_flag ,
        in_num_receipt_amount ,
        l_approval_date ,
        g_num_user_id ,
        SYSDATE ,
        g_num_login_id ,
        g_num_user_id ,
        SYSDATE ,
        0 ,
        0 ,
        0 ,
        0
      );
  ELSE -- IF l_return_status = fnd_api.g_ret_sts_success
    l_chr_exe_location := 'IRP_0009';
    l_stmt_processing  := 'Receipt API is Failed getting Error Details ' ;
    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
    IF l_msg_count >= 0 THEN
      FOR j IN 0 .. l_msg_count
      LOOP
        fnd_msg_pub.get
        (
          j, fnd_api.g_false, l_msg_data, t_msg_dummy
        )
        ;
        t_output          := ( TO_CHAR (j) || ': ' || l_msg_data ) ;
        p_out_chr_errbuff := p_out_chr_errbuff || SUBSTR ( t_output, 1, 255 ) ;
      END LOOP; -- FOR j IN 0 .. l_msg_count
    END IF;     -- IF l_msg_count >= 0
    p_out_chr_retcode := g_chr_failure_code;
    RETURN;
  END IF; -- IF l_return_status = fnd_api.g_ret_sts_success
  l_chr_exe_location := 'IRP_0010';
  l_stmt_processing  := 'Moving our of Interest_recpt_proc ' ;
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := p_out_chr_errbuff || 'Error in Cash receipt api ' || SQLERRM;
  write_msg ( g_write_logfile , ' Unexpected Error -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm ) ;
END interest_recpt_proc;
-- ***************** End of Function / Procedure **********************--
--+
------------------------------------------------------------------------------+
--| Name : roundoff_calc
--| Description :
--|
--|
--+
------------------------------------------------------------------------------+
FUNCTION roundoff_calc
  (
    p_dmd_amount IN NUMBER,
    out_identify_amt OUT NOCOPY NUMBER,
    out_roundoff_amt OUT NOCOPY NUMBER
  )
  RETURN NUMBER
  /****************************************************************************
  ****************************************
  * Type : FUNCTION
  * Name : ROUNDOFF_CALC
  * Input Parameters : p_dmd_amount
  * Output Parameters : out_identify_amt ; out_roundoff_amt
  * Purpose : To calculate the invoice identify/roundoff amount
  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  ----------------- --------------------------
  ******************************************
  *************************************************************************/
IS
  l_status           NUMBER := 0;
  l_identify_amt     NUMBER;
  l_roundoff_amt     NUMBER;
  l_temp             NUMBER;
  l_chr_proc_name    VARCHAR2 ( 50 ) :='roundoff_calc';
  l_chr_exe_location VARCHAR2 ( 50 ) :='';
BEGIN
  l_chr_exe_location := 'ROC001';
  SELECT MOD (p_dmd_amount, 1),
    (p_dmd_amount - MOD (p_dmd_amount, 1))
  INTO l_roundoff_amt,
    l_identify_amt
  FROM DUAL;
  l_chr_exe_location := 'ROC002';
  SELECT MOD (l_identify_amt, 10) INTO l_temp FROM DUAL;
  l_chr_exe_location := 'ROC003';
  IF l_temp          >= 0 AND l_temp < 5 THEN
    out_identify_amt := p_dmd_amount - l_roundoff_amt - l_temp;
    out_roundoff_amt :=                 - (l_roundoff_amt + l_temp);
  ELSE
    out_identify_amt := l_identify_amt   - l_temp + 10;
    out_roundoff_amt := out_identify_amt - p_dmd_amount;
  END IF;
  RETURN (l_status);
EXCEPTION
WHEN OTHERS THEN
  l_status := 2;
  write_msg( g_write_logfile ,'FAILURE in roundoff_calc! ' ||l_chr_exe_location ||'-'||sqlerrm );
  RETURN (l_status);
END roundoff_calc;
/******************************************************************************
**************************************
* Type : PROCEDURE
* Name : create_process_log
* Input Parameters : p_in_request_id, p_in_process_cnt , p_in_failure_cnt
* Output Parameters : p_out_chr_errbuff ; p_out_chr_retcode
* Purpose : Routine to write the log of records processed in specified run
*
*******************************************************************************
**************************************
* Modified Date Modified By Version Reviewed By Reviewed Date Modification Type
Modification Details
* ------------- ------------ -------- --------------- --------------
----------------- --------------------------
*******************************************************************************
*************************************/
PROCEDURE create_process_log(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2 ,
    p_in_request_id     IN NUMBER ,
    p_in_process_cnt    IN NUMBER ,
    P_IN_FAILURE_CNT    IN NUMBER ,
    P_STATUS            IN VARCHAR2 ,
    p_parent_request_id IN NUMBER DEFAULT NULL )
IS
  l_stmt_processing  VARCHAR2(100);
  l_chr_proc_name    VARCHAR2(50) :='create_process_log';
  l_chr_exe_location VARCHAR2(50) :='';
  l_cnt              NUMBER       := 0;
  CURSOR Cur_Chk_Request (P_REQUEST_ID NUMBER)
  IS
    SELECT NVL(Xpl.Request_Id,'0') Request_Id ,
      TO_CHAR(Fcr.Actual_Start_Date,'DD/MON/YYYY HH24:MI:SS') Start_Date ,
      TO_CHAR(FCR.ACTUAL_COMPLETION_DATE,'DD/MON/YYYY HH24:MI:SS') completion_date
    FROM xx_IRT_ACCT_PROCESS_LOG XPL ,
      FND_CONCURRENT_REQUESTS FCR
    WHERE XPL.REQUEST_ID (+) = FCR.REQUEST_ID
    AND FCR.REQUEST_ID       = p_request_id;
  l_request_rec Cur_Chk_Request%rowtype;
  -- Start of changes for 1.13 version on 15-OCT-2014
  PRAGMA AUTONOMOUS_TRANSACTION;
  -- End of changes for 1.13 version on 15-OCT-2014
BEGIN
  p_out_chr_retcode  := g_chr_success_code;
  P_OUT_CHR_ERRBUFF  := '';
  l_chr_exe_location := 'CPR001';
  write_debug( g_debug_flag , 'Entering Procedure ' || l_chr_proc_name );
  l_stmt_processing := 'Writing Data to Process Log Table ';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN Cur_Chk_Request(p_in_request_id);
  FETCH Cur_Chk_Request INTO L_Request_Rec;
  CLOSE Cur_Chk_Request;
  IF L_Request_Rec.request_id = 0 THEN
    -- INSERT INTO Process Log
    INSERT
    INTO xx_IRT_ACCT_PROCESS_LOG
      (
        REQUEST_ID ,
        Request_Start_Date ,
        Request_end_Date ,
        irt_processed_cnt ,
        irt_failed_cnt ,
        recpt_cnt ,
        status ,
        parent_request_id
      )
      VALUES
      (
        P_IN_REQUEST_ID ,
        To_date(L_Request_Rec.Start_Date,'DD/MON/YYYY HH24:MI:SS') ,
        To_date(L_Request_Rec.completion_date,'DD/MON/YYYY HH24:MI:SS') ,
        p_in_process_cnt ,
        p_in_failure_cnt ,
        G_Rcpt_Cnt ,
        p_status ,
        p_parent_request_id
      );
  ELSE
    UPDATE xx_IRT_ACCT_PROCESS_LOG
    SET Request_End_Date = SYSDATE ,
      Irt_Processed_Cnt  = P_In_Process_Cnt ,
      Irt_Failed_Cnt     = P_In_Failure_Cnt ,
      recpt_cnt          = g_rcpt_cnt ,
      status             = p_status
    WHERE request_id     = L_Request_Rec.request_id;
  END IF;
  -- Start of changes for 1.13 version on 15-OCT-2014
  COMMIT;
  -- End of changes for 1.13 version on 15-OCT-2014
  L_CHR_EXE_LOCATION  := 'CPR002';
  IF P_IN_PROCESS_CNT IS NOT NULL THEN
    write_msg( g_write_outfile , ' ');
    write_msg( g_write_outfile , ' ');
    WRITE_MSG( G_WRITE_OUTFILE , ' ');
    write_msg( g_write_outfile , ' ');
    write_msg( g_write_outfile , '************************************************************');
    write_msg( g_write_outfile , ' Summary of Error ');
    write_msg( g_write_outfile , '************************************************************');
    write_msg( g_write_outfile , ' IRT ID Id Number AY Error ');
    write_msg( g_write_outfile , '************************************************************');
    FOR err_rec IN
    (SELECT request_id,
      SUBSTR(transaction_number ,1,15) irt_id ,
      SUBSTR(BILL_TO_CUSTOMER_NUMBER,1,15) Id_Number ,
      SUBSTR(assessment_year,1,9) AY_Year,
      error_message
    FROM xx_ar_trans_stg
    WHERE status_code = 'ERROR'
    AND request_id    = p_in_request_id
    )
    LOOP
      L_CNT := 1;
      WRITE_MSG( G_WRITE_OUTFILE , ERR_REC.IRT_ID || ' ' || ERR_REC.ID_NUMBER || ' '|| err_rec.AY_Year || ' '||err_rec. error_message);
    END LOOP;
    IF l_cnt = 0 THEN
      write_msg( g_write_outfile , ' No Error Records Found for the Request_id ' ||p_in_request_id );
    END IF;
    write_msg( g_write_outfile , '************************************************************');
  END IF;
  write_debug( g_debug_flag , 'Moving out from Procedure ' || l_chr_proc_name ) ;
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := l_chr_proc_name ||'-'|| sqlerrm ;
  write_msg( g_write_logfile , ' Unexpected Error -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm);
END create_process_log;
-- ***************** End of Function / Procedure **********************--
/******************************************************************************
**************************************
* Type : PROCEDURE
* Name : archieve_processed_data
* Input Parameters : p_in_request_id
* Output Parameters : p_out_chr_errbuff ; p_out_chr_retcode
* Purpose : This Procedure would archive the processed records to the History
* table and also reset the request_id and status of the unprocessed records
*******************************************************************************
**************************************
* Modified Date Modified By Version Reviewed By Reviewed Date Modification Type
Modification Details
* ------------- ------------ -------- --------------- --------------
----------------- --------------------------
***********************************************************************/
PROCEDURE archieve_processed_data(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2 ,
    p_in_request_id IN NUMBER )
AS
  l_stmt_processing  VARCHAR2(100);
  l_chr_proc_name    VARCHAR2(50) :='archieve_processed_data';
  l_chr_exe_location VARCHAR2(50) :='';
BEGIN
  l_chr_proc_name   := 'archieve_processed_data';
  p_out_chr_retcode := g_chr_success_code;
  p_out_chr_errbuff := '';
  write_debug( g_debug_flag , 'Entering Procedure ' || l_chr_proc_name );
  l_stmt_processing := 'Backuping up Processed records to Archive Table';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Moving processed records to Histrory table
  INSERT
  INTO xx_AR_TRANS_STG_HISTORY
  SELECT *
  FROM xx_ar_trans_stg xats
  WHERE status_code = 'PROCESSED'
  AND request_id    = p_in_request_id;
  write_msg( g_write_outfile , ' Count of records Archived [' || sql%rowcount ||'] ' );
  l_stmt_processing := 'DELETE records from Invoice staging processed records';
  -- Deleting processed records to Invoice Staging table
  DELETE
  FROM xx_ar_trans_stg xats
  WHERE status_code = 'PROCESSED'
  AND request_id    = p_in_request_id;
  write_msg( g_write_outfile , ' Count of records purged from staging table [' || sql%rowcount ||'] ' );
  l_stmt_processing := 'Reset the status and request_id for unprocessed records';
  -- Reset the records status and request_id to NULL for cases which is at NEW
  -- status at the end
  -- processing . This happens when rollback to savepoint happens between
  -- commit's
  UPDATE xx_AR_TRANS_STG xats
  SET status_code  = NULL ,
    request_id     = NULL
  WHERE request_id = p_in_request_id
  AND status_code  = 'NEW';
  write_msg( g_write_outfile , ' Unprocessed record count [' || sql%rowcount || '] ' );
  write_msg( g_write_logfile , 'Moving out from Procedure ' || l_chr_proc_name );
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := l_chr_proc_name ||'-'|| sqlerrm ;
  write_msg( g_write_logfile , ' Unexpected Error -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm);
END archieve_processed_data ;
-- ***************** End of Function / Procedure **********************--
PROCEDURE threshold_dmd_update_proc(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_id_number IN VARCHAR2,
    p_in_irt_id     IN VARCHAR2 )
AS
  /****************************************************************************
  **************
  * Type : Procedure
  * Name : threshold_dmd_update_proc
  * Input Parameters : p_in_id_number, p_in_irt_id
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : UPDATE THRESHOLD CASES FROM NULL TO Y FOR DMDS LESS THAN 100
  WHICH CANNOT BE SEEN.
  *
  *****************************************************************************
  **********
  * Modified Date Modified By Version Modification Type Modification Details
  * ------------- ------------ -------- - -----------------
  *****************************************************************************
  *********/
  l_chr_exe_location VARCHAR2(250) := '';
  l_stmt_processing  VARCHAR2(250) := '';
  CURSOR cur_dmd_inv
  IS
    SELECT *
    FROM xx_dmd_headers
    WHERE id_number               =p_in_id_number
    AND dmd_status             IN ('DMD','INT DMD') --#CR-644
    AND ( AVL_REFD_ADJUST_AMOUNT <100
    AND avl_refd_adjust_amount  >=0 )-- subha Changes done as PART of HOTFIX#126857 added on 30-AUG-2016
    AND attribute6                IS NULL
    AND attribute1                IS NULL
    AND MAJOR_HEAD                <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
BEGIN
  p_out_chr_errbuff := ' ';
  p_out_chr_retcode := g_chr_success_code;
  --p_out_chr_retcode  := 0;
  l_chr_exe_location := '';
  l_stmt_processing  :=' Entering the Threshold Update Proc';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  write_debug( g_debug_flag , '-----------------------------------------------------------------------');
  write_debug( g_debug_flag ,'*** Threshold Dmd UPDATE - STARTS ***');
  write_debug( g_debug_flag , '-----------------------------------------------------------------------');
  FOR i IN cur_dmd_inv
  LOOP
    BEGIN
      UPDATE xx_DMD_HEADERS
      SET ATTRIBUTE1        = 'Y',
        ATTRIBUTE2          = 'ABC',
        ATTRIBUTE4          = TRUNC (SYSDATE),
        ATTRIBUTE9          ='THRESHOLD DMD UPDATE'
      WHERE CUSTOMER_TRX_ID = I.CUSTOMER_TRX_ID
      AND ID_NUMBER        = I.ID_NUMBER
      AND IRT_AY            = I.IRT_AY;
      write_debug( g_debug_flag ,'NUMBER OF ROWS UPDATED'||SQL%rowcount);
      write_debug( g_debug_flag ,'************');
      write_debug( g_debug_flag ,' **** FOR IRT_ID ***** ');
      write_debug( g_debug_flag ,' irt_id :'|| p_in_irt_id);
      write_debug( g_debug_flag ,' ID Number :'|| I.ID_NUMBER);
      write_debug( g_debug_flag ,'CUSTOMER_TRX_ID'|| I.CUSTOMER_TRX_ID);
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Exception is '||SQLERRM);
      p_out_chr_retcode := g_chr_failure_code;
      p_out_chr_errbuff := 'Error in procedure ' || ' threshold_dmd_update_proc'|| '-' ||SUBSTR(sqlerrm,1,255);
    END;
  END LOOP;
EXCEPTION
WHEN OTHERS THEN
  write_debug( g_debug_flag ,'Exception is '||SQLERRM);
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' ||' threshold_dmd_update_proc' || '-' ||SUBSTR(sqlerrm,1,255);
END threshold_dmd_update_proc;
------------------------------------------------------------------------------------------------------------------
--**********************************************HOTFIX#127737******************
-- *********************************---
PROCEDURE MARKING_RECORDS_RORLX_PROC(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_id_number IN VARCHAR2,
    p_in_irt_id     IN VARCHAR2 )
AS
  /****************************************************************************
  **************
  * Type : Procedure
  * Name : threshold_dmd_update_proc
  * Input Parameters : p_in_id_number, p_in_irt_id
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : UPDATE REFD HEADERS FOR SENDING NOTICES FOR RO_RELAX CASES.
  *
  *****************************************************************************
  **********
  * Modified Date Modified By Version Modification Type Modification Details
  * ------------- ------------ -------- - -----------------
  *****************************************************************************
  *********/
  l_chr_exe_location       VARCHAR2(250) := '';
  l_stmt_processing        VARCHAR2(250) := '';
  L_REFD_IDENTIFY_AMOUNT NUMBER        := 0;
  L_AVL_ADJUST_AMOUNT      NUMBER        :=0;
  L_NET_REFD_AMOUNT      NUMBER        :=0;
  L_COUNT                  NUMBER        :=0;
BEGIN
  p_out_chr_errbuff := ' ';
  p_out_chr_retcode := g_chr_success_code;
  --p_out_chr_retcode  := 0;
  l_chr_exe_location := '';
  l_stmt_processing  :=' Entering the MARKING_RECORDS_RORLX_PROC';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  write_debug( g_debug_flag , '-----------------------------------------------------------------------');
  write_debug( g_debug_flag ,'*** UPDATE FOR RO_RELAX CASES START ***');
  write_debug( g_debug_flag , '-----------------------------------------------------------------------');
  SELECT COUNT(1)
  INTO L_COUNT
  FROM xxcus.xx_REFD_HEADERS XRH
  WHERE XRH.IRT_ID                       = P_IN_IRT_ID
  AND NVL(XRH.REFD_ADJUSTMENT_AMOUNT,0)=0
  AND NVL(NET_REFD_AMOUNT,0)           >100
  AND EXISTS
    (SELECT 1
    FROM xx_DMD_HEADERS XDH
    WHERE XDH.ID_NUMBER   =XRH.ID_NUMBER
    AND XDH.DMD_STATUS IN ('DMD','INT DMD','THRESHOLD DMD')
    AND XDH.MAJOR_HEAD    <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    );
  IF(L_COUNT>0)--if1
    THEN
    SELECT SUM(AVL_REFD_ADJUST_AMOUNT)
    INTO L_AVL_ADJUST_AMOUNT
    FROM xx_DMD_HEADERS XDH
    WHERE XDH.ID_NUMBER   =P_IN_ID_NUMBER
    AND XDH.DMD_STATUS IN ('DMD','INT DMD','THRESHOLD DMD')
    AND XDH.MAJOR_HEAD    <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    SELECT SUM(NET_REFD_AMOUNT)
    INTO L_NET_REFD_AMOUNT
    FROM xxcus.xx_REFD_HEADERS XRH
    WHERE XRH.IRT_ID         =P_IN_IRT_ID;
    IF((L_AVL_ADJUST_AMOUNT >=1 AND L_AVL_ADJUST_AMOUNT<=5000)OR ( L_NET_REFD_AMOUNT>=1 AND L_NET_REFD_AMOUNT<=5000 ) )--if2  --modified condition for hotfix#165114
      THEN
      UPDATE xxcus.xx_REFD_HEADERS
      SET ATTRIBUTE15='RO_RELAX'
        --ATTRIBUTE14='FAS'
      WHERE IRT_ID =P_IN_IRT_ID;
      write_debug( g_debug_flag ,'L_NET_REFD_AMOUNT:--'||L_NET_REFD_AMOUNT);
      write_debug( g_debug_flag ,'NUMBER OF ROWS UPDATED'||SQL%rowcount);
      write_debug( g_debug_flag ,'************');
      write_debug( g_debug_flag ,' **** FOR IRT_ID ***** ');
      write_debug( g_debug_flag ,' irt_id :'|| p_in_irt_id);
      write_debug( g_debug_flag ,' ID Number :'|| P_IN_ID_NUMBER);
    END IF;--if2
  END IF;  --if1
EXCEPTION
WHEN OTHERS THEN
  write_debug( g_debug_flag ,'Exception is '||SQLERRM);
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || 'MARKING RECORDS FOR RO-RELAX-CASES'|| '-' ||SUBSTR(sqlerrm,1,255);
END MARKING_RECORDS_RORLX_PROC;
--*****************************************************************************
-- ***********************************--
PROCEDURE XX_CREDIT_MISMATCH_API(
    P_OUT_CHR_ERRBUFF OUT NOCOPY VARCHAR2 ,
    P_OUT_CHR_RETCODE OUT NOCOPY VARCHAR2 ,
    P_IN_IRT_ID     IN VARCHAR2,
    P_IN_ID_NUMBER IN VARCHAR2 )
AS
  /****************************************************************************
  ****************************************
  * Type                         : PROCEDURE
  * Name                         : XX_CREDIT_MISMATCH_API
  * Input Parameters             : VARCHAR2
  * Output Parameters            : VARCHAR2,NUMBER
  * Purpose                      : To Automate the movement of XX credit
  Mismatch.
  *
  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  *****************************************************************************
  ***************************************/
  CURSOR C_DMND(P_ID_NUMBER IN VARCHAR2)
  IS
    SELECT *
    FROM xxcus.IRT_ABC_XX_CREDIT_MISMATCH
    WHERE ID_NUMBER=P_ID_NUMBER
  UNION
  SELECT *
  FROM xxcus.IRT_AST_XX_CREDIT_MISMATCH
  WHERE ID_NUMBER =P_ID_NUMBER;--cusrsor modified as part of CR#608
  CURSOR C_2627(P_ID_NUMBER IN VARCHAR2)
  IS
    SELECT *
    FROM xxcus.xx_DMD_HEADERS
    WHERE ID_NUMBER  =P_ID_NUMBER
    AND ATTRIBUTE1    ='N'
    AND ATTRIBUTE2   IN ('26','27')
    AND ( ATTRIBUTE6 IS NULL
    OR ATTRIBUTE6     ='N' )
    AND MAJOR_HEAD   <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
  V_TCM_COUNT   NUMBER :=0;
  V_2627_COUNT  NUMBER :=0;--hotfix#144630
  V_TOT_DMD_AMT NUMBER :=0;-- added as part of CR#608
  V_DMND_AMT    NUMBER :=0;-- added as part of CR#608
BEGIN
  /*CR#608 starts*/
  V_TCM_COUNT:=0;
  BEGIN
    SELECT 1
    INTO V_TCM_COUNT
    FROM DUAL
    WHERE EXISTS
      (SELECT *
      FROM xxcus.IRT_AST_XX_CREDIT_MISMATCH
      WHERE ID_NUMBER=P_IN_ID_NUMBER
      UNION
      SELECT *
      FROM xxcus.IRT_ABC_XX_CREDIT_MISMATCH
      WHERE ID_NUMBER=P_IN_ID_NUMBER
      );
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    V_TCM_COUNT:=0;
  END;
  IF (V_TCM_COUNT>0) THEN
    FOR C_REL IN C_DMND(P_IN_ID_NUMBER)
    LOOP
      V_DMND_AMT:=0;
      BEGIN --HOTFIX#156870
        SELECT NVL(AVL_REFD_ADJUST_AMOUNT,0)
        INTO V_DMND_AMT
        FROM xx_DMD_HEADERS
        WHERE ID_NUMBER                =C_REL.ID_NUMBER
        AND IRT_AY                      =C_REL.IRT_AY
        AND CUSTOMER_TRX_ID             =C_REL.CUSTOMER_TRX_ID
        AND DMD_IDENTIFICATION_NUMBER=C_REL.DMD_IDENTIFICATION_NUMBER
        AND DMD_STATUS NOT LIKE '%CANCEL%'
        AND MAJOR_HEAD <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        V_DMND_AMT:=0;-- SINCE THE DMD IS NOT THERE IN DMD HEADERS WITH
        -- DMD STATUS.
      END;--HOTFIX#156870
      V_TOT_DMD_AMT :=V_TOT_DMD_AMT+V_DMND_AMT;
    END LOOP;
  END IF;
  --/cr#608 ENDS/
  SELECT COUNT(1)
  INTO V_2627_COUNT
  FROM xxcus.xx_DMD_HEADERS
  WHERE ID_NUMBER  =P_IN_ID_NUMBER
  AND ATTRIBUTE1    ='N'
  AND ATTRIBUTE2   IN ('26','27')
  AND ( ATTRIBUTE6 IS NULL
  OR ATTRIBUTE6     ='N' )    --HOTFIX#144630
  AND MAJOR_HEAD   <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
  WRITE_DEBUG( G_DEBUG_FLAG ,'V_2627_COUNT updating:-'||V_2627_COUNT);
  IF(V_TCM_COUNT>0 AND V_TOT_DMD_AMT<1000001)--cHANGED AS PART OF CR#608
    THEN
    FOR C_REC IN C_DMND(P_IN_ID_NUMBER)
    LOOP--1
      BEGIN
        INSERT INTO xx_DMD_CONFM_GTT
        SELECT ID_NUMBER,
          IRT_AY,
          ATTRIBUTE1,
          ATTRIBUTE6,
          DMD_IDENTIFICATION_NUMBER,
          CUSTOMER_TRX_ID,
          IRT_ID,
          P_IN_IRT_ID,
          DMD_STATUS
        FROM xx_DMD_HEADERS
        WHERE DMD_IDENTIFICATION_NUMBER=C_REC.DMD_IDENTIFICATION_NUMBER
        AND IRT_ID                        =C_REC.IRT_ID
        AND CUSTOMER_TRX_ID               =C_REC.CUSTOMER_TRX_ID;
        UPDATE xx_DMD_HEADERS XDH
        SET DMD_STATUS                 ='TCM CANCEL'
        WHERE DMD_IDENTIFICATION_NUMBER=C_REC.DMD_IDENTIFICATION_NUMBER
        AND IRT_ID                        =C_REC.IRT_ID
        AND CUSTOMER_TRX_ID               =C_REC.CUSTOMER_TRX_ID
        AND DMD_STATUS                 ='DMD'
        AND NVL(ATTRIBUTE6,'X')          <> 'Y'; -- Added for HF#185029 on 8-Aug-2018 -- to remove the update for TCM aggreed (by Xx payer) dmd
        WRITE_DEBUG( G_DEBUG_FLAG ,'customer_trx_id updating:-'|| C_REC.CUSTOMER_TRX_ID||'144630'||sql%rowcount);
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag ,'Exception is inside YHE FOR LOOP'||SQLERRM) ;
        p_out_chr_retcode := g_chr_failure_code;
        p_out_chr_errbuff := 'Error in procedure ' || ' XX_CREDIT_MISMATCH_API '|| '-' ||SUBSTR(sqlerrm,1,255);
      END;
    END LOOP;--1
  ELSE
    DBMS_OUTPUT.PUT_LINE('NOT A XX CREDIT MISMATCH CASE.');
  END IF;
  --ADDED AS PART OF HOTFIX#144630
  IF (V_2627_COUNT>0) THEN
    FOR C_REC1 IN C_2627(P_IN_ID_NUMBER)
    LOOP--2
      BEGIN
        INSERT INTO xx_DMD_CONFM_GTT
        SELECT ID_NUMBER,
          IRT_AY,
          ATTRIBUTE1,
          ATTRIBUTE6,
          DMD_IDENTIFICATION_NUMBER,
          CUSTOMER_TRX_ID,
          IRT_ID,
          P_IN_IRT_ID,
          DMD_STATUS
        FROM xx_DMD_HEADERS
        WHERE DMD_IDENTIFICATION_NUMBER=C_REC1.DMD_IDENTIFICATION_NUMBER
        AND IRT_ID                        =C_REC1.IRT_ID
        AND CUSTOMER_TRX_ID               =C_REC1.CUSTOMER_TRX_ID
          --and dmd_status='DMD'; --added for Hotfix_179002 on 13-Apr-2018
        AND dmd_status IN ('DMD','INT DMD','THRESHOLD DMD'); --added for Hotfix_179002 on 19-Apr-2018
        UPDATE xx_DMD_HEADERS XDH
        SET DMD_STATUS                 ='TCM CANCEL'
        WHERE DMD_IDENTIFICATION_NUMBER=C_REC1.DMD_IDENTIFICATION_NUMBER
        AND IRT_ID                        =C_REC1.IRT_ID
        AND CUSTOMER_TRX_ID               =C_REC1.CUSTOMER_TRX_ID
        AND DMD_STATUS                 ='DMD';
        WRITE_DEBUG( G_DEBUG_FLAG ,'customer_trx_id updating:-'|| C_REC1.CUSTOMER_TRX_ID||'144630'||sql%rowcount);
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag ,'Exception is inside YHE FOR LOOP'||SQLERRM) ;
        p_out_chr_retcode := g_chr_failure_code;
        p_out_chr_errbuff := 'Error in procedure ' || ' XX_CREDIT_MISMATCH_API '|| '-' ||SUBSTR(sqlerrm,1,255);
      END;
    END LOOP;--2
    --END OF HOTFIX#144630
  ELSE
    DBMS_OUTPUT.PUT_LINE('NOT A XX CREDIT MISMATCH CASE.');
  END IF;
EXCEPTION
WHEN OTHERS THEN
  write_debug( g_debug_flag ,'Exception is '||SQLERRM);
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' ||'XX_CREDIT_MISMATCH_API'|| '-' ||SUBSTR(sqlerrm,1,255);
END;
PROCEDURE XX_CREDIT_MISMATCH_REVERT_API(
    P_OUT_CHR_ERRBUFF OUT NOCOPY VARCHAR2 ,
    P_OUT_CHR_RETCODE OUT NOCOPY VARCHAR2 ,
    P_IN_IRT_ID     IN VARCHAR2,
    P_IN_ID_NUMBER IN VARCHAR2 )
AS
  /****************************************************************************
  ****************************************
  * Type                         : PROCEDURE
  * Name                         : XX_CREDIT_MISMATCH_REVERT_API
  * Input Parameters             : VARCHAR2
  * Output Parameters            : VARCHAR2,NUMBER
  * Purpose                      : To Automate the movement of XX credit
  Mismatch.
  *
  * Company                      : Infosys Technologies Ltd.
  * Created By                   : Infosys
  * Created Date                 : 14-DEC-2016
  * Last Reviewed By             :
  * Last Reviewed Date           :
  *****************************************************************************
  ****************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  ----------------- --------------------------
  * 14-DEC-2016 Infosys 1.0 Created
  *****************************************************************************
  ***************************************/
  V_DMD_STATUS VARCHAR2(150):='';
  CURSOR C_DMND(P_ID_NUMBER IN VARCHAR2)
  IS
    SELECT *
    FROM xxcus.xx_DMD_HEADERS
    WHERE ID_NUMBER =P_ID_NUMBER
    AND DMD_STATUS='TCM CANCEL'
    AND MAJOR_HEAD  <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
BEGIN
  FOR C_REV IN C_DMND(P_IN_ID_NUMBER)
  LOOP
    BEGIN
      SELECT DMD_STATUS
      INTO V_DMD_STATUS
      FROM xx_DMD_CONFM_GTT
      WHERE CUSTOMER_TRX_ID           =C_REV.CUSTOMER_TRX_ID
      AND DMD_IDENTIFICATION_NUMBER=C_REV.DMD_IDENTIFICATION_NUMBER
      AND IRT_ID                      =C_REV.IRT_ID
      AND REFD_IRT_ID               =P_IN_IRT_ID;
      UPDATE xx_DMD_HEADERS
      SET DMD_STATUS               =V_DMD_STATUS
      WHERE CUSTOMER_TRX_ID           =C_REV.CUSTOMER_TRX_ID
      AND DMD_IDENTIFICATION_NUMBER=C_REV.DMD_IDENTIFICATION_NUMBER
      AND IRT_ID                      =C_REV.IRT_ID
      AND DMD_STATUS               ='TCM CANCEL';
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Exception is inside tHE FOR LOOP'||SQLERRM);
      p_out_chr_retcode := g_chr_failure_code;
      p_out_chr_errbuff := 'Error in procedure ' || ' XX_CREDIT_MISMATCH_REVERT_API '|| '-' ||SUBSTR(sqlerrm,1,255);
    END;
  END LOOP;
EXCEPTION
WHEN OTHERS THEN
  write_debug( g_debug_flag ,'Exception is '||SQLERRM);
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' ||'XX_CREDIT_MISMATCH_REVERT_API' || '-' ||SUBSTR(sqlerrm,1,255);
END;
/******************************************************************************
**************************************
* Type : PROCEDURE
* Name : Backup_data
* Input Parameters : p_in_irt_id
* Output Parameters : p_out_chr_errbuff ; p_out_chr_retcode
* Purpose : This Procedure would backup data in the main table of IRT
accounting
* in PL/SQL Table and so that the same can be used to call the Log_exception
*******************************************************************************
**************************************
* Modified Date Modified By Version Reviewed By Reviewed Date Modification Type
Modification Details
* ------------- ------------ -------- --------------- --------------
----------------- --------------------------
***********************************************************************/
PROCEDURE Backup_data(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2 ,
    p_in_irt_id IN VARCHAR2 )
AS
  l_stmt_processing  VARCHAR2(100);
  l_chr_proc_name    VARCHAR2(50) :='Backup_data ';
  l_chr_exe_location VARCHAR2(50) :='';
BEGIN
  l_stmt_processing  := ' Entering Backup Data Procedure ';
  l_chr_exe_location := 'BK_001';
  g_Cust_Trx_tbl.DELETE;
  g_irfheader_tbl.DELETE; --Added on 15-11-12
  g_Cus_Trx_Line_tbl.DELETE;
  g_Pay_Schd_tbl.DELETE;
  g_Cash_Recpt_tbl.DELETE;
  g_Rec_Appl_tbl.DELETE;
  g_Refd_head_tbl.DELETE;
  g_refd_line_tbl.DELETE;
  g_dmd_head_tbl.DELETE;
  g_fas_hold_tbl.DELETE; --Added on 15-11-12
  g_prev_dem_tbl.DELETE; -- added for 220 logic
  g_tot_tbl.DELETE ;    ---added for 220 logic
  g_dmd_line_tbl.DELETE;
  g_overdue_dem_tbl.DELETE;
  G_INTEREST_ON_REFD_TBL.delete;
  g_xx_rfnd_inst_tbl.delete;
  -- Backup the Invoice information to the temp table
  l_stmt_processing  := ' Backing up Customer Trx All ';
  l_chr_exe_location := 'BK_001_A';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_Cust_Trx_tbl
  FROM ra_customer_trx_all
  WHERE attribute11 = p_in_irt_id;
  -- Backup the IIRF Header information to the temp table
  l_stmt_processing  := ' Backing up xx_IRF_TS_HEADER TABLE ';
  l_chr_exe_location := 'BK_002';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_irfheader_tbl
  FROM xx_IRF_TS_HEADER
  WHERE IRT_ID = p_in_irt_id; ----Added on 15-11-12
  -- Backup the Invoice Lines information to the temp table
  l_stmt_processing  := ' Backing up Customer Trx Lines All ';
  l_chr_exe_location := 'BK_002';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_Cus_Trx_Line_tbl
  FROM ra_customer_trx_lines_all
  WHERE customer_trx_id IN
    (SELECT customer_trx_id
    FROM ra_customer_trx_all
    WHERE attribute11 = p_in_irt_id
    );
  -- Backup the Invoice Payment Schedule information to the temp table
  l_stmt_processing  := ' Backing up xx_ar_pymnt_schedules ';
  l_chr_exe_location := 'BK_003';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_Pay_Schd_tbl
  FROM ar_payment_schedules_all
  WHERE customer_trx_id IN
    (SELECT customer_trx_id
    FROM ra_customer_trx_all
    WHERE attribute11 = p_in_irt_id
    );
  -- Backup the Cash Receipt information to the temp table
  l_stmt_processing  := ' Insert xx_ar_cash_rcpts_all ';
  l_chr_exe_location := 'BK_004';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_Cash_Recpt_tbl
  FROM ar_cash_receipts_all
  WHERE attribute12 = p_in_irt_id;
  -- Backup the Receivable Invoice application information to the temp table
  l_stmt_processing  := ' Insert xx_ar_recpt_applications ';
  l_chr_exe_location := 'BK_005';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_Rec_Appl_tbl
  FROM ar_receivable_applications_all
  WHERE applied_customer_trx_id IN
    (SELECT customer_trx_id
    FROM ra_customer_trx_all
    WHERE attribute11 = p_in_irt_id
    );
  -- Backup the Refd Header information to the temp table
  l_stmt_processing  := ' Insert g_Refd_head_tbl ';
  l_chr_exe_location := 'BK_006';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_Refd_head_tbl
  FROM xx_refd_headers
  WHERE irt_id = p_in_irt_id;
  -- Backup the Refd Lines information to the temp table
  l_stmt_processing  := ' Insert g_refd_line_tbl ';
  l_chr_exe_location := 'BK_007';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_refd_line_tbl
  FROM xx_refd_lines
  WHERE reference_id IN
    ( SELECT reference_id FROM xx_refd_headers WHERE irt_id = p_in_irt_id
    );
  l_stmt_processing  := ' Insert g_dmd_head_tbl ';
  l_chr_exe_location := 'BK_008';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Backup the Dmd Header information to the temp table
  SELECT * BULK COLLECT
  INTO g_dmd_head_tbl
  FROM xx_dmd_headers
  WHERE irt_id        = p_in_irt_id
  AND MAJOR_HEAD     <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
  l_stmt_processing  := ' Insert g_fas_hold_tbl ';
  l_chr_exe_location := 'BK_008.5';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Backup the xx_irt_fas_prcsng_hold information to the temp table
  SELECT * BULK COLLECT
  INTO g_fas_hold_tbl
  FROM xx_irt_fas_prcsng_hold
  WHERE irt_id        = p_in_irt_id; --Added on 15-11-12
  l_stmt_processing  := ' Insert g_dmd_line_tbl ';
  l_chr_exe_location := 'BK_009';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- below code added for 220 logic
  SELECT * BULK COLLECT
  INTO g_prev_dem_tbl
  FROM xx_prev_dem_details_gtt
  WHERE irt_id        = p_in_irt_id; --Added on 15-11-12
  l_stmt_processing  := ' Insert g_dmd_line_tbl ';
  l_chr_exe_location := 'BK_009.5';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- below code added for 220 logic
  SELECT * BULK COLLECT
  INTO g_tot_tbl
  FROM xxcus.xx_tot_overdue_details
  WHERE irt_id        = p_in_irt_id; --Added on 15-11-12
  l_stmt_processing  := ' Insert g_dmd_line_tbl ';
  l_chr_exe_location := 'BK_009.55';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Backup the Dmd Lines information to the temp table
  SELECT * BULK COLLECT
  INTO g_dmd_line_tbl
  FROM xx_dmd_lines
  WHERE irt_id        = p_in_irt_id;
  l_stmt_processing  := ' Insert Over Due Dmd details g_overdue_dem_tbl ';
  l_chr_exe_location := 'BK_010';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT * BULK COLLECT
  INTO g_overdue_dem_tbl
  FROM xx_overdue_dem_details
  WHERE IRT_ID = P_IN_IRT_ID;
  /* Added ONLY FOR PT*/
  SELECT * BULK COLLECT
  INTO g_xx_rfnd_inst_tbl
  FROM xx_RFND_INST
  WHERE irt_id        =p_in_irt_id;
  L_STMT_PROCESSING  := ' Insert Into Rfnd inst gtt table';
  l_chr_exe_location := 'BK_011';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  /*ONLY FOR PT*/
  /*Added As asked by IVS TEAM SAME IS NOT THERE IN PRODUCTION*/
  L_STMT_PROCESSING  := ' Insert into interest on refd_table';
  l_chr_exe_location := 'BK_012';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  --SELECT * BULK COLLECT
  -- INTO g_interest_on_refd_tbl
  -- FROM IRT_STDCMP.interest_on_refd
  -- WHERE IRT_ID = P_IN_IRT_ID;
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := l_chr_proc_name ||'-'||l_chr_exe_location|| '-'|| l_stmt_processing ||'-'|| sqlerrm ;
  write_msg( g_write_logfile , ' Unexpected Error -' || p_out_chr_errbuff);
END Backup_data;
/******************************************************************************
**************************************
* Type : PROCEDURE
* Name : log_exception
* Input Parameters : p_in_err_desc,p_in_err_code,p_in_err_loc,p_in_irt_id,
p_in_login_id
p_in_cust_trx_id,p_in_refd_ref_id ,p_in_request_id
* Output Parameters : p_out_chr_errbuff ; p_out_chr_retcode
* Purpose : This Procedure would write the exceptions encountered into the
error log
* and also backup's data for the error IRT in the various tables for
* support team investigation
* Company : Infosys Technologies Ltd.
* Created By : Infosys
* Created Date : 24-JAN-12
* Last Reviewed By :
* Last Reviewed Date : 24-JAN-12
*******************************************************************************
**************************************
* Modified Date Modified By Version Reviewed By Reviewed Date Modification Type
Modification Details
* ------------- ------------ -------- --------------- --------------
----------------- --------------------------
* 24-JAN-2012 Infosys 1.0 Created *********************************************
***********************************************************************/
PROCEDURE log_exception(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2 ,
    p_in_err_desc      IN VARCHAR2 ,
    p_in_err_code      IN VARCHAR2 ,
    p_in_err_loc       IN VARCHAR2 ,
    p_in_irt_id        IN VARCHAR2 ,
    p_in_cust_trx_id   IN NUMBER ,
    p_in_refd_ref_id IN NUMBER ,
    p_in_request_id    IN NUMBER ,
    p_in_login_id      IN NUMBER )
AS
  l_stmt_processing  VARCHAR2(100);
  l_chr_proc_name    VARCHAR2(50) :='log_exception ';
  l_chr_exe_location VARCHAR2(50) :='';
  vCreate_Sql_1      VARCHAR2(4000);
  vCreate_Sql_2      VARCHAR2(4000);
  vCreate_Sql_3      VARCHAR2(4000);
  vCreate_Sql_4      VARCHAR2(4000);
  vCreate_Sql_5      VARCHAR2(4000);
  vCreate_Sql_6      VARCHAR2(4000);
  vCreate_Sql_7      VARCHAR2(4000);
  vCreate_Sql_8      VARCHAR2(4000);
  vCreate_Sql_9      VARCHAR2(4000);
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  l_chr_proc_name    := 'log_exception';
  l_chr_exe_location := 'LE_001';
  p_out_chr_retcode  := g_chr_success_code ;
  p_out_chr_errbuff  := '';
  write_debug( g_debug_flag , 'Entering Procedure ' || l_chr_proc_name );
  l_stmt_processing := ' Starting to write Exception Data and Backup Tables';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  l_stmt_processing  := ' Insert xx_5to6_error_log ';
  l_chr_exe_location := 'LE_002';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Log error information to the Error table
  INSERT
  INTO xx_irt_acct_error_log
    (
      irt_id ,
      cust_trx_id ,
      refd_ref_id ,
      error_program ,
      error_code ,
      error_details ,
      request_id ,
      request_date ,
      created_by ,
      creation_date
    )
    VALUES
    (
      p_in_irt_id ,
      p_in_cust_trx_id ,
      p_in_refd_ref_id ,
      p_in_err_loc ,
      p_in_err_code ,
      p_in_err_desc ,
      p_in_request_id ,
      SYSDATE ,
      p_in_login_id ,
      SYSDATE
    );
  l_stmt_processing  := ' Insert xx_ra_cust_trx_all ';
  l_chr_exe_location := 'LE_003';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the Invoice information to the temp table
  FORALL l_cust_trx_rec IN 1..g_Cust_Trx_tbl.count
  INSERT
  INTO xxcus.xx_bkup_ra_cust_trx_all VALUES g_Cust_Trx_tbl
    (
      l_cust_trx_rec
    );
  l_stmt_processing  := ' Insert xx_irf_ts_header ';
  l_chr_exe_location := 'LE_003A';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the Invoice information to the temp table
  FORALL l_cust_trx_rec IN 1..g_irfheader_tbl.count
  INSERT
  INTO xx_bkup_irf_ts_header VALUES g_irfheader_tbl
    (
      l_cust_trx_rec
    ); ----Added on 15-11-12
  l_stmt_processing  := ' Insert xx_ra_cust_trx_lines ';
  l_chr_exe_location := 'LE_004';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the Invoice lines information to the temp table
  FORALL l_cust_trx_line_rec IN 1..g_Cus_Trx_Line_tbl.count
  INSERT
  INTO xxcus.xx_bkup_ra_cust_trx_lines VALUES g_Cus_Trx_Line_tbl
    (
      l_cust_trx_line_rec
    );
  -- Backup the Invoice Payment Schedule information to the temp table
  l_stmt_processing  := ' Insert xx_ar_pymnt_schedules ';
  l_chr_exe_location := 'LE_005';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  FORALL l_pay_schd_rec IN 1..g_Pay_Schd_tbl.count
  INSERT
  INTO xxcus.xx_bkup_ar_pymnt_schdles VALUES g_Pay_Schd_tbl
    (
      l_pay_schd_rec
    );
  -- Backup the Cash Receipt information to the temp table
  l_stmt_processing  := ' Insert xx_ar_cash_rcpts_all ';
  l_chr_exe_location := 'LE_006';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  FORALL l_cash_recpt_rec IN 1..g_Cash_Recpt_tbl.count
  INSERT
  INTO xxcus.xx_bkup_ar_cash_rcpts_all VALUES g_Cash_Recpt_tbl
    (
      l_cash_recpt_rec
    );
  -- Backup the Receivable Invoice application information to the temp table
  l_stmt_processing  := ' Insert xx_ar_recpt_applications ';
  l_chr_exe_location := 'LE_007';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  FORALL l_rec_appl_rec IN 1..g_Rec_Appl_tbl.count
  INSERT
  INTO xxcus.xx_bkup_ar_recpt_applied VALUES g_Rec_Appl_tbl
    (
      l_rec_appl_rec
    );
  -- Backup the Refd Header information to the temp table
  l_stmt_processing  := ' Insert xx_bkup_refd_headers ';
  l_chr_exe_location := 'LE_008';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  FORALL l_ref_head_rec IN 1..g_Refd_head_tbl.count
  INSERT
  INTO xxcus.xx_bkup_refd_headers VALUES g_Refd_head_tbl
    (
      l_ref_head_rec
    );
  -- Backup the Refd Lines information to the temp table
  l_stmt_processing  := ' Insert Refd Lines ';
  l_chr_exe_location := 'LE_009';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  FORALL l_ref_line_rec IN 1..g_refd_line_tbl.count
  INSERT
  INTO xxcus.xx_bkup_refd_lines VALUES g_refd_line_tbl
    (
      l_ref_line_rec
    );
  l_stmt_processing  := ' Insert xx_dmd_headers_bkup ';
  l_chr_exe_location := 'LE_010';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the Dmd Header information to the temp table
  FORALL l_dem_head_rec IN 1..g_dmd_head_tbl.count
  INSERT
  INTO xxcus.xx_bkup_dmd_headers VALUES g_dmd_head_tbl
    (
      l_dem_head_rec
    );
  l_stmt_processing  := ' Insert xx_irt_fas_prcsng_hold_bkup ';
  l_chr_exe_location := 'LE_010';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the Dmd Header information to the temp table
  -- Backup the xx_prev_dem_details_gtt information to the temp table
  FORALL l_prev_dem_rec IN 1..g_prev_dem_tbl.count
  INSERT
  INTO xxcus.xx_bkup_dem_details_gtt VALUES g_prev_dem_tbl
    (
      l_prev_dem_rec
    );
  l_stmt_processing  := ' Insert xx_prev_dem_details_gtt ';
  l_chr_exe_location := 'LE_010';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the xx_prev_dem_details_gtt information to the temp table
  FORALL l_tot_rec IN 1..g_tot_tbl.count
  INSERT
  INTO xxcus.xx_bkup_tot_overdue_details VALUES g_tot_tbl
    (
      l_tot_rec
    );
  l_stmt_processing  := ' Insert xx_prev_dem_details_gtt ';
  l_chr_exe_location := 'LE_010';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the Dmd Header information to the temp table
  FORALL l_dem_head_rec IN 1..g_fas_hold_tbl.count
  INSERT
  INTO xx_irt_fas_prcsng_hold_bkup VALUES g_fas_hold_tbl
    (
      l_dem_head_rec
    ); ----Added on 15-11-12
  l_stmt_processing  := ' Insert xx_dmd_lines_bkup ';
  l_chr_exe_location := 'LE_011';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  -- Backup the Dmd Lines information to the temp table
  FORALL l_dem_line_rec IN 1..g_dmd_line_tbl.count
  INSERT
  INTO xxcus.xx_bkup_dmd_lines VALUES g_dmd_line_tbl
    (
      l_dem_line_rec
    );
  -- Backup the Over Due Dmd information to the temp table
  l_stmt_processing  := ' Insert xx_bkup_overdue_dem_dtls ';
  l_chr_exe_location := 'LE_012';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  FORALL l_overdue_dem_rec IN 1..g_overdue_dem_tbl.count
  INSERT
  INTO xxcus.xx_bkup_overdue_dem_dtls VALUES g_overdue_dem_tbl
    (
      l_overdue_dem_rec
    );
  l_stmt_processing  := ' Insert interest_on_refd_Table';
  l_chr_exe_location := 'LE_013';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  FORALL l_interest_on_refd IN 1..g_interest_on_refd_tbl.count
  INSERT
  INTO INTEREST_BKUP_ON_REFD VALUES g_interest_on_refd_tbl
    (
      l_interest_on_refd
    );
  L_STMT_PROCESSING  := ' Insert xx_rfnd_inst_bkp';
  l_chr_exe_location := 'LE_014';
  FORALL l_rfnd_inst IN 1..g_xx_rfnd_inst_tbl.count
  INSERT INTO xx_rfnd_inst_bkp VALUES g_xx_rfnd_inst_tbl
    ( L_RFND_INST
    );
  COMMIT;
  p_out_chr_errbuff := '';
  write_debug ( g_debug_flag , 'Moving out from Procedure ' || l_chr_proc_name ) ;
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := l_chr_proc_name ||'-'|| sqlerrm ;
  write_msg ( g_write_logfile , ' Unexpected Error during backuping data -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm ) ;
END log_exception;
PROCEDURE WRITE_VALIDATION_ERROR
  (
    P_OUT_CHR_RETCODE OUT VARCHAR2 ,
    p_out_chr_errbuff OUT VARCHAR2 ,
    P_REQUEST_ID IN NUMBER
  )
AS
  l_chr_proc_name VARCHAR2
  (
    50
  )
                                      :='WRITE_VALIDATION_ERROR ';
  l_chr_exe_location VARCHAR2 ( 50 )  :='WVE';
  l_stmt_processing  VARCHAR2 ( 150 ) := '';
BEGIN
  l_stmt_processing := ' Writing Bulk error to error log table';
  INSERT
  INTO xx_irt_acct_error_log
    (
      irt_id ,
      cust_trx_id ,
      refd_ref_id ,
      error_program ,
      error_code ,
      error_details ,
      request_id ,
      request_date ,
      created_by ,
      creation_date
    )
  SELECT TRANSACTION_NUMBER ,
    NULL CUST_TRX_ID ,
    NULL REFD_REF_ID ,
    'Bulk validation in get_dflt_value proc' ERR_LOC ,
    '99' ERR_CODE ,
    Error_Message ERR_DESC ,
    p_request_id REQUEST_ID ,
    SYSDATE ,
    g_num_login_id ,
    SYSDATE
  FROM xx_AR_TRANS_STG XATS
  WHERE STATUS_CODE   = 'ERROR'
  AND xats.request_id = p_request_id;
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  P_Out_Chr_Errbuff := L_Chr_Proc_Name ||'-'|| Sqlerrm ;
  write_msg( g_write_logfile , ' Unexpected Error during writing error data -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm);
END;
-- ***************** End of Function / Procedure **********************--
/******************************************************************************
**************************************
* Type : PROCEDURE
* Name : get_dflt_value
* Input Parameters : p_in_request_id
* Output Parameters : p_out_chr_errbuff ; p_out_chr_retcode
* Purpose : This Procedure would derive the id values for columns which has
* common value across IRT's . eg:- Invoice Batch source, Payment Terms
* , Customer Number Etc
* Company : Infosys Technologies Ltd.
* Created By : Infosys
* Created Date : 19-Dec-11
* Last Reviewed By :
* Last Reviewed Date :
*******************************************************************************
**************************************
* Modified Date Modified By Version Reviewed By Reviewed Date Modification Type
Modification Details
* ------------- ------------ -------- --------------- --------------
----------------- --------------------------
* 19-Dec-11 Infosys 1.0 Created ***********************************************
*********************************************************************/
PROCEDURE get_dflt_value(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2 ,
    p_in_request_id IN NUMBER )
AS
  l_chr_proc_name         VARCHAR2(50)   :='get_dflt_value';
  l_chr_exe_location      VARCHAR2(50)   :='';
  l_chr_batch_source_name VARCHAR2(100)  := 'Transaction Source';
  l_chr_terms_name        VARCHAR2(100)  := 'IMMEDIATE';
  l_organization_name     VARCHAR2(10)   := 'IT-ABC';
  l_pay_vendor_name       VARCHAR2(50)   := 'Xx Refd Customer';
  l_payable_resp_name     VARCHAR2(50)   := 'Payables Manager';
  l_dist_set_name         VARCHAR2(50)   := 'IT_RFND_PAY_DS';
  l_adj_dist_set_name     VARCHAR2(50)   := 'IT_RFND_ADJ_DS';
  l_receivable_trx_type   VARCHAR2(20)   := 'WRITEOFF';
  l_pay_trx_number        VARCHAR2(50)   := 'Receipt Write-off';
  l_stmt_processing       VARCHAR2(200)  := '';
  l_chr_errbuff           VARCHAR2(3000) := '';
  l_chr_retcode           VARCHAR2(20)   := '';
  /*** Start Adding Parameters for Fraudulent ***/
  P_Out_Cd_Etl      NUMBER;
  p_out_msg_etl     VARCHAR2(1000);
  V_FRAUD_COUNT     NUMBER       :=0;  --Added as a Part of CR_HWSW_0483
  V_READ_FLAG       VARCHAR2(10) :=''; --Added as a Part of CR_HWSW_0483
  V_FRAUD_COUNT_REC NUMBER       :=0;  --Added as a Part of CR_HWSW_0483
  v_read_flag_rec   VARCHAR2(10) :=''; --Added as a Part of CR_HWSW_0483
  /*** END of Adding Parameters for Fraudulent ***/
  -- Cursor to fetch Org_id and Legal Entity
  CURSOR Cur_Get_org_info (P_org_name IN VARCHAR2)
  IS
    SELECT Organization_Id,
      Legal_Entity
    FROM Org_Organization_Definitions
    WHERE organization_name = p_org_name;
  -- Cursor to fetch Active Batch source
  CURSOR cur_get_batch_src (p_batch_source IN VARCHAR2)
  IS
    SELECT batch_source_id ,
      name
    FROM ra_batch_sources_all
    WHERE UPPER(NAME) = UPPER(p_batch_source)
    AND status        = 'A'
    AND TRUNC (SYSDATE) BETWEEN NVL(start_date, TRUNC (SYSDATE)) AND NVL( end_date, TRUNC (SYSDATE));
  -- Cursor to fetch Payment Terms id
  CURSOR cur_get_terms_id(p_terms_name IN VARCHAR2)
  IS
    SELECT name,
      term_id
    FROM ra_terms
    WHERE name = p_terms_name
    AND TRUNC (SYSDATE) BETWEEN NVL(start_date_active, TRUNC (SYSDATE)) AND NVL (end_date_active, TRUNC (SYSDATE));
  -- Cursor to fetch Customer Account Number based on the custom
  -- Lookup
  CURSOR cur_get_acct_num
  IS
    SELECT hca.cust_account_id,
      hcas.cust_acct_site_id
    FROM hz_cust_accounts_all hca,
      hz_cust_acct_sites_all hcas
    WHERE HCA.CUST_ACCOUNT_ID = HCAS.CUST_ACCOUNT_ID
    AND hca.account_number = g_id_number ;--//Added kulasekhar ABC 2.0 Start
	--//COMMENTED BY  kulasekhar ABC 2.0 Start
   /*AND hca.account_number   IN
      (SELECT meaning
      FROM fnd_lookup_values
      WHERE lookup_type = 'xx_AR_ACCT_NUMBER'
      AND lookup_code   = 'xx_AR_ACCT_NUM'
      AND enabled_flag  = 'Y'
      AND TRUNC(SYSDATE) BETWEEN TRUNC(NVL(START_DATE_ACTIVE,SYSDATE)) AND TRUNC(NVL(END_DATE_ACTIVE,SYSDATE))
      );*/
	  --//COMMENTED BY  kulasekhar ABC 2.0 End
  -- Cursor to Fetch Distribution Set CCID
  CURSOR cur_get_dist_ccid (p_dist_set_name VARCHAR2)
  IS
    SELECT dist_code_combination_id
    FROM ap_distribution_set_lines_all
    WHERE distribution_set_id =
      (SELECT distribution_set_id
      FROM ap_distribution_sets_all
      WHERE distribution_set_name = p_dist_set_name
      );
  -- Cursor to Fetch Responsibilty and Application id
  CURSOR cur_get_appl_resp_id ( p_resp_name VARCHAR2)
  IS
    SELECT application_id,
      responsibility_id
    FROM Fnd_Responsibility_vl
    WHERE responsibility_name =p_resp_name;
  -- Cursor to Fetch default Vendor and Vensor Site Id
  CURSOR cur_get_vendor_info (p_vendor_name VARCHAR2)
  IS
    SELECT po.vendor_id,
      pos.vendor_site_id
    FROM ap_suppliers po,
      ap_supplier_sites_all pos
    WHERE pos.vendor_id = po.vendor_id
    AND po.vendor_name  = p_vendor_name;
  -- Cursor to Fetch Receivable transation_id and CCID
  CURSOR cur_get_recv_info (p_rec_type VARCHAR2 ,p_org_id NUMBER)
  IS
    SELECT receivables_trx_id,
      code_combination_id
    FROM ar_receivables_trx_all
    WHERE status = 'A'
    AND type     = p_rec_type
    AND org_id   =p_org_id
    AND SYSDATE BETWEEN NVL (start_date_active, SYSDATE - 1) AND NVL ( end_date_active, SYSDATE + 1);
  -- Cursor to Fetch Payment Schedule id for Write-off rec
  CURSOR cur_get_payschd_info( p_trx_number IN VARCHAR2)
  IS
    SELECT payment_schedule_id
    FROM ar_payment_schedules_all
    WHERE trx_number = p_trx_number ;
BEGIN
  l_chr_proc_name   := 'Get_dflt_value';
  p_out_chr_errbuff := '';
  p_out_chr_retcode := g_chr_success_code ;
  --
  -- For fetching the Org and Legal Entity
  --
  l_chr_exe_location := 'GDFLT_0001';
  OPEN Cur_Get_org_info( l_organization_name);
  FETCH Cur_Get_org_info INTO g_num_org_id, g_Legal_Entity_Id;
  CLOSE Cur_Get_org_info ;
  l_chr_exe_location := 'GDFLT_0002';
  IF g_num_org_id    IS NULL THEN
    write_msg( g_write_logfile , ' Unable to Find Organization [' || l_organization_name || '] not defined ');
    p_out_chr_errbuff := p_out_chr_errbuff || ' Unable to Find Organization [' || l_organization_name || '] not defined ';
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  --
  -- For fetching the Batch Source
  --
  l_chr_exe_location := 'GDFLT_0003';
  write_debug( g_debug_flag , 'Entering Procedure ' || l_chr_proc_name );
  l_stmt_processing := 'Opening Cursor for Batch Source ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_batch_src (l_chr_batch_source_name);
  FETCH cur_get_batch_src INTO g_num_batch_source_id, g_batch_source_name;
  CLOSE cur_get_batch_src;
  l_chr_exe_location := 'GDFLT_0004';
  l_stmt_processing  := 'Checking if the Setup requried for Invoice creation exists' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Raise error if the default value requried for Invoice creation does not
  -- exists
  IF g_num_batch_source_id IS NULL THEN
    write_msg( g_write_logfile , ' Invoice Batch Source [' || l_chr_batch_source_name || '] not defined ');
    p_out_chr_errbuff := p_out_chr_errbuff || '- Invoice Batch Source [' || l_chr_batch_source_name || '] not defined ';
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  --
  -- For fetching the payment Term_id
  --
  l_chr_exe_location := 'GDFLT_0005';
  l_stmt_processing  := 'Opening Cursor for Payment Terms' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_terms_id (l_chr_terms_name ) ;
  FETCH cur_get_terms_id INTO g_term_name, g_term_id;
  CLOSE cur_get_terms_id;
  l_chr_exe_location := 'GDFLT_0006';
  IF g_term_id       IS NULL THEN
    write_msg( g_write_logfile , ' - Payment Term [' || l_chr_terms_name || '] not defined ');
    p_out_chr_errbuff := 'Payment Term [' || l_chr_terms_name || '] not defined ';
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  --
  -- For fetching the Customer Account Number
  --
  l_stmt_processing  := 'Opening Cursor to Get account Number and Site_id' ;
  l_chr_exe_location := 'GDFLT_0007';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_acct_num ;
  FETCH cur_get_acct_num INTO g_cust_account_id , g_cust_acc_site_id ;
  CLOSE cur_get_acct_num ;
  l_chr_exe_location   := 'GDFLT_0008';
  IF g_cust_account_id IS NULL THEN
    write_msg( g_write_logfile , ' Unable to get Customer Account from Lookup xx_AR_ACCT_NUMBER ');
    p_out_chr_errbuff := p_out_chr_errbuff || '- Unable to get Customer Account from Lookup xx_AR_ACCT_NUMBER ';
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  l_chr_exe_location := 'GDFLT_0009';
  l_stmt_processing  := ' Retrieving dist_code_combination_id for Distribtion Set IT_RFND_PAY_DS ';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_dist_ccid(l_dist_set_name);
  FETCH cur_get_dist_ccid INTO g_refd_ccid;
  CLOSE cur_get_dist_ccid ;
  l_chr_exe_location := 'GDFLT_0010';
  IF g_refd_ccid   IS NULL THEN
    write_msg( g_write_logfile , ' Unable to derive refd Account id for Distribution Set ' || l_dist_set_name);
    p_out_chr_errbuff := p_out_chr_errbuff || ' Unable to derive refd Account id for Distribution Set ' || l_dist_set_name;
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  l_chr_exe_location := 'GDFLT_0011';
  l_stmt_processing  := ' Retrieving dist_code_combination_id for Adjustment Distribtion Set IT_RFND_ADJ_DS ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_dist_ccid(l_adj_dist_set_name);
  FETCH cur_get_dist_ccid INTO g_adjustment_ccid;
  CLOSE cur_get_dist_ccid ;
  l_chr_exe_location   := 'GDFLT_0012';
  IF g_adjustment_ccid IS NULL THEN
    write_msg( g_write_logfile , ' Unable to derive Adjustment Account id for Distribution Set ' || l_adj_dist_set_name);
    p_out_chr_errbuff := p_out_chr_errbuff || ' Unable to derive Adjustment Account id for Distribution Set ' || l_adj_dist_set_name;
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  l_chr_exe_location := 'GDFLT_0013';
  l_stmt_processing  := ' Retrieving application_id, responsibility_id from fnd_responsibility_tl for Payables Manager ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_appl_resp_id (l_payable_resp_name);
  FETCH cur_get_appl_resp_id INTO g_pay_application_id , g_pay_resp_id;
  CLOSE cur_get_appl_resp_id;
  l_chr_exe_location := 'GDFLT_0014';
  IF g_pay_resp_id   IS NULL THEN
    write_msg( g_write_logfile , ' Unable to derive Respnsibility id for Responsibility ' || l_payable_resp_name);
    p_out_chr_errbuff := p_out_chr_errbuff || ' Unable to derive Respnsibility id for Responsibility ' || l_payable_resp_name;
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  l_chr_exe_location := 'GDFLT_0015';
  l_stmt_processing  := ' Retrieving vendor_id,vendor_site_id from po_vendors,po_vendor_sites_all for Xx Refd Customer ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_vendor_info (l_pay_vendor_name);
  FETCH cur_get_vendor_info INTO g_vendor_id , g_vendor_site_id;
  CLOSE cur_get_vendor_info ;
  l_chr_exe_location := 'GDFLT_0016';
  IF g_vendor_id     IS NULL THEN
    write_msg( g_write_logfile , ' Unable to derive Vendor details for Vendor ' || l_pay_vendor_name);
    p_out_chr_errbuff := p_out_chr_errbuff || ' Unable to derive Vendor details for Vendor ' || l_pay_vendor_name;
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  l_stmt_processing  := ' Fetching the Receivable and CCID for write-off';
  l_chr_exe_location := 'GDFLT_0016-1';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_recv_info (l_receivable_trx_type ,g_num_org_id );
  FETCH cur_get_recv_info INTO g_receivables_trx_id, g_recv_ccid;
  CLOSE cur_get_recv_info ;
  IF g_receivables_trx_id IS NULL THEN
    write_msg( g_write_logfile , ' Unable to derive Receivables Transaction Id and CCID for Type ' || l_receivable_trx_type );
    p_out_chr_errbuff := p_out_chr_errbuff || ' Unable to derive Receivables Transaction Id and CCID for Type ' || l_receivable_trx_type ;
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  l_stmt_processing  := ' Fetching the Payment Schedule Id for write-off';
  l_chr_exe_location := 'GDFLT_0016-2';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  OPEN cur_get_payschd_info (l_pay_trx_number );
  FETCH cur_get_payschd_info INTO g_payment_schedule_id;
  CLOSE cur_get_payschd_info ;
  IF g_payment_schedule_id IS NULL THEN
    write_msg( g_write_logfile , ' Unable to derive Payment Schedule Id for TRX_NUMBER ' || l_pay_trx_number );
    p_out_chr_errbuff := p_out_chr_errbuff || ' Unable to derive Payment Schedule Id for TRX_NUMBER ' || l_pay_trx_number ;
    p_out_chr_retcode := g_chr_failure_code;
  END IF;
  l_stmt_processing   := 'Checking if any Setup info missing ' ;
  l_chr_exe_location  := 'GDFLT_0017';
  IF p_out_chr_retcode = g_chr_failure_code THEN
    RETURN;
  END IF;
  -- Including the Bulk validation into this routine as these can done for the
  -- set of records at one strech
  -- instead of doing it for each record
  l_stmt_processing  := ' Checking if any Duplicate ID, Assessment, Major Head and Type ';
  l_chr_exe_location := 'GDFLT_0018';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );

  UPDATE xx_AR_TRANS_STG XATS
  SET status_code = 'ERROR',
    error_message = error_message
    || ' , '
    || 'Duplicate IRT Record in Staging for the ID, Assmt Year , Major Head, Minor Head and Schedule type combination'
  WHERE -- status_code = 'NEW' AND
    request_id = p_in_request_id
  AND EXISTS
    (SELECT 'x'
    FROM xx_AR_TRANS_STG XATS1
    WHERE XATS.bill_to_customer_number = XATS1.bill_to_customer_number
    AND XATS.assessment_year           = XATS1.assessment_year
    AND XATS.major_head                = XATS1.major_head
    AND XATS.irt_schedule_type         =XATS1.irt_schedule_type
    AND XATS.minor_head                =XATS1.minor_head
    AND XATS.rowid                    != XATS1.rowid
    AND status_code                    = 'NEW'
    );
  l_chr_exe_location := 'GDFLT_0019';
  l_stmt_processing  := ' Checking if any Duplicate IRT_id across ID / Assessment Year';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE xx_AR_TRANS_STG xats
  SET status_code = 'ERROR',
    error_message = error_message
    || ' , '
    || 'Duplicate IRT Record in Staging , across ID / Assessment year'
  WHERE --status_code = 'NEW' AND
    request_id = p_in_request_id
  AND EXISTS
    (SELECT transaction_number
    FROM xx_ar_trans_stg xats1
    WHERE xats.transaction_number       = xats1.transaction_number
    AND xats1.status_code               = 'NEW' --Added to handle rectification cases.
    AND ( xats.bill_to_customer_number <> xats1.bill_to_customer_number
    OR xats.assessment_year            <> xats1.assessment_year )
    );
  l_stmt_processing  := ' Checking if any Multiple IRT_id for Customer for a assessment year';
  l_chr_exe_location := 'GDFLT_0020';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE xx_AR_TRANS_STG xats
  SET status_code = 'ERROR',
    error_message = error_message
    || ' , '
    || 'Duplicate IRT Record in Staging, Multiple IRT_ID for ID, Assessment Year combination'
  WHERE --status_code = 'NEW' AND
    request_id = p_in_request_id
  AND EXISTS
    (SELECT transaction_number
    FROM xx_ar_trans_stg xats1
    WHERE xats.transaction_number   <> xats1.transaction_number
    AND xats1.status_code            = 'NEW' --added
    AND xats.bill_to_customer_number = xats1.bill_to_customer_number
    AND xats.assessment_year         = xats1.assessment_year
    );
  l_stmt_processing  := ' Checking if any Processed IRT is being sent Again';
  l_chr_exe_location := 'GDFLT_0021';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  FND_FILE.PUT_LINE(FND_FILE.log,'g_num_batch_source_id:'||g_num_batch_source_id);
  UPDATE xx_AR_TRANS_STG xats
  SET status_code = 'ERROR',
    error_message = error_message
    || ' , '
    || 'Duplicate IRT Record in FAS.'
  WHERE -- status_code = 'NEW' AND
    request_id = p_in_request_id
  AND EXISTS
    (SELECT rct.attribute11
    FROM ra_customer_trx_all rct,
      ra_cust_trx_types_all rctt
    WHERE rct.cust_trx_type_id = rctt.cust_trx_type_id
    AND rct.attribute5         = xats.bill_to_customer_number
    AND RCT.ATTRIBUTE4         = TO_CHAR(XATS.ASSESSMENT_YEAR)
    AND RCT.ATTRIBUTE1        <> '0032' --Added To skip WTR_ID'S
    AND rct.batch_source_id    = g_num_batch_source_id
    AND rctt.type              = 'INV'
    AND NOT EXISTS
      (SELECT 1
      FROM ra_customer_trx_all cm
      WHERE cm.previous_customer_trx_id = rct.customer_trx_id
      AND cm.batch_source_id            = g_num_batch_source_id
      )
    AND rct.attribute8 IS NULL
    );
  l_stmt_processing  := ' Checking if any Prior Refd not reversed yet';
  l_chr_exe_location := 'GDFLT_0022';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE xx_AR_TRANS_STG xats
  SET status_code = 'ERROR',
    error_message = error_message
    || ' , '
    ||'Prior Refd not reversed yet.'
  WHERE -- status_code = 'NEW' AND
    request_id = p_in_request_id
  AND EXISTS
    (SELECT xrh.irt_id
    FROM xx_refd_headers xrh
    WHERE xrh.id_number             = xats.bill_to_customer_number
    AND XRH.IRT_AY                   = XATS.ASSESSMENT_YEAR
    AND XRH.MAJOR_HEAD              <> '0032' --Added to SKIP WTR_ID's
    AND xrh.rr_ref_dem_trx_id       IS NULL
    AND xrh.cancelled_refd_amount IS NULL
    );
  l_stmt_processing  := ' Checking if any revised / rectification invoices before the Original Invoice' ;
  l_chr_exe_location := 'GDFLT_0023';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE xx_AR_TRANS_STG xats
  SET status_code = 'ERROR',
    error_message =error_message
    || ' , '
    || 'There is no ORIGINAL processed record available for the ID- '
    || xats.bill_to_customer_number
    || 'and AY-'
    || xats.assessment_year
    || 'combination'
  WHERE -- status_code = 'NEW' AND
    REQUEST_ID                  = P_IN_REQUEST_ID
  AND UPPER (TRANSACTION_TYPE) IN ('REVISED', 'RECTIFICATION')
  AND NOT EXISTS
    (SELECT 1
    FROM ra_customer_trx_all rcta,
      ra_cust_trx_types_all rctt
    WHERE rcta.cust_trx_type_id  = rctt.cust_trx_type_id
    AND rcta.attribute5          = xats.bill_to_customer_number
    AND RCTA.ATTRIBUTE4          = XATS.ASSESSMENT_YEAR
    AND RCTA.ATTRIBUTE1         <> '0032'                --Added To skip WTR_ID'S
    AND UPPER (rctt.attribute2) IN ('ORIGINAL','REVISED')--check modified on
      -- 7-SEP-2012 for revised cases also the rectification will be
      -- accepted.
    AND UPPER (rcta.attribute9) ='RR IRT DEM CANCEL'
    );
  write_validation_error (p_out_chr_retcode => p_out_chr_retcode , p_out_chr_errbuff => p_out_chr_errbuff , p_request_id => p_in_request_id);
  l_stmt_processing  := 'Updating default value requried for Invoice creation which does not have any error' ;
  l_chr_exe_location := 'GDFLT_0024';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  /** Start of Code*****Block to Update Fraudulent ID *******/
  UPDATE xx_AR_TRANS_STG xats
  SET status_code       = 'ERROR',
    error_message       = 'FRAUDULENT ID DETERMINED'
  WHERE REQUEST_ID      = P_IN_REQUEST_ID
  AND TRANSACTION_TYPE IN ('Original', 'Revised')
  AND ( --Added as a Part of CR_HWSW_0483 - Starts Here
    NOT EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_HOLD_FRAUD_ID_CUS IFPT
    WHERE IFPT.IRT_ID  =XATS.TRANSACTION_NUMBER
    AND IFPT.ID_CD    =XATS.BILL_TO_CUSTOMER_NUMBER
    AND IFPT.READ_FLAG = 'P'
    ) ) --Added as a Part of CR_HWSW_0483 - Ends Here
  AND ( EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_FRAUD_ID IFP
    WHERE IFP.ID_CD = XATS.BILL_TO_CUSTOMER_NUMBER
    )
    --Added as a part of CR_HWSW_179 Starts 03-JUN-2014
  OR EXISTS
    (SELECT 1
    FROM IRT_STDCMP.irt_sch_tcs IST
    WHERE IST.IRT_ID=xats.transaction_number
    AND EXISTS
      (SELECT 1
      FROM IRT_STDCMP.IRT_FRAUD_ID IFP
      WHERE IFP.CUS_CD = IST.TI_COLLECTOR_CUS_CD
      )
    )
    --Added as a part of CR_HWSW_179 ENDS 03-JUN-2014
  OR EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_TS_SALARY ITS
    WHERE its.irt_id = xats.transaction_number
    AND EXISTS
      (SELECT 1
      FROM IRT_STDCMP.IRT_FRAUD_ID IFP
      WHERE IFP.CUS_CD = ITS.TOS_EMPLOYER_CUS_CD
      )
    )
  OR EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_TS_INTEREST ITI
    WHERE iti.irt_id = xats.transaction_number
    AND EXISTS
      (SELECT 1
      FROM IRT_STDCMP.IRT_FRAUD_ID IFP
      WHERE IFP.CUS_CD = ITI.TOI_DEDCTOR_CUS_CD
      )
    ) );
  --Commented as a Part of Hotfix#107229 - Starts Here
  /*
  IF(SQL%ROWCOUNT >0) THEN
  FOR i        IN
  ( SELECT DISTINCT Transaction_Number irt_id
  FROM xx_ar_trans_stg
  WHERE Error_Message LIKE '%FRAUDULENT ID DETERMINED%'
  AND Request_Id = P_In_Request_Id
  )
  LOOP
  L_Chr_Exe_Location := 'GDFLT_0025';
  Write_Debug( G_Debug_Flag ,L_Chr_Exe_Location ||'-'||'Fraudulent Check' );
  --Added as a Part of CR_HWSW_0483 - Starts Here
  v_fraud_count :=0;
  V_READ_FLAG :='';
  BEGIN
  select COUNT(1),READ_FLAG into V_FRAUD_COUNT,V_READ_FLAG
  from irt_stdcmp.IRT_HOLD_FRAUD_ID_CUS where irt_id=i.irt_id
  group by READ_FLAG;
  EXCEPTION
  when NO_DATA_FOUND then
  v_fraud_count :=0;
  null;
  END;
  if v_fraud_count=0 then
  Pdc_Etl.Pkg_Queue_Movement.Sp_Update_Pcm_Abandon_Status (i.irt_id, 5, 81, '
  FAS', 35026, --35024
  'Fraduluent Records being Processed from FAS',
  --Approval_txt
  NULL ,
  --NULL
  NULL ,
  --NULL
  p_out_cd_etl , P_Out_Msg_Etl );
  else
  if v_read_flag <> 'P' THEN
  UPDATE xx_AR_TRANS_STG
  SET status_code       = 'ERROR',
  error_message       = 'FRAUDULENT ID DETERMINED'
  where transaction_number = i.irt_id
  ;
  end if;
  end if;
  --Added as a Part of CR_HWSW_0483 - Ends Here
  Write_Debug( G_Debug_Flag ,L_Chr_Exe_Location ||'-'||P_Out_Msg_Etl );
  END LOOP;
  END IF;
  */
  --Commented as a Part of Hotfix#107229 - Ends Here
  --FRAUDULENT CUS_ID_CR_HWSW_179 FOR RCETIFICATION STARTS HERE 11-Nov-2014
  dbms_output.put_line('Insert Into IRT_STDCMP.FRAUD_ID_CUS_FOR_XFR_TO_AST');
  INSERT
  INTO IRT_STDCMP.FRAUD_ID_CUS_FOR_XFR_TO_AST
    (
      irt_id,
      ID_CD,
      ASSMENT_YEAR,
      RD_FLAG
    )
    ( SELECT DISTINCT xats.transaction_number,
        xats.bill_to_customer_number,
        xats.assessment_year,
        'N'
      FROM xx_AR_TRANS_STG xats
      WHERE REQUEST_ID      = P_IN_REQUEST_ID
      AND TRANSACTION_TYPE IN ('Rectification')
      AND --Added as a Part of CR_HWSW_0483 - Starts Here
        EXISTS
        (SELECT 1
        FROM IRT_STDCMP.IRT_HOLD_FRAUD_ID_CUS IFPT
        WHERE IFPT.IRT_ID  =XATS.TRANSACTION_NUMBER
        AND IFPT.ID_CD    =XATS.BILL_TO_CUSTOMER_NUMBER
        AND IFPT.READ_FLAG = 'T'
        )
      AND NOT EXISTS
        (SELECT 1
        FROM IRT_STDCMP.FRAUD_ID_CUS_FOR_XFR_TO_AST
        WHERE IRT_ID =XATS.TRANSACTION_NUMBER
        AND ID_CD   =XATS.BILL_TO_CUSTOMER_NUMBER
        )--Added as a Part of CR_HWSW_0483 - Ends Here
      AND ( EXISTS
        (SELECT 1
        FROM IRT_STDCMP.IRT_FRAUD_ID IFP
        WHERE IFP.ID_CD = XATS.BILL_TO_CUSTOMER_NUMBER
        )
      OR EXISTS
        (SELECT 1
        FROM IRT_STDCMP.irt_sch_tcs IST
        WHERE IST.IRT_ID=xats.transaction_number
        AND EXISTS
          (SELECT 1
          FROM IRT_STDCMP.IRT_FRAUD_ID IFP
          WHERE IFP.CUS_CD = IST.TI_COLLECTOR_CUS_CD
          )
        )
      OR EXISTS
        (SELECT 1
        FROM IRT_STDCMP.IRT_TS_SALARY ITS
        WHERE its.irt_id = xats.transaction_number
        AND EXISTS
          (SELECT 1
          FROM IRT_STDCMP.IRT_FRAUD_ID IFP
          WHERE IFP.CUS_CD = ITS.TOS_EMPLOYER_CUS_CD
          )
        )
      OR EXISTS
        (SELECT 1
        FROM IRT_STDCMP.IRT_TS_INTEREST ITI
        WHERE iti.irt_id = xats.transaction_number
        AND EXISTS
          (SELECT 1
          FROM IRT_STDCMP.IRT_FRAUD_ID IFP
          WHERE IFP.CUS_CD = ITI.TOI_DEDCTOR_CUS_CD
          )
        ) )
    );
  IF ( SQL%ROWCOUNT > 0 ) THEN
    write_debug ( g_debug_flag ,'Number of records Detected as Fraud : '||sql%rowcount ) ;
	 dbms_output.put_line('Number of records Detected as Fraud : '||sql%rowcount ) ;
  END IF;
  --FRAUDULENT CUS_ID_CR_HWSW_179 FOR RCETIFICATION ENDS HERE
  --Added as a Part of CR_HWSW_0483 - Starts Here
  UPDATE xx_AR_TRANS_STG xats
  SET status_code       = 'ERROR',
    error_message       = 'HOLDING FRAUDULENT ID DETERMINED'
  WHERE REQUEST_ID      = P_IN_REQUEST_ID
  AND TRANSACTION_TYPE IN ('Rectification')
  AND ( --Added as a Part of CR_HWSW_0483 - Starts Here
    NOT EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_HOLD_FRAUD_ID_CUS IFPT
    WHERE IFPT.IRT_ID   =XATS.TRANSACTION_NUMBER
    AND IFPT.ID_CD     =XATS.BILL_TO_CUSTOMER_NUMBER
    AND IFPT.READ_FLAG IN ('P','T')
    ) ) --Added as a Part of CR_HWSW_0483 - Ends Here
  AND ( EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_FRAUD_ID IFP
    WHERE IFP.ID_CD = XATS.BILL_TO_CUSTOMER_NUMBER
    )
    --Added as a part of CR_HWSW_179 Starts 03-JUN-2014
  OR EXISTS
    (SELECT 1
    FROM IRT_STDCMP.irt_sch_tcs IST
    WHERE IST.IRT_ID=xats.transaction_number
    AND EXISTS
      (SELECT 1
      FROM IRT_STDCMP.IRT_FRAUD_ID IFP
      WHERE IFP.CUS_CD = IST.TI_COLLECTOR_CUS_CD
      )
    )
    --Added as a part of CR_HWSW_179 ENDS 03-JUN-2014
  OR EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_TS_SALARY ITS
    WHERE its.irt_id = xats.transaction_number
    AND EXISTS
      (SELECT 1
      FROM IRT_STDCMP.IRT_FRAUD_ID IFP
      WHERE IFP.CUS_CD = ITS.TOS_EMPLOYER_CUS_CD
      )
    )
  OR EXISTS
    (SELECT 1
    FROM IRT_STDCMP.IRT_TS_INTEREST ITI
    WHERE iti.irt_id = xats.transaction_number
    AND EXISTS
      (SELECT 1
      FROM IRT_STDCMP.IRT_FRAUD_ID IFP
      WHERE IFP.CUS_CD = ITI.TOI_DEDCTOR_CUS_CD
      )
    ) );
  --Commented as a Part of Hotfix#107229 - Starts here
  /*
  IF(SQL%ROWCOUNT >0) THEN
  FOR i        IN
  ( SELECT DISTINCT Transaction_Number irt_id
  FROM xx_ar_trans_stg
  WHERE Error_Message LIKE '%FRAUDULENT ID DETERMINED%'
  AND Request_Id = P_In_Request_Id
  )
  LOOP
  L_Chr_Exe_Location := 'GDFLT_0026';
  Write_Debug( G_Debug_Flag ,L_Chr_Exe_Location ||'-'||'Fraudulent Check' );
  --Added as a Part of CR_HWSW_0483 - Starts Here
  v_fraud_count_rec :=0;
  v_read_flag_rec :='';
  BEGIN
  select COUNT(1),READ_FLAG into V_FRAUD_COUNT_REC,V_READ_FLAG_REC
  from irt_stdcmp.IRT_HOLD_FRAUD_ID_CUS where irt_id=i.irt_id
  group by READ_FLAG;
  EXCEPTION
  when NO_DATA_FOUND then
  V_FRAUD_COUNT_REC :=0;
  null;
  END;
  if V_FRAUD_COUNT_REC=0 then
  write_msg( g_write_logfile ,' Before Calling
  pkg_queue_movement.sp_update_pcm_status_25 : '||i.irt_id);
  Pdc_Etl.pkg_queue_movement.sp_update_pcm_status_25 (i.irt_id, 5, 25, 'F',
  p_out_cd_etl , P_Out_Msg_Etl );
  Write_Debug( G_Debug_Flag ,L_Chr_Exe_Location ||'-'||P_Out_Msg_Etl );
  else
  if v_read_flag_rec <> 'P' THEN
  UPDATE xx_AR_TRANS_STG
  SET status_code       = 'ERROR',
  error_message       = 'HOLDING FRAUDULENT ID DETERMINED'
  where transaction_number = i.irt_id;
  end if;
  end if;
  END LOOP;
  END IF;
  --Added as a Part of CR_HWSW_0483 - Ends Here
  */
  --Commented as a Part of Hotfix#107229 - Ends Here
  /** End of Code*****Block to Update Fraudulent ID *******/
  UPDATE xx_ar_trans_stg xatg
  SET dr_batch_source_id      = g_num_batch_source_id,
    dr_batch_source_name      = g_batch_source_name,
    dr_term_name              = g_term_name,
    dr_term_id                = g_term_id,
    dr_cust_account_id        = g_cust_account_id ,
    dr_cust_acct_site_id      = g_cust_acc_site_id,
    dr_interface_line_context = 'IT Return',
    dr_line_type              = 'LINE',
    dr_currency_code          = 'INR',
    dr_conversion_rate        = '1',
    dr_conversion_type        = 'User',
    quantity                  = '1',
    dr_uom_code               = NULL,
    created_by                = fnd_global.user_id,
    creation_date             = sysdate,
    dr_org_id                 = g_num_org_id,
    amount_includes_xx_flag  = 'N'
  WHERE status_code           = 'NEW'
  AND request_id              = p_in_request_id;
  COmmit;
  Dbms_output.put_line('end get_dflt_value procedure..' );
  l_chr_exe_location         := 'GDFLT_0025';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  write_debug( g_debug_flag , 'Moving out from Procedure ' || l_chr_proc_name ) ;
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name || '-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || SUBSTR(sqlerrm, 1,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
END get_dflt_value;
-- ***************** End of Function / Procedure **********************--
/******************************************************************************
**************************************
* Type : PROCEDURE
* Type                 : PROCEDURE
* Name                 : Update_ar_trans_stg_tbl
* Input Parameters     : p_in_irt_id,p_in_request_id
* Output Parameters    : p_out_chr_errbuff ; p_out_chr_retcode
* Purpose              : This Procedure will calculate Interest 234B
calculation
from 46 date to sysdate and update xx_ar_trans_stg,
This proc is added for CR_HWSW_224
* Company              : Infosys Technologies Ltd.
* Created By           : Infosys
* Created Date         : 19-mar-14
* Last Reviewed By     :
* Last Reviewed Date   :
*******************************************************************************
**************************************
* Modified Date  Modified By  Version  Reviewed By     Reviewed Date
Modification Type Modification Details
* -------------  ------------ -------- --------------- --------------
----------------- --------------------------
* 19-mar-14     Infosys     1.0
Created
*******************************************************************************
***********************************/
PROCEDURE Update_ar_trans_stg_tbl(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2,
    p_in_irt_id        IN VARCHAR2,
    P_IN_REQUEST_ID    IN NUMBER ,
    p_in_months_exists IN NUMBER)
IS
  /* Below cursor is for CR_HW_224, to get data from xx_ar_trans_stg, first
  we need to select minor head like '%234B%' */
  CURSOR cur_inv_stg_status (p_irt_id IN VARCHAR2,p_request_id IN NUMBER)
  IS
    SELECT *
    FROM apps.xx_ar_trans_stg
    WHERE request_id       =p_request_id
    AND transaction_number = p_irt_id
    AND status_code        = 'NEW'
    AND minor_head        IN ('Rev Interest 234B','Interest 234B', 'Rec Interest 234B');
  --AND minor_head LIKE '%234B%'; for tuning the query ,we removed the line on
  -- 04-july-2014
  X_attribute1       NUMBER        := NULL;
  l_chr_proc_name    VARCHAR2(150) :='Update_ar_trans_stg_tbl';
  l_chr_exe_location VARCHAR2(150) :='';
  l_stmt_processing  VARCHAR2(200);
  l_chr_errbuff      VARCHAR2(3000) := '';
  L_CHR_RETCODE      VARCHAR2 (10);
  L_form_type_code "process_store"."irt_process_control_mstr"."form_type_code"@psql_process_fas%TYPE; --Added as a Part
  -- of Hotfix#113277 - 06-May-2016
  L_REC_COUNT NUMBER :=0; -- Added as a Part of Hotfix#113277 On 25-Nov-2016
  l_num_irt number;
BEGIN
l_num_irt := to_number(P_IN_IRT_ID);   --Added for ABC-2.0 Bhagya
  write_debug( g_debug_flag , 'Entering Procedure ' || l_chr_proc_name );
  dbms_output.put_line('start of Update_ar_trans_stg_tbl');

  FOR X_cur_inv_stg_status_1 IN cur_inv_stg_status(p_in_irt_id,p_in_request_id)
  LOOP
    -- cursor1
    /*selecting the records of 'ORIGINAL' or 'REVISED' for CR_HW_0224 */
    IF upper(X_cur_inv_stg_status_1.transaction_type) IN ('ORIGINAL','REVISED') THEN
      l_chr_exe_location := 'UPD_TRN_02';
      l_stmt_processing  := 'Entered cursor 1';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      write_msg( g_write_logfile ,' P_IN_MONTHS_EXISTS '|| P_IN_MONTHS_EXISTS);
      IF P_IN_MONTHS_EXISTS >0 THEN
        l_chr_exe_location := 'UPD_TRN_01';
        l_stmt_processing  := 'Interest need to calculate ';
        Write_Debug ( G_Debug_Flag ,L_Chr_Exe_Location ||'-'||L_Stmt_Processing ) ;
        --Added as a Part of Hotfix#113277 - Starts here On 25-Nov-2016
		BEGIN
        SELECT "form_type_code"
        INTO L_form_type_code
        FROM "process_store"."irt_process_control_mstr"@psql_process_fas
        WHERE "irt_id"=P_IN_IRT_ID;
		EXCEPTION
		WHEN no_data_found then
		dbms_output.put_line('No form type code for irt id : '||P_IN_IRT_ID);		
		END;

        write_msg( g_write_logfile ,' L_form_type_code '|| L_form_type_code);
        L_REC_COUNT      :=0;
        IF L_form_type_code = 1 THEN
          SELECT COUNT(1)
          INTO L_REC_COUNT
          FROM "process_store"."irt_irt1_xx_liab_prcssd"@psql_process_fas
          WHERE "irt_id"           =P_IN_IRT_ID
          AND "tp_xx_payable_amt" > 100;
        ELSE
          SELECT COUNT(1)
          INTO L_REC_COUNT
          FROM "process_store"."irt_xx_lia_tot_incm_prcssd"@psql_process_fas
          WHERE "irt_id"       =P_IN_IRT_ID
          AND "tp_xx_pay_amt" > 100;
        END IF;
        WRITE_MSG( G_WRITE_LOGFILE ,' L_REC_COUNT '|| L_REC_COUNT);
        write_msg( g_write_logfile ,' X_cur_inv_stg_status_1.attribute1 '|| X_cur_inv_stg_status_1.attribute1);
        IF L_REC_COUNT > 0 THEN
          x_attribute1:=(NVL(X_cur_inv_stg_status_1.attribute1,0)*(1/100)* p_in_months_exists);
        ELSE
          x_attribute1 :=0;
        END IF;
        write_msg( g_write_logfile ,' x_attribute1 '|| x_attribute1);
        --Added as a Part of Hotfix#113277 - Ends here On 25-Nov-2016
        --  x_attribute1:=(NVL(X_cur_inv_stg_status_1.attribute1,0)*(1/100)*
        -- p_in_months_exists); --Needs to be comment
        write_debug( g_debug_flag ,'Interest amount : ' || x_attribute1);
        BEGIN
          l_chr_exe_location := 'UPD_TRN_02';
          l_stmt_processing  := 'Updating xx_ar_trans_stg table with interest amount';
          write_debug ( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ) ;
          UPDATE xxcus.xx_ar_trans_stg
          SET ATTRIBUTE3           = LINE_AMOUNT,
            LINE_AMOUNT            =LINE_AMOUNT+X_attribute1,
            ATTRIBUTE5             =X_attribute1
          WHERE transaction_number = p_in_irt_id
          AND REQUEST_ID           = p_in_request_id
          AND status_code          = 'NEW'
          AND minor_head          IN ('Rev Interest 234B','Interest 234B', 'Rec Interest 234B');

          --AND minor_head LIKE '%234B%'; for tuning the query ,we removed the
          -- line on 04-july-2014
          --Below added as a Part of Hotfix#113277 - Starts Here --06-May-2016
          BEGIN
            --  select form_type_code into L_form_type_code from
            -- IRT_PROCESS_CONTROL_MSTR where IRT_ID=P_IN_IRT_ID; --Commented
            -- as a part of Hotfix#113277
            IF L_form_type_code = 1 THEN
			BEGIN
              UPDATE "process_store"."irt_irt1_xx_liab_prcssd"@psql_process_fas
              SET
                --TP_REFD_AMT=TP_REFD_AMT-X_ATTRIBUTE1,
                "tc_int_sec234b_amt" ="tc_int_sec234b_amt"+X_ATTRIBUTE1,
                "tc_int_pay_tot_amt" ="tc_int_pay_tot_amt"+X_ATTRIBUTE1,
                "tp_xx_payable_amt" ="tp_xx_payable_amt"+X_attribute1 ---changes
                -- done for hot fix 146788 changes done for incremental 234
              WHERE "irt_id" =l_num_irt; --P_IN_IRT_ID;
			  EXCEPTION
			  WHEN OTHERS THEN 
			  dbms_output.put_line('Error updating irt_irt1_xx_liab_prcssd in postgres'||SQLERRM);
			  END;

            ELSE
              IF L_form_type_code <> 1 THEN
			  BEGIN
                UPDATE "process_store"."irt_xx_lia_tot_incm_prcssd"@psql_process_fas
                SET
                  --TP_REFD_AMT=TP_REFD_AMT-X_ATTRIBUTE1,
                  "ctl_int_pay_sec234b_amt"="ctl_int_pay_sec234b_amt"+X_ATTRIBUTE1,
                  "ctl_int_pay_tot_amt"    ="ctl_int_pay_tot_amt"    +X_ATTRIBUTE1,
                  "ctl_agg_liab_amt"       ="ctl_agg_liab_amt"       +X_ATTRIBUTE1,
                  "tp_xx_pay_amt"         = "tp_xx_pay_amt"        +X_ATTRIBUTE1
                  --Added to populate intimation correctly
                WHERE "irt_id" =P_IN_IRT_ID;
				EXCEPTION WHEN OTHERS THEN
				DBMS_OUTPUT.PUT_LINE('Error updating irt_xx_lia_tot_incm_prcssd in Postgres'||SQLERRM);
				END;
              END IF;
            END IF;
            write_debug( g_debug_flag ,'Number of rows updated for 234B: '|| sql%rowcount );
          EXCEPTION
          WHEN OTHERS THEN
            p_out_chr_retcode := g_chr_failure_code;
            P_OUT_CHR_ERRBUFF := 'Unexpected Error in procedure ' || L_CHR_PROC_NAME ||'-' || L_CHR_EXE_LOCATION ||'-' || L_STMT_PROCESSING ||'-' || SUBSTR(SQLERRM,1,255);
            write_debug( g_debug_flag ,p_out_chr_errbuff );
          END;
          --Below added as a Part of Hotfix#113277 - Ends Here - 06-May-2016
          write_debug( g_debug_flag ,'Number of rows updated : '||sql%rowcount );
        EXCEPTION
        WHEN OTHERS THEN
          l_chr_exe_location:= 'UPD_TRN_03';
          l_stmt_processing := 'Updation error in stg table';
          p_out_chr_retcode := g_chr_failure_code;
          p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || SUBSTR(sqlerrm,1,255);
          write_debug( g_debug_flag ,p_out_chr_errbuff );
          Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
          IF l_chr_retcode = g_chr_failure_code THEN
            write_debug( g_debug_flag , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
          ELSE
            log_exception ( p_out_chr_errbuff => l_chr_errbuff , p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
            IF l_chr_retcode = g_chr_failure_code THEN
              write_debug( g_debug_flag , ' Error also while writing error data of Procedure - '|| l_chr_proc_name || '-' ||l_chr_errbuff );
            END IF;
          END IF;
        END;
      END IF; --x_month_exists>0
    END IF;   --
  END LOOP;

EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name || '-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || SUBSTR(sqlerrm, 1,255);
  write_debug( g_debug_flag ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_debug( g_debug_flag , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_debug( g_debug_flag , ' Error also while writing error data of Procedure - '|| l_chr_proc_name || '-' ||l_chr_errbuff );
    END IF;
  END IF;
  dbms_output.put_line ('Exit from Update_ar_trans_stg_tbl');
END Update_ar_trans_stg_tbl;
-- ***************** End of Function / Procedure **********************--
/******************************************************************************
**************************************
* Type                 : PROCEDURE
* Name : validate_create_invoice
* Input Parameters : p_in_request_id
* Output Parameters : p_out_chr_errbuff ; p_out_chr_retcode
* Purpose : This Procedure would validate the data in the staging table,
* calls the write off routine to indentify the amount, derives value
* and then call Invoice API for creating the invoice for the IRT
* Company : Infosys Technologies Ltd.
* Created By : Infosys
* Created Date : 22-Dec-11
* Last Reviewed By :
* Last Reviewed Date :
*******************************************************************************
**************************************
* Modified Date Modified By Version Reviewed By Reviewed Date Modification Type
Modification Details
* ------------- ------------ -------- --------------- --------------
----------------- --------------------------
* 22-Dec-11 Infosys 1.0 Created
*******************************************************************************
***********************************/
PROCEDURE validate_create_invoice(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2,
    p_in_irt_id     IN VARCHAR2,
    p_in_request_id IN NUMBER )
IS
  -- Cursor to fetch Memo Id
  CURSOR Cur_Get_Memo_Details (P_Major_Head IN VARCHAR2 ,P_Minor_Head IN VARCHAR2 ,p_schedule_type IN VARCHAR2)
  IS
    /*SELECT ar.memo_line_id,
      ar.description,
      ar.set_of_books_id
    FROM ar_memo_lines_vl ar
    WHERE upper(ar.attribute1) = upper(P_Major_Head)
    AND upper(ar.attribute2)   = upper(P_Minor_Head)
    AND upper(ar.attribute3)   = upper(p_schedule_type)
    AND TRUNC (SYSDATE) BETWEEN NVL(start_date, TRUNC (SYSDATE)) AND NVL( end_date , TRUNC (SYSDATE));
	*/

	SELECT t.memo_line_id,
     t.description,
     b.set_of_books_id
    From AR_MEMO_LINES_ALL_TL T, AR_MEMO_LINES_ALL_B B 
    WHERE B.MEMO_LINE_ID = T.MEMO_LINE_ID 
    and NVL(B.ORG_ID, -99) = NVL(T.ORG_ID, -99) 
    and T.LANGUAGE = userenv('LANG')
    and upper(b.attribute1) = upper(P_Major_Head)
    AND upper(b.attribute2)   = upper(P_Minor_Head)
    AND upper(b.attribute3)   = upper('IT')
    AND TRUNC (SYSDATE) BETWEEN NVL(start_date, TRUNC (SYSDATE)) AND NVL( end_date , TRUNC (SYSDATE));

  -- Cursor to fetch transaction type
  CURSOR Cur_Get_Trans_Type (P_Major_Head IN VARCHAR2 ,p_transaction_type IN VARCHAR2 ,p_schedule_type IN VARCHAR2 )
  IS
    SELECT name,
      cust_trx_type_id
    FROM ra_cust_trx_types_all rctt
    WHERE upper(rctt.attribute1) = upper(p_major_head)
    AND upper(rctt.attribute2)   = upper(p_transaction_type)
    AND upper(rctt.attribute3)   = upper(p_schedule_type)
    AND TRUNC (SYSDATE) BETWEEN NVL(rctt.start_date, TRUNC (SYSDATE))AND NVL( rctt.end_date, TRUNC (SYSDATE)) ;
  l_stmt_processing VARCHAR2(200);
  -- Variables for Refd Wait List API
  l_num_xx_computed    NUMBER := NULL;
  l_num_refd_approved NUMBER := NULL;
  l_num_claim_amt       NUMBER := NULL;
  l_rec_memo_details cur_get_Memo_details%ROWTYPE;
  l_rec_trans_type cur_get_trans_type%ROWTYPE;
  -- Variable Required for Invoice API call
  l_batch_source_rec ar_invoice_api_pub.batch_source_rec_type;
  l_trx_header_tbl ar_invoice_api_pub.trx_header_tbl_type;
  l_trx_lines_tbl ar_invoice_api_pub.trx_line_tbl_type;
  l_trx_dist_tbl ar_invoice_api_pub.trx_dist_tbl_type;
  l_trx_salescredits_tbl ar_invoice_api_pub.trx_salescredits_tbl_type;
  l_batch_id         INTEGER;
  l_cnt              INTEGER;
  l_count            NUMBER := 0;
  l_line_count       NUMBER := 0;
  l_trx_id           NUMBER ;
  l_trx_line_id      NUMBER ;
  x_customer_trx_id  NUMBER ;
  x_msg_count        NUMBER ;
  l_id_number       VARCHAR2(20) :='';
  l_assmt_year       VARCHAR2(4)  :='';
  x_return_status    VARCHAR2 (100);
  x_msg_data         VARCHAR2 (2000);
  l_err_msg          VARCHAR2 (5000);
  l_rec_status       VARCHAR2(200)  :='';
  l_chr_proc_name    VARCHAR2(150)  :='';
  l_chr_exe_location VARCHAR2(150)  :='';
  l_chr_errbuff      VARCHAR2(3000) := '';
  l_chr_retcode      VARCHAR2(20)   := '';
  custom_exception   EXCEPTION;
  x_form_type_code     NUMBER; --added for CR_HW_224 on 20-03-14
  X_LINE_AMOUNT      NUMBER; --added for CR_HW_224 on 20-03-14
  x_tot_line_amount  NUMBER; --added for CR_HW_224 on 25-04-14
v_cust_trx_id		number;
  -- Cursor to derive Memo Line and Transaction for IRT
  CURSOR cur_inv_stg_staus (p_irt_id IN VARCHAR2)
  IS
    SELECT *
    FROM apps.xx_ar_trans_stg
    WHERE TRANSACTION_NUMBER = P_IRT_ID
    AND status_code          = 'NEW';
  -- Cursor to Check error records within IRT
  CURSOR cur_irt_stg_staus (p_irt_id IN VARCHAR2)
  IS
    SELECT COUNT('X')
    FROM apps.xx_ar_trans_stg
    WHERE TRANSACTION_NUMBER = P_IRT_ID
    AND status_code          = 'ERROR';
  -- Cursor to Create Different Invoices
  -- based on grouping rule logic for an IRT
  CURSOR cur_grp_inv_stg (p_irt_id IN VARCHAR2)
  IS
    SELECT DISTINCT transaction_number ,
      dr_interface_line_context ,
      major_head
      -- , minor_head
      ,
      irt_schedule_type
    FROM apps.xx_ar_trans_stg
    WHERE transaction_number = p_irt_id ;
  -- Cursor to fetch details of Invoice lines based on grouping rule
  CURSOR cur_inv_dtl_stg (p_irt_id IN VARCHAR2 ,p_context IN VARCHAR2 , p_major_head IN VARCHAR2
    -- ,p_minor_head IN VARCHAR2
    ,p_irt_schd_type IN VARCHAR2 )
  IS
    SELECT *
    FROM apps.xx_ar_trans_stg
    WHERE transaction_number      = p_irt_id
    AND dr_interface_line_context = p_context
    AND major_head                = p_major_head
      --AND minor_head = p_minor_head
    AND irt_schedule_type = p_irt_schd_type;
  -- Cursor to fetch different Invoice Id created for a batch
  CURSOR cur_batch ( p_batch_id IN NUMBER)
  IS
    SELECT customer_trx_id FROM ra_customer_trx_all WHERE batch_id = p_batch_id;
  -- Cursor to fetch Errors encountered for Invoice Id created for a batch
  CURSOR Cur_list_errors
  IS
    SELECT trx_header_id ,
      trx_line_id ,
      trx_salescredit_id ,
      trx_dist_id ,
      trx_contingency_id ,
      error_message ,
      invalid_value
    FROM ar_trx_errors_gt;
BEGIN
  l_chr_proc_name    := 'validate_create_invoice ';
  p_out_chr_retcode  := g_chr_success_code;
  p_out_chr_errbuff  := '';
  l_chr_exe_location := 'VCI_0001';
  write_debug( g_debug_flag , 'Entering Procedure ' || l_chr_proc_name );
  dbms_output.put_line ('Start of Validate_create_invoice procedure');
  l_stmt_processing := ' Calling the Refd White List API to get xx, refd and claim amt';
  l_rec_status      := NULL;
  -- The below loop would call the refd waitlistAPI and get the amount for
  -- IRT
  FOR l_rec_updt_claims IN
  (SELECT transaction_number ,
    assessment_year ,
    bill_to_customer_number ,
    irt_schedule_type
  FROM xx_ar_trans_stg
  WHERE status_code      = 'NEW'
  AND transaction_number = p_in_irt_id
  )
  LOOP
    l_chr_exe_location := 'VCI_0002';
    l_stmt_processing  := 'Before calling Whitelisting API';
--	dbms_output.put_line('Before calling Whitelisting API');
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  --  REFDWHITELISTINGAPI (v_irt_id => l_rec_updt_claims.transaction_number, v_assment_year => l_rec_updt_claims.assessment_year, v_id_cd => l_rec_updt_claims.bill_to_customer_number, v_schedule_type => l_rec_updt_claims.irt_schedule_type, v_xx_liability_computed => l_num_xx_computed, v_refd_amount_as_approved => l_num_refd_approved, v_matched_claims_amount => l_num_claim_amt);
  -- dbms_output.put_line('After calling Whitelisting API');
    write_debug( g_debug_flag ,'After calling Whitelisting API');
    write_debug( g_debug_flag ,'l_num_xx_computed' || l_num_xx_computed);
    write_debug( g_debug_flag ,'l_num_refd_approved' || l_num_refd_approved );
    write_debug( g_debug_flag ,'l_num_claim_amt' || l_num_claim_amt);
    l_chr_exe_location := 'VCI_0003';
    -- The IF condition would not be successful as NVL condition would make it
    -- 0 always
    IF ((NVL(l_num_xx_computed,0) IS NULL) OR ( NVL(l_num_refd_approved,0) IS NULL ) OR ( NVL(l_num_claim_amt,0) IS NULL ) ) THEN
      l_chr_exe_location           := 'VCI_0004';
      l_stmt_processing            := ' Updating the status to error if any of the amt is NULL';
      l_rec_status                 := 'Updating the status to error if any of the amt is NULL' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      UPDATE xx_AR_TRANS_STG xats
      SET status_code = 'ERROR' ,
        error_message = error_message
        || ' , '
        || 'FAS IRT STG HOLD'
      WHERE status_code           = 'NEW'
      AND transaction_number      = l_rec_updt_claims.transaction_number
      AND bill_to_customer_number = l_rec_updt_claims.bill_to_customer_number
      AND assessment_year         = l_rec_updt_claims.assessment_year;
    ELSE -- IF ((NVL(l_num_xx_computed,0) IS NULL) OR
      l_chr_exe_location := 'VCI_0005';
      l_stmt_processing  := ' Updating the amt received from the Waitlist API';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	  	dbms_output.put_line('Updating the xx computed and other amounts. '||l_num_xx_computed||' claim amount: '||l_num_claim_amt||' Refd amount: '||l_num_refd_approved);
      UPDATE xx_AR_TRANS_STG xats
      SET xx_computed            = l_num_xx_computed,
        matched_claims_amt        = l_num_claim_amt,
        refd_computed_amt       = l_num_refd_approved
      WHERE status_code           = 'NEW'
      AND transaction_number      = l_rec_updt_claims.transaction_number
      AND bill_to_customer_number = l_rec_updt_claims.bill_to_customer_number
      AND assessment_year         = l_rec_updt_claims.assessment_year
      AND irt_schedule_type       = l_rec_updt_claims.irt_schedule_type;
    END IF; -- IF ((NVL(l_num_xx_computed,0) IS NULL) OR
  END LOOP; -- FOR l_rec_updt_claims IN (SELECT transaction_number
  FOR irt_info_rec IN cur_inv_stg_staus(p_in_irt_id)
  LOOP
    l_id_number       := irt_info_rec.bill_to_customer_number;
    l_assmt_year       := irt_info_rec.assessment_year;
    l_chr_exe_location := 'VCI_0006';
    l_stmt_processing  := ' Getting Memo Line Id for the IRT and Transaction Type ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- Getting the Memo id
    OPEN Cur_Get_Memo_Details ( Irt_Info_Rec.Major_Head , Irt_Info_Rec.Minor_Head , irt_info_rec.irt_schedule_type );
    FETCH cur_get_Memo_details INTO l_rec_memo_details;
    CLOSE cur_get_Memo_details;
    l_chr_exe_location := 'VCI_0007';
    -- Getting the transaction type id
    OPEN cur_get_trans_type ( Irt_Info_Rec.Major_Head , Irt_Info_Rec.transaction_type , irt_info_rec.irt_schedule_type );
    FETCH cur_get_trans_type INTO l_rec_trans_type;
    CLOSE cur_get_trans_type;
    l_chr_exe_location := 'VCI_0008';
    l_stmt_processing  := ' Checking if both Memo Id and transaction Types are error';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- Checking if both Memo Id and transaction Types are error
    IF l_rec_memo_details.memo_line_id IS NULL AND l_rec_trans_type.cust_trx_type_id IS NULL THEN
      l_rec_status                     := ' Updating status to Error for Memo line , Unable to derive description transaction type ' ;
      L_CHR_EXE_LOCATION               := 'VCI_0009';
      l_stmt_processing                := ' Updating status to Error for Memo line , Unable to derive description transaction type ' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      UPDATE xx_AR_TRANS_STG xats
      SET STATUS_CODE = 'ERROR' ,
        error_message = error_message
        || ' , '
        || 'Memo ID not found and customer transaction type not found '
      WHERE -- status_code = 'NEW' AND
        xats.transaction_number            = p_in_irt_id
      AND xats.major_head                  = Irt_Info_Rec.Major_Head
      AND xats.minor_head                  = Irt_Info_Rec.Minor_Head
      AND xats.irt_schedule_type           = irt_info_rec.irt_schedule_type
      AND xats.transaction_type            = Irt_Info_Rec.transaction_type ;
    ELSIF l_rec_memo_details.memo_line_id IS NULL OR l_rec_trans_type.cust_trx_type_id IS NULL THEN
      l_rec_status                        := ' Updating status to Error for Memo or transaction type issue';
      l_chr_exe_location                  := 'VCI_0010';
      l_stmt_processing                   := ' Updating status to Error for Memo or transaction type issue';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      UPDATE xx_AR_TRANS_STG xats
      SET status_code = 'ERROR' ,
        error_message = error_message
        || ' , '
        || DECODE(NVL(l_rec_memo_details.memo_line_id,   -1),-1, ' Memo ID not found ','')
        || DECODE(NVL(l_rec_trans_type.cust_trx_type_id ,-1),-1, ' Customer transaction type not found ','')
      WHERE -- status_code = 'NEW' AND
        transaction_number       = p_in_irt_id
      AND xats.major_head        = Irt_Info_Rec.Major_Head
      AND xats.minor_head        = Irt_Info_Rec.Minor_Head
      AND xats.irt_schedule_type = irt_info_rec.irt_schedule_type
      AND xats.transaction_type  = Irt_Info_Rec.transaction_type ;
    END IF; -- IF l_rec_memo_details.memo_line_id IS NULL
    l_chr_exe_location := 'VCI_0011';
    l_stmt_processing  := ' Udpdating Derived value of Memo id and transaction Type id ';
	dbms_output.put_line('Udpdating Derived value of Memo id and transaction Type id');
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- Udpdating Derived value of Memo id and transaction Type id
    UPDATE xx_ar_trans_stg xatg
    SET dr_memo_line_id        = l_rec_memo_details.memo_line_id ,
      dr_memo_description      = l_rec_memo_details.description ,
      dr_set_of_books_id       = l_rec_memo_details.set_of_books_id ,
      dr_cust_trx_type_name    = l_rec_trans_type.name ,
      dr_cust_trx_type_id      = l_rec_trans_type.cust_trx_type_id
    WHERE transaction_number   = p_in_irt_id
    AND xatg.major_head        = Irt_Info_Rec.Major_Head
    AND xatg.minor_head        = irt_info_rec.minor_head
    AND xatg.irt_schedule_type = irt_info_rec.irt_schedule_type
    AND xatg.transaction_type  = Irt_Info_Rec.transaction_type
    AND xatg.status_code       = 'NEW' ;
    l_chr_exe_location        := 'VCI_0012';
    l_stmt_processing         := ' Check if all the lines of IRT is NEW';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- Call API for Invoice Creation only if all the lines of IRT is NEW
  END LOOP ;
  IF L_REC_STATUS      IS NOT NULL THEN
    L_CHR_EXE_LOCATION := 'VCI_0013';
    l_stmt_processing  := ' Found one / more lines for IRT with ERROR ';
    INSERT
    INTO xx_irt_acct_error_log
      (
        irt_id ,
        cust_trx_id ,
        refd_ref_id ,
        error_program ,
        error_code ,
        error_details ,
        request_id ,
        request_date ,
        created_by ,
        creation_date
      )
      VALUES
      (
        p_in_irt_id ,
        NULL ,
        NULL ,
        L_CHR_PROC_NAME ,
        '100' ,
        l_stmt_processing ,
        p_in_request_id ,
        SYSDATE ,
        G_NUM_LOGIN_ID ,
        SYSDATE
      );
    write_debug ( g_debug_flag ,p_out_chr_errbuff ) ;
  END IF;
  -- Checking if any records failed because memo line / transactio type Issue
  IF L_CHR_EXE_LOCATION = 'VCI_0013' THEN
    P_OUT_CHR_RETCODE  := G_CHR_FAILURE_CODE;
    p_out_chr_errbuff  := l_stmt_processing ;
    RETURN; -- break from loop any record within the IRT has an issue
  END IF;   --IF L_CHR_EXE_LOCATION = 'VCI_0013'
  l_count := 0;
  -- Check if any record within the IRT had error out if so stop processing the
  -- IRT
  OPEN cur_irt_stg_staus ( p_in_irt_id ) ;
  FETCH cur_irt_stg_staus INTO l_count ;
  CLOSE cur_irt_stg_staus;
  IF l_count            > 0 THEN
    L_CHR_EXE_LOCATION := 'VCI_013_A';
    P_OUT_CHR_RETCODE  := G_CHR_FAILURE_CODE;
    p_out_chr_errbuff  := 'One or More rec of the IRT failed, setting IRT status ERROR';
    RETURN;
  END IF; -- IF l_count > 0
  l_chr_exe_location := 'VCI_0014';
  l_stmt_processing  := ' Found All lines for IRT with status NEW ';
  l_trx_header_tbl.delete ;
  l_batch_source_rec := NULL;
  l_trx_lines_tbl.delete;
  l_trx_dist_tbl.delete ;
  l_trx_salescredits_tbl.delete ;
  l_count      := 1;
  l_line_count :=1;
  dbms_output.put_line('Start cursor cur_grp_inv_stg');
  -- Check the status of the record
  FOR l_rec_grp_inv IN cur_grp_inv_stg(p_in_irt_id)
  LOOP
    l_chr_exe_location := 'VCI_0015';
    l_stmt_processing  := ' Assigning Invoice Header data for IRT_ID '|| p_in_irt_id ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    write_debug( g_debug_flag ,' Invoice '|| l_count );
    -- Populate API variables to call the Invoice Creation
    SELECT ra_customer_trx_s.NEXTVAL
    INTO l_trx_id
    FROM DUAL;
    write_debug( g_debug_flag ,' Next Trx id '|| l_trx_id );
    FOR l_rec_inv_stg IN cur_inv_dtl_stg( p_irt_id => p_in_irt_id ,p_context => l_rec_grp_inv.dr_interface_line_context ,p_major_head => l_rec_grp_inv.major_head
    -- ,p_minor_head => l_rec_grp_inv.minor_head
    ,p_irt_schd_type => l_rec_grp_inv.irt_schedule_type )
    LOOP
      l_chr_exe_location                             := 'VCI_0016';
      l_stmt_processing                              := ' Assigining Invoice Line data for IRT_ID '|| p_in_irt_id ;
      l_batch_source_rec.batch_source_id             := l_rec_inv_stg.dr_batch_source_id;
      l_trx_header_tbl (l_count).trx_header_id       := l_trx_id;
      l_trx_header_tbl (l_count).trx_currency        := l_rec_inv_stg.dr_currency_code;
      l_trx_header_tbl (l_count).cust_trx_type_id    := l_rec_inv_stg.dr_cust_trx_type_id;
      l_trx_header_tbl (l_count).term_id             := l_rec_inv_stg.dr_term_id;
      l_trx_header_tbl (l_count).bill_to_customer_id := l_rec_inv_stg.dr_cust_account_id;
      l_trx_header_tbl (l_count).bill_to_address_id  := l_rec_inv_stg.dr_cust_acct_site_id;
      -- The following 2 columns can be used only when the currency is
      -- different from Functional Currency
      -- l_trx_header_tbl (l_count).exchange_rate_type :=
      -- l_rec_inv_stg.dr_conversion_type;
      -- l_trx_header_tbl (l_count).exchange_rate :=
      -- l_rec_inv_stg.dr_conversion_rate;
      l_trx_header_tbl (l_count).trx_date := NVL(l_rec_inv_stg.invoice_date, sysdate);
      --l_trx_header_tbl (l_count).gl_date  := SYSDATE; --Commented for Hotfix_199485 on 13-MAR-2019
      l_trx_header_tbl (l_count).gl_date := TO_CHAR( l_rec_inv_stg.irt_approval_date,'DD-MON-RRRR'); --Added for Hotfix_199485 on 13-MAR-2019
      l_trx_header_tbl (l_count).org_id  := l_rec_inv_stg.dr_org_id;
      --l_trx_header_tbl(l_count).interface_header_context :=
      -- l_rec_inv_stg.dr_interface_line_context;
      l_trx_header_tbl(l_count).interface_header_attribute1 := l_rec_inv_stg.transaction_number;
      l_trx_header_tbl(l_count).interface_header_attribute2 := l_rec_inv_stg.major_head;
      l_trx_header_tbl(l_count).interface_header_attribute3 := l_rec_inv_stg.minor_head;
      l_trx_header_tbl(l_count).interface_header_attribute4 := l_rec_inv_stg.irt_schedule_type;
      L_TRX_HEADER_TBL (L_COUNT).ATTRIBUTE1                 := L_REC_INV_STG.MAJOR_HEAD;
      l_trx_header_tbl (l_count).attribute3                 := TO_CHAR( l_rec_inv_stg.irt_approval_date,'DD-MON-RRRR');
      l_trx_header_tbl (l_count).attribute4                 := l_rec_inv_stg.assessment_year;
      l_trx_header_tbl (l_count).attribute5                 := l_rec_inv_stg.bill_to_customer_number;
      l_trx_header_tbl (l_count).attribute7                 := l_rec_inv_stg.irt_schedule_type;
      l_trx_header_tbl (l_count).attribute9                 := l_rec_inv_stg.attribute4;
      l_trx_header_tbl (l_count).attribute11                := l_rec_inv_stg.transaction_number;
      l_trx_header_tbl (l_count).attribute13                := TO_CHAR(l_rec_inv_stg.due_date, 'DD-MON-RRRR');
      l_trx_header_tbl (l_count).attribute14                := TO_CHAR( l_rec_inv_stg.orig_irt_return_date,'DD-MON-RRRR');
      l_trx_header_tbl (l_count).attribute15                := l_rec_inv_stg.days_delay_assesee;
      write_debug( g_debug_flag ,' l_rec_inv_stg.refd_computed_amt: ' ||l_rec_inv_stg.refd_computed_amt||'l_rec_inv_stg.irt_schedule_type: '||l_rec_inv_stg.irt_schedule_type);
      l_trx_header_tbl (l_count).global_attribute1 := l_rec_inv_stg.refd_computed_amt;
      write_debug( g_debug_flag ,' l_trx_header_tbl (l_count).global_attribute1:  ' || l_trx_header_tbl (l_count).global_attribute1 );
      l_trx_header_tbl (l_count).global_attribute2 := l_rec_inv_stg.matched_claims_amt;
      l_trx_header_tbl (l_count).global_attribute3 := l_rec_inv_stg.xx_computed ;
      write_debug( g_debug_flag ,' Line '|| l_line_count );
      l_chr_exe_location := 'VCI_0017';
      write_debug( g_debug_flag ,' Processing Invoice Line data ' || l_line_count ||' for IRT_ID '|| p_in_irt_id );
	  dbms_output.put_line('Processing Invoice Line data ' || l_line_count ||' for IRT_ID '|| p_in_irt_id );
      SELECT ra_customer_trx_lines_s.NEXTVAL INTO l_trx_line_id FROM DUAL;
      l_trx_lines_tbl (l_line_count).trx_header_id             := l_trx_id;
      l_trx_lines_tbl (l_line_count).trx_line_id               := l_trx_line_id;
      l_trx_lines_tbl (l_line_count).line_number               := l_line_count;
      l_trx_lines_tbl (l_line_count).interface_line_context    := l_rec_inv_stg.dr_interface_line_context;
      l_trx_lines_tbl (l_line_count).interface_line_attribute1 := l_rec_inv_stg.transaction_number;
      l_trx_lines_tbl (l_line_count).interface_line_attribute2 := l_rec_inv_stg.major_head;
      l_trx_lines_tbl (l_line_count).interface_line_attribute3 := l_rec_inv_stg.minor_head;
      l_trx_lines_tbl (l_line_count).interface_line_attribute4 := l_rec_inv_stg.irt_schedule_type;
      l_trx_lines_tbl (l_line_count).line_type                 := l_rec_inv_stg.dr_line_type;
      l_trx_lines_tbl (l_line_count).description               := l_rec_inv_stg.dr_memo_description;
      l_trx_lines_tbl (l_line_count).quantity_invoiced         := l_rec_inv_stg.quantity;
      l_trx_lines_tbl (l_line_count).unit_selling_price        := l_rec_inv_stg.line_amount;
      l_trx_lines_tbl (l_line_count).uom_code                  := l_rec_inv_stg.dr_uom_code;
      l_trx_lines_tbl (l_line_count).amount_includes_xx_flag  := l_rec_inv_stg.amount_includes_xx_flag;
      l_trx_lines_tbl (l_line_count).memo_line_id              := l_rec_inv_stg.dr_memo_line_id;
      l_trx_lines_tbl (l_line_count).amount                    := l_rec_inv_stg.line_amount;
      l_trx_lines_tbl (l_line_count).attribute3                := l_rec_inv_stg.attribute3; --
      -- added for CR_HWSW_224 on 19-03-14
      l_trx_lines_tbl (l_line_count).attribute4 := l_rec_inv_stg.attribute5; --
      -- added for CR_HWSW_224 on 19-03-14
      l_trx_lines_tbl (l_line_count).attribute5 := l_rec_inv_stg.ATTRIBUTE1; --
      -- added for CR_HWSW_224 on 19-03-14
      l_line_count := l_line_count +1;
    END LOOP; -- FOR l_rec_inv_stg IN cur_inv_dtl_stg( p_irt_id => p_in_irt_id
    l_count := l_count +1;
  END LOOP; -- FOR l_rec_grp_inv IN cur_grp_inv_stg(p_in_irt_id)

  l_stmt_processing  := ' Calling API to process IRT_ID '|| p_in_irt_id ;
  dbms_output.put_line('Calling API to process IRT_ID '|| p_in_irt_id );
  l_chr_exe_location := 'VCI_0018';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- call the invoice API only when all the invoice for the IRT are
   AR_INVOICE_API_PUB.CREATE_INVOICE (p_api_version => 1.0,
									  p_init_msg_list => FND_API.G_TRUE, 
									  p_commit => FND_API.G_FALSE, 
									  p_batch_source_rec => l_batch_source_rec,
									  p_trx_header_tbl => l_trx_header_tbl, 
									  p_trx_lines_tbl => l_trx_lines_tbl, 
									  p_trx_dist_tbl => l_trx_dist_tbl, 
									  p_trx_salescredits_tbl => l_trx_salescredits_tbl,
									  x_return_status => x_return_status, 
									  x_msg_count => x_msg_count,
									  x_msg_data => x_msg_data );
  write_debug( g_debug_flag , 'Invoice status ' || x_return_status || ' Msg cnt ' || x_msg_count);
  dbms_output.put_line('Invoice status ' || x_return_status || ' Msg cnt ' || x_msg_count|| ' Message data '||x_msg_data );
  -- l. check for errors
  l_chr_exe_location   := 'VCI_0019';
  l_err_msg            := NULL;
  IF x_return_status    = fnd_api.g_ret_sts_error OR x_return_status = fnd_api.g_ret_sts_unexp_error THEN
    l_chr_exe_location := 'VCI_0020';
    l_stmt_processing  := ' API Call Failure for IRT_ID ' ;
    write_msg( g_write_logfile ,'FAILURE: Unexpected errors were raised! ' || l_chr_exe_location ||'-'|| l_stmt_processing ||'-' || x_msg_data);
	dbms_output.put_line('FAILURE: Unexpected errors were raised! ' || l_chr_exe_location ||'-'|| l_stmt_processing ||'-' || x_msg_data);
				IF x_msg_count > 1 THEN
				  FOR i IN 1 .. x_msg_count
				  LOOP
					l_err_msg := l_err_msg || ' - ' || i|| '. '|| SUBSTR (fnd_msg_pub.get ( p_encoded=> fnd_api.g_false),1,355);
				  END LOOP; -- FOR i IN 1 .. x_msg_count
				ELSE
				  L_ERR_MSG := L_ERR_MSG || ' - ' ||SUBSTR (fnd_msg_pub.get (p_encoded=> fnd_api.g_false),1,355) || '- ' || x_msg_data;
				END IF; -- IF x_msg_count > 1
    write_msg( g_write_logfile ,l_err_msg );
    P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
    p_out_chr_errbuff := l_chr_exe_location ||'-' || l_stmt_processing||'-'|| l_err_msg;
    WRITE_MSG( G_WRITE_LOGFILE ,P_OUT_CHR_ERRBUFF);
    RAISE custom_exception;
  ELSE -- IF x_return_status = fnd_api.g_ret_sts_error OR
    -- m. check batch/invoices created

	dbms_output.put_line('VCI_0021 ');
    l_chr_exe_location := 'VCI_0021';
	BEGIN
    SELECT DISTINCT batch_id INTO l_batch_id FROM ar_trx_header_gt;
	dbms_output.put_line('l_batch_id '||l_batch_id);
	EXCEPTION
	when no_data_found then 
	dbms_output.put_line('no data found for batch id '||l_batch_id||' in ar_trx_header_gt');
	END;
    IF l_batch_id IS NOT NULL THEN
      write_debug( g_debug_flag , 'SUCCESS: Created batch_id = ' || l_batch_id || ' containing the following customer_trx_id:');
      FOR c IN cur_Batch (l_batch_id)
      LOOP
        write_msg( g_write_logfile ,' ' || c.customer_trx_id );
		dbms_output.put_line('customer_trx_id '||c.customer_trx_id);
      END LOOP; -- FOR c IN cBatch
    END IF;     -- IF l_batch_id IS NOT NULL THEN
    --below code added for CR_HW_224 on 20-03-14
    BEGIN
      SELECT "form_type_code"
      INTO x_form_type_code
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE "irt_id"=p_in_irt_id;
      --start of : interchanging the below query for intimation issue
      -- CR_HW_0224
      SELECT NVL(SUM(line_amount),0)   ---added - Bhagya
      INTO x_tot_line_amount
      FROM xx_ar_trans_stg
      WHERE TRANSACTION_NUMBER = P_IN_IRT_ID
      AND ( MINOR_HEAD LIKE '%234B%'
      OR MINOR_HEAD LIKE '%234A%'
      OR MINOR_HEAD LIKE '%234C%'
      OR MINOR_HEAD LIKE '%234F%'); --Added for Hotfix_182167 on 21-JUN-2018
      --end of : interchanging the query for intimation issue CR_HW_0224
	  dbms_output.put_line('x_tot_line_amount '||x_tot_line_amount);
	  begin
      SELECT line_amount
      INTO x_line_amount
      FROM xx_ar_trans_stg
      WHERE transaction_number = p_in_irt_id
      AND minor_head          IN ('Rev Interest 234B','Interest 234B', 'Rec Interest 234B');
	 Exception When no_data_found
	   then
	   x_line_amount:=0;
	  dbms_output.put_line('x_line_amount '||x_line_amount);
	  End;
      --AND minor_head LIKE '%234B%'; for tuning the query ,we removed the line
      -- on 04-july-2014
      /*
      --below code added for CR_HW_224 on 25-04-14
      select sum(line_amount)
      into x_tot_line_amount
      from xx_ar_trans_stg
      where TRANSACTION_NUMBER = P_IN_IRT_ID
      and (MINOR_HEAD like '%234B%' or MINOR_HEAD like '%234A%' or MINOR_HEAD
      like '%234C%');
      */
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      x_line_amount:= 0;
    WHEN OTHERS THEN
      RAISE CUSTOM_EXCEPTION;
    END;

    IF x_form_type_code=1 THEN

	 dbms_output.put_line(' x_form_type_code=1 ');


     /* UPDATE "process_store"."irt_irt1_xx_liab_prcssd"@psql_process_fas
      SET "tc_int_sec234b_amt"=NVL(X_LINE_AMOUNT,0),
       "tc_xx_int_pay_tot_amt" ="tc_bal_xx_pay_amt"+NVL(x_tot_line_amount,0),
	   "tc_int_pay_tot_amt"=NVL(x_tot_line_amount,0) --defect 4349 30
       WHERE "irt_id"                  =p_in_irt_id;
	*/
	/*Begin
	   xx_ABC_UPDATE_ACCT_PRC( p_in_irt_id ,
					X_LINE_AMOUNT  ,
					x_tot_line_amount   
					  );
	EXCEPTION
	when others then
	dbms_output.put_line('Error updating irt_irt1_xx_liab_prcssd in postgres'||SQLERRM);
	END;
*/
    ELSE
	Begin
      UPDATE IRT_STDCMP.irt_xx_lia_tot_incm_prcssd  -- NEED TO CHANGE it to postgres- Bhagya
      SET ctl_int_sec234b_periodic_amt=NVL(x_line_amount,0),
        --ctl_int_pay_tot_amt=nvl(x_tot_line_amount,0), --code added for
        -- CR_HW_224 on 25-04-14
        --ctl_agg_liab_amt= ctl_net_xx_liab_amt+ nvl(x_tot_line_amount,0) --
        -- defect #4349 29-04-14
        CTL_INT_PAY_PRINCIPAL_TOT_AMT=NVL(x_tot_line_amount,0), --defect 4349
        -- 30-04-14(CR 224)
        CTL_AGG_LIAB_PRINCIPAL_AMT = CTL_NET_XX_LIAB_AMT+ NVL( x_tot_line_amount,0) --defect 4349 30-04-14(CR 224)
      WHERE irt_id                 =p_in_irt_id;
	  EXCEPTION when no_data_found
	  then
	  dbms_output.put_line('No data found in IRT_STDCMP.irt_xx_lia_tot_incm_prcssd for this IRT');	 
	  END;
    END IF;
    --till here for CR_HW_224
  END IF; -- IF x_return_status = fnd_api.g_ret_sts_error OR
  -- n. Within the batch, check if some invoices raised errors
  SELECT COUNT(*)
  INTO l_cnt
  FROM ar_trx_errors_gt;
   dbms_output.put_line('ar_trx_errors_gt errors count '||l_cnt);
  IF l_cnt > 0 THEN
    write_msg( g_write_logfile ,'FAILURE: Errors encountered, see list below:') ;

    l_err_msg := NULL;
    write_msg( g_write_logfile ,' In ' || l_chr_proc_name);
    FOR i IN cur_list_errors
    LOOP
      write_msg( g_write_logfile , '----------------------------------------------------');
      write_msg( g_write_logfile ,'Header ID = ' || TO_CHAR(i.trx_header_id));
      write_msg( g_write_logfile ,'Line ID = ' || TO_CHAR(i.trx_line_id));
      write_msg( g_write_logfile ,'Sales Credit ID = ' || TO_CHAR( i.trx_salescredit_id));
      write_msg( g_write_logfile ,'Dist Id = ' || TO_CHAR(i.trx_dist_id));
      write_msg( g_write_logfile ,'Contingency ID = ' || TO_CHAR( i.trx_contingency_id));
      write_msg( g_write_logfile ,'Message = ' || SUBSTR(i.error_message,1,80)) ;
      l_err_msg := l_err_msg || ' Header ID = ' || TO_CHAR(i.trx_header_id) || ' - ' || SUBSTR(i.error_message,1,80);
      write_msg( g_write_logfile ,'Invalid Value = ' || SUBSTR(i.invalid_value, 1,80));
      write_msg( g_write_logfile , '----------------------------------------------------');
	   dbms_output.put_line('----------------------------------------------------');
      dbms_output.put_line('Header ID = ' || TO_CHAR(i.trx_header_id));
      dbms_output.put_line('Line ID = ' || TO_CHAR(i.trx_line_id));
       dbms_output.put_line('Sales Credit ID = ' || TO_CHAR( i.trx_salescredit_id));
       dbms_output.put_line('Dist Id = ' || TO_CHAR(i.trx_dist_id));
       dbms_output.put_line('Contingency ID = ' || TO_CHAR( i.trx_contingency_id));
       dbms_output.put_line('Message = ' || SUBSTR(i.error_message,1,80)) ;      
       dbms_output.put_line( 'Invalid Value = ' || SUBSTR(i.invalid_value, 1,80));
       dbms_output.put_line('----------------------------------------------------');
    END LOOP; --FOR i in list_errors
    write_debug( g_debug_flag ,p_out_chr_errbuff);
    P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
    p_out_chr_errbuff := l_chr_exe_location ||'-' || l_stmt_processing ||'-'|| l_err_msg;
    RAISE custom_exception;
    RETURN;
  END IF; --IF l_cnt > 0 THEN
  l_chr_exe_location := 'VCI_0022';
  l_stmt_processing  := ' Updating the attribute of Invoice which has attribute 9 RR Ref Dem' ;
  dbms_output.put_line(' Updating the attribute of Invoice which has attribute 9 RR Ref Dem');

  UPDATE ar.ra_customer_trx_all rcta
  SET
    (
      rcta.attribute11,
      rcta.attribute3,
      rcta.attribute13,
      rcta.attribute14,
      rcta.attribute15
    )
    =
    ( SELECT DISTINCT xats.transaction_number,
      TO_CHAR(irt_approval_date,'DD-MON-RRRR'),
      TO_CHAR(due_date,'DD-MON-RRRR'),
      TO_CHAR(orig_irt_return_date,'DD-MON-RRRR'),
      days_delay_assesee
    FROM xx_ar_trans_stg xats
    WHERE xats.bill_to_customer_number = rcta.attribute5
    AND xats.assessment_year           = rcta.attribute4
    AND UPPER (xats.transaction_type) IN ('REVISED', 'RECTIFICATION')
    AND xats.status_code               = 'NEW'
    AND xats.request_id                = p_in_request_id
    )
  WHERE rcta.attribute9 = 'RR REF DEM' --refd converted to dem
    -- AND rcta.attribute11 = p_in_irt_id
  AND rcta.attribute5 = l_id_number
  AND rcta.attribute4 = l_assmt_year
  AND EXISTS
    (SELECT 1
    FROM xx_ar_trans_stg xats
    WHERE xats.bill_to_customer_number = rcta.attribute5
    AND xats.assessment_year           = rcta.attribute4
    AND UPPER (xats.transaction_type) IN ('REVISED', 'RECTIFICATION')
    AND xats.status_code               = 'NEW'
    );
  UPDATE ar.ra_customer_trx_all rcta
  SET rcta.interface_header_context =
    ( SELECT DISTINCT dr_interface_line_context
    FROM xx_ar_trans_stg xats
    WHERE xats.major_head            = rcta.attribute1
    AND xats.assessment_year         = rcta.attribute4
    AND xats.bill_to_customer_number = rcta.attribute5
    AND xats.irt_schedule_type       = rcta.attribute7
    AND xats.transaction_number      = rcta.attribute11
    AND xats.minor_head              = rcta.interface_header_attribute3
    AND xats.dr_cust_trx_type_id     = rcta.cust_trx_type_id
    AND xats.status_code             = 'NEW'
    AND xats.request_id              = p_in_request_id
    ) ,
    interface_header_attribute1 = attribute11 ,
    interface_header_attribute4 = interface_header_attribute4
    ||'-'
    || rownum
  WHERE rcta.attribute11 = p_in_irt_id ;
  write_debug( g_debug_flag , 'Moving out from Procedure ' || l_chr_proc_name ) ;
   dbms_output.put_line('Moving out from Procedure '||SQL%rowcount);

EXCEPTION
WHEN CUSTOM_EXCEPTION THEN

 dbms_output.put_line(' CUSTOM_EXCEPTION :'||g_chr_failure_code);
  p_out_chr_retcode := g_chr_failure_code;
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => p_in_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    END IF;
  END IF;
WHEN OTHERS THEN

dbms_output.put_line(' Unexpected Error in procedure :'||g_chr_failure_code);

  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name || '-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || SUBSTR(sqlerrm, 1,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name || '-' ||l_chr_errbuff );
    END IF;
  END IF;
  dbms_output.put_line(' exit procedure Validate_Create_Invoice :'||g_chr_failure_code);
END Validate_Create_Invoice;
-- ***************** End of Function / Procedure **********************--
PROCEDURE inv_apply(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_irt_id IN VARCHAR2 )
AS
  /****************************************************************************
  ****************************************
  * Type : Procedure
  * Name : INV_APPLY
  * Input Parameters : p_in_irt_id
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : Procedure to apply invoice to receipts
  *****************************************************************************
  *************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details *
  * ------------- ------------ -------- --------------- --------------
  *****************************************************************************
  **************************************/
  l_num_tot_apply_amt     NUMBER := 0;
  l_inv_amount            NUMBER;
  l_recpt_amount          NUMBER;
  l_num_claim_amt         NUMBER;
  l_num_claim_amt_ts     NUMBER := NULL; -- Added for CR - 661
  l_num_claim_amt_ch NUMBER := NULL; -- Added for CR - 661
  l_apply_amount          NUMBER;
  l_ins_chk               NUMBER;
  l_msg_count             NUMBER;
  l_return_status         VARCHAR2 (1);
  l_msg_data              VARCHAR2 (5000);
  l_receipt_avl_flg       CHAR := 'N';
  -- l_exc_exit_error_proc EXCEPTION;
  -- l_exc_exit_warn_proc EXCEPTION;
  l_chr_proc_name    VARCHAR2(50) :='inv_apply';
  l_chr_exe_location VARCHAR2(50) :='';
  l_stmt_processing  VARCHAR2(200);
  l_chr_errbuff      VARCHAR2 (5000);
  l_chr_retcode      VARCHAR2 (10);
  custom_exception   EXCEPTION;
  remaining_amt      NUMBER:=0;
  v_remaining_amt    NUMBER;
  v_irt_sch_type     VARCHAR2(200);
  v_irt_id           VARCHAR2(200);
  v_glob2            VARCHAR2(200);
  v_att9             VARCHAR2(400);
  v_arp_status       VARCHAR2(400);
  v_cust_trx_id      NUMBER;
  v_true             NUMBER;
  V_cust     number;
  --Cursor Declaration
  --
  CURSOR cur_inv (p_irt_id VARCHAR2)
  IS
    SELECT rat.customer_trx_id ,
      rat.trx_number ,
      rat.bill_to_customer_id ,
      rat.attribute4 assmt_year ,
      rat.attribute5 customer_number ,
      rat.attribute2 bank_account ,
      rat.attribute3 irt_approval_date ,
      ABS (arp.amount_due_remaining) amount_due_remaining ,
      rat.attribute1 major_head ,
      rat.attribute9 status ,
      rat.attribute7 schedule_type ,
      rat.attribute11 irt_id ,
      rat.attribute10 dmd_serv_date ,
      arp.payment_schedule_id ,
      arp.amount_due_original ,
      rat.global_attribute2
    FROM ra_customer_trx_all rat ,
      ar_payment_schedules_all arp
    WHERE rat.customer_trx_id           = arp.customer_trx_id
    AND rat.interface_header_attribute1 = p_irt_id
    AND rat.attribute9                  = 'NEW'
    AND arp.status                      = 'OP'
    AND rat.attribute4                 IS NOT NULL
    AND rat.attribute5                 IS NOT NULL
    AND rat.attribute1                 IS NOT NULL
    AND arp.amount_due_remaining       <> 0
    ORDER BY TO_NUMBER (rat.attribute4),
      TO_NUMBER (rat.attribute1) ASC,
      rat.attribute7 DESC; --added for CR_661 on 31-Jan-2019
TYPE l_cur_inv_table
IS
  TABLE OF cur_inv%ROWTYPE;
  cur_inv_rec l_cur_inv_table;
  CURSOR cur_recpt ( in_num_customer VARCHAR2, in_num_assmt_year VARCHAR2, in_num_major_head VARCHAR2, in_num_minor_head1 VARCHAR2, in_num_minor_head2 VARCHAR2, in_num_minor_head3 VARCHAR2, in_num_minor_head4 VARCHAR2,in_num_minor_head5 VARCHAR2,in_num_minor_head6 VARCHAR2,in_num_minor_head7 VARCHAR2,in_num_minor_head8 VARCHAR2, in_chr_irt_id VARCHAR2, in_irt_schedule_type VARCHAR -- Added  in_num_minor_head5 as part of CR#0653 ----Added in_num_minor_head8 for Minor Head 'OTH' as part of  CR#0613(5A-SPI)-Phase2, Added  for CR - 661
    -- in 3.1.1
    )
  IS
    SELECT arc.cash_receipt_id ,
      arc.receipt_number ,
      arc.receipt_date ,
      arc.attribute4 assmt_year ,
      arc.attribute2 minor_head ,
      TO_NUMBER (arc.global_attribute10) claim_amount
    FROM ar_cash_receipts_all arc
    WHERE arc.attribute5                   = in_num_customer
    AND ( ( TO_NUMBER (arc.attribute4)     = TO_NUMBER (in_num_assmt_year)
    AND arc.attribute15                   IN ('MATCHED', 'PARTIALLY MATCHED','SPI PARTIALLY MATCHED') ) --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
    OR ( arc.global_attribute4             = 'TS'
    AND TO_NUMBER (arc.attribute4)         < TO_NUMBER (in_num_assmt_year)
    AND arc.attribute15 NOT               IN ('CLAIMED', 'REFD IN PROCESS')
    AND arc.attribute2                     = in_num_minor_head2
    AND in_num_minor_head2                IS NOT NULL ) )
    AND arc.attribute1                     = in_num_major_head
    AND arc.attribute12                    = in_chr_irt_id
    AND arc.status                         = 'UNAPP'
    AND TO_NUMBER (arc.global_attribute10) > 0
    AND arc.attribute2                    IN (in_num_minor_head1 , in_num_minor_head2 , in_num_minor_head3 , in_num_minor_head4, in_num_minor_head5,in_num_minor_head6,in_num_minor_head7,in_num_minor_head8) -- Added  in_num_minor_head5 as part of CR#0653, Add minor head 8 27-NOV-18  --Added in_num_minor_head8 for Minor Head 'OTH' as part of  CR#0613(5A-SPI)-Phase2
    /*AND EXISTS
      (SELECT 1
      FROM "efile"."irt_xx_matched"@psql_process_fas
      WHERE "irt_id"                                          = to_number (arc.attribute12)
      AND "matched_amt"                                       > 0
      AND DECODE("xx_type_val", 'DDTP', 'DDT', "xx_type_val") = in_irt_schedule_type
      )*/ -- Added for CR- 661
--commented irt_xx_matched in ABC-2.0 - Bhagya
  ORDER BY arc.receipt_date,
    arc.cash_receipt_id ,
    arc.attribute2 ASC;
TYPE l_cur_recpt_table
IS
  TABLE OF cur_recpt%ROWTYPE;
  cur_recpt_rec l_cur_recpt_table;
  cur_recpt_rec1 l_cur_recpt_table;
  V_l_num_claim_amt ar_cash_receipts_all.GLOBAL_ATTRIBUTE10%type;------Added
  -- for hot Fix #81169
  V_L_Global_Attribute2 Ra_Customer_Trx_All.Global_Attribute2%type; --
BEGIN                                                               -- main
  -- program
  dbms_output.put_line('Start of inv_apply procedure');
  p_out_chr_errbuff  := ' ';
  p_out_chr_retcode  := g_chr_success_code;
  l_chr_exe_location := 'INVAPP_001';
  l_stmt_processing  := ' Entering Invoice Apply API ' ;
  write_debug( g_debug_flag , l_chr_exe_location || '-' || l_stmt_processing );
  write_debug( g_debug_flag, '-----------------------------------------------------------------------------------' );
  write_debug( g_debug_flag , '*** Apply Invoice to Receipts Program - STARTS ***');
  write_debug( g_debug_flag, '-----------------------------------------------------------------------------------' );
  l_chr_exe_location := 'INVAPP_002';
  l_stmt_processing  := ' Updating if Invoice is Closed i.e amount_due_remaining = 0 ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -----------------start of hot fix 81169 changes
  -------------------------------------------
  BEGIN
    SELECT NVL(SUM(TO_NUMBER(GLOBAL_ATTRIBUTE10)),0) -- ADDED ON 13-JUN-2013 to
      -- capture records in whitelisting error
    INTO V_l_num_claim_amt
    FROM ar_cash_receipts_all
    WHERE attribute15 IN('MATCHED','PARTIALLY MATCHED','SPI PARTIALLY MATCHED') --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
    AND STATUS        <>'REV'
    AND ATTRIBUTE12    =p_in_irt_id;	
dbms_output.put_line('Claim amount for irt id:'||p_in_irt_id||'is '||V_l_num_claim_amt);
    l_stmt_processing := ' CHECKING FOR REFD WHITE LISTING FOR ZERO CREDIT';
    SELECT NVL(SUM(Global_Attribute2),0)
    INTO V_L_Global_Attribute2
    FROM Ra_Customer_Trx_All
    WHERE Attribute11 =p_in_irt_id;

	dbms_output.put_line('V_L_Global_Attribute2: '||V_L_Global_Attribute2);

    write_debug( g_debug_flag ,'V_L_Global_Attribute2: '||V_L_Global_Attribute2);
    write_debug( g_debug_flag ,'V_l_num_claim_amt: '||V_l_num_claim_amt);
    IF V_L_NUM_CLAIM_AMT = 0 AND V_L_GLOBAL_ATTRIBUTE2 =0 THEN
      NULL;
    ELSIF V_L_Num_Claim_Amt = 0 AND V_L_Global_Attribute2 <> 0 THEN
		  l_ins_chk            := 0;
		  SELECT COUNT('X')
		  INTO l_ins_chk
		  FROM xx_irt_fas_prcsng_hold
		  WHERE irt_id      = P_IN_IRT_ID
		  AND hold_flag     = 'IRT CLAIM HOLD'
		  AND release_flag IS NULL;
			  IF l_ins_chk      = 0 THEN
				INSERT
				INTO xx_irt_fas_prcsng_hold
				  (
					irt_id,
					hold_flag,
					creation_date,
					last_update_date,
					matched_amount, --Added for Hotfix 146632
					claimed_amount  --Added for Hotfix 146632
				  )
				  VALUES
				  (
					p_in_irt_id,
					'IRT CLAIM HOLD',
					SYSDATE,
					SYSDATE,
					V_l_num_claim_amt,    --Added for Hotfix 146632
					V_L_Global_Attribute2 --Added for Hotfix 146632
				  );
				----   COMMIT;
			  END IF;
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    FND_FILE.put_line ( FND_FILE.LOG,'ERRORR WHILE PROCESSING FOR ZERO CREDIT' ) ;
	dbms_output.put_line('ERRORR WHILE PROCESSING FOR ZERO CREDIT' );
  END;   
  ---------------------end Hot fix 81169 changes
  -----------------------------------

 -- BEGIN--added

--  Exception when no_data_found then
--	v_cust_trx_id  := null;

 --- End;
  -- dbms_output.put_line('cust_trx_id ..:'||v_cust_trx_id ||'V_cust'||V_cust);


  UPDATE ra_customer_trx_all rat
  SET rat.attribute9                    = 'PCM CLOSED'
  WHERE rat.interface_header_attribute1 = p_in_irt_id
  AND rat.attribute9                    = 'NEW'
  AND EXISTS
    (SELECT arp.customer_trx_id
    FROM ar_payment_schedules_all arp
    WHERE arp.customer_trx_id    = rat.customer_trx_id
    AND arp.status               = 'CL'
    AND arp.amount_due_remaining = 0
    )
  AND rat.attribute4 IS NOT NULL -- NOt required
  AND rat.attribute5 IS NOT NULL
  AND rat.attribute1 IS NOT NULL;

  write_debug( g_debug_flag ,' No of records Updated for Zero Invoice: ' || SQL%ROWCOUNT);
  dbms_output.put_line(' No of records Updated for Zero Invoice: ' || SQL%ROWCOUNT);
  l_chr_exe_location := 'INVAPP_003';
  l_stmt_processing  := ' Updating as Dmd if no pending receipts to be matched' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -------Hint /*+ index (ARC XX_AR_CASH_RECEIPTS_ATT12) */ added by Oracle ACS
  -- on Nov 03 ---------
  FOR i  IN
  (SELECT *
  FROM ra_customer_trx_all RAT
  WHERE RAT.interface_header_attribute1 = p_in_irt_id
  AND RAT.attribute9                    = 'NEW'
  AND NOT EXISTS
   (SELECT
		1
    FROM ar_cash_receipts_all ARC
     -- "efile"."irt_xx_matched"@psql_process_fas itm
    WHERE RAT.attribute9                                          = 'NEW'
    AND ARC.attribute5                                            = RAT.attribute5
    AND ( ( ARC.attribute4                                        = RAT.attribute4
    AND ARC.attribute15                                          IN ('MATCHED', 'PARTIALLY MATCHED','SPI PARTIALLY MATCHED') ) --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
    OR ( TO_NUMBER (ARC.attribute4)                               < TO_NUMBER (RAT.attribute4)
    AND ARC.global_attribute4                                     = 'TS'
    AND ARC.attribute2                                            = '200'
    AND ARC.attribute15 NOT                                      IN('CLAIMED', 'REFD IN PROCESS') ) )
    AND ARC.attribute1                                            = RAT.attribute1
    AND RAT.attribute11                                           = ARC.attribute12
    AND TO_NUMBER (ARC.global_attribute10)                        > 0
   -- AND itm."irt_id"                                                = to_number(arc.attribute12)
    --AND DECODE(itm."xx_type_val", 'DDTP', 'DDT', itm."xx_type_val") = rat.attribute7
   -- AND itm."matched_amt"                                           = to_number(arc.global_attribute10)
   --commented irt_xx_matched table in ABC-2.0 - Bhagya
    )
 /* AND RAT.ATTRIBUTE7 NOT IN
    (SELECT DECODE("xx_type_val", 'DDTP', 'DDT', "xx_type_val")
    FROM "efile"."irt_xx_matched"@psql_process_fas
    WHERE "irt_id"    = to_number (RAT.interface_header_attribute1)
    AND "matched_amt" > 0
    )*/
	--commented irt_xx_matched table in ABC-2.0 - Bhagya 
  )
  LOOP
  dbms_output.put_line('v_cust_trx_id15: '|| i.customer_trx_id);
  dbms_output.put_line('att9: '|| i.attribute9);
  dbms_output.put_line('v_true: '|| v_true);


    write_debug( g_debug_flag , 'v_cust_trx_id15: '|| i.customer_trx_id);
    write_debug( g_debug_flag , 'att9: '|| i.attribute9);
    write_debug( g_debug_flag , 'v_true: '|| v_true);
  END LOOP;

  UPDATE ra_customer_trx_all RAT
  SET RAT.attribute9 = 'DMD' ,
    RAT.attribute12  =
    (SELECT ABS (amount_due_remaining)
    FROM ar_payment_schedules_all
    WHERE customer_trx_id = RAT.customer_trx_id
    )
  WHERE RAT.interface_header_attribute1 = p_in_irt_id
  AND RAT.attribute9                    = 'NEW'
  AND NOT EXISTS
    (SELECT
      /*+ index (ARC XX_AR_CASH_RECEIPTS_ATT12) */
      1
    FROM ar_cash_receipts_all ARC
     -- "efile"."irt_xx_matched"@psql_process_fas itm   --commented irt_xx_matched table in ABC-2.0 - Bhagya
    WHERE RAT.attribute9                                          = 'NEW'
    AND ARC.attribute5                                            = RAT.attribute5
    AND ( ( ARC.attribute4                                        = RAT.attribute4
    AND ARC.attribute15                                          IN ('MATCHED', 'PARTIALLY MATCHED','SPI PARTIALLY MATCHED') ) --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
    OR ( TO_NUMBER (ARC.attribute4)                               < TO_NUMBER (RAT.attribute4)
    AND ARC.global_attribute4                                     = 'TS'
    AND ARC.attribute2                                            = '200'
    AND ARC.attribute15 NOT                                      IN('CLAIMED', 'REFD IN PROCESS') ) )
    AND ARC.attribute1                                            = RAT.attribute1
    AND RAT.attribute11                                           = ARC.attribute12
    AND TO_NUMBER (ARC.global_attribute10)                        > 0
    --AND itm."irt_id"                                                = to_number(arc.attribute12)
    --AND DECODE(itm."xx_type_val", 'DDTP', 'DDT', itm."xx_type_val") = rat.attribute7
    --AND itm."matched_amt"                                           = to_number(arc.global_attribute10)
    )
  /*AND RAT.ATTRIBUTE7 NOT IN
    (SELECT DECODE("xx_type_val", 'DDTP', 'DDT', "xx_type_val")
    FROM "efile"."irt_xx_matched"@psql_process_fas
    WHERE "irt_id"    = to_number (RAT.interface_header_attribute1)
    AND "matched_amt" > 0
    )
	*/
	;
	dbms_output.put_line('No of records updated for Zero Receipts to DMD: '|| SQL%ROWCOUNT );

  write_debug( g_debug_flag , 'No of records updated for Zero Receipts to DMD: '|| SQL%ROWCOUNT );
  l_chr_exe_location := 'INVAPP_004';
  l_stmt_processing  := ' Getting Open Invoice for IRT ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );

  /* BEGIN
   SELECT rat.customer_trx_id 
      INTO V_cust
    FROM ra_customer_trx_all rat ,
      ar_payment_schedules_all arp
    WHERE rat.customer_trx_id           = arp.customer_trx_id
    AND rat.interface_header_attribute1 = '12'
    AND rat.attribute9                  = 'NEW'
    AND arp.status                      = 'OP'
    AND rat.attribute4                 IS NOT NULL
    AND rat.attribute5                 IS NOT NULL
    AND rat.attribute1                 IS NOT NULL;
  --  AND arp.amount_due_remaining       <> 0;
	exception when no_data_found then 
	dbms_output.put_line('no data found  of  '|| V_cust );
	end;
	*/

  For i in(Select rat.customer_trx_id, arp.customer_trx_id arp_cust_trx,rat.attribute1,rat.attribute4,rat.attribute5,rat.attribute9,rat.interface_header_attribute1,--into v_cust_trx_id
 ABS (arp.amount_due_remaining) amount_due_remaining , arp.status from  ra_customer_trx_all rat, ar_payment_schedules_all arp
--  SET rat.attribute9                    = 'PCM CLOSED'
  WHERE rat.customer_trx_id           = arp.customer_trx_id 
  and rat.interface_header_attribute1 = p_in_irt_id)loop
    dbms_output.put_line('RAT cust_trx_id ..:'||i.customer_trx_id ||' attributes:'||i.attribute1||':'||i.attribute4||':'||i.attribute5||' Status:'||i.status);
	dbms_output.put_line('cust_trx_id .:'||i.customer_trx_id ||'attributes.:'||i.attribute9||':'||i.interface_header_attribute1||' amount_due_remaining:'||i.amount_due_remaining);
  end loop;


  dbms_output.put_line('Start Cursor cur_inv for inv_apply' );
  OPEN cur_inv ( p_in_irt_id );
  LOOP
    --Bulk collecting into by limiting the number of records
    FETCH cur_inv BULK COLLECT
    INTO cur_inv_rec LIMIT 1000;
    l_chr_exe_location := 'INVAPP_005';
    l_stmt_processing  := ' Feching Open Invoice ' ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || ' -' || cur_inv_rec.COUNT );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing || ' -' || cur_inv_rec.COUNT );
    -- use a variabe for LIMIT
    EXIT
  WHEN cur_inv_rec.COUNT = 0;
    FOR idx IN cur_inv_rec.FIRST .. cur_inv_rec.LAST
    LOOP
      -- LOOP
      l_receipt_avl_flg := 'N';
      write_debug( g_debug_flag , '************');
      write_debug( g_debug_flag ,'Invoice number :'|| cur_inv_rec (idx) .trx_number);
      write_debug( g_debug_flag ,'Invoice Amount :'|| cur_inv_rec (idx) .amount_due_remaining);
      write_debug( g_debug_flag ,'Id Number :'|| cur_inv_rec (idx) .customer_number);
      write_debug( g_debug_flag ,'Assessment Year:'|| cur_inv_rec (idx) .assmt_year);
      write_debug( g_debug_flag ,'Major Head :'|| cur_inv_rec (idx).major_head) ;
      write_debug( g_debug_flag ,'Schedule type :'|| cur_inv_rec (idx) .schedule_type);
      --
      -- Apply Invoice to receipt for current Assesment year
      --
	   dbms_output.put_line('Invoice number :'|| cur_inv_rec (idx) .trx_number);
	    dbms_output.put_line('Invoice Amount :'|| cur_inv_rec (idx) .amount_due_remaining);
		dbms_output.put_line('Id Number  :'|| cur_inv_rec (idx) .customer_number);
		dbms_output.put_line('Major Head :'|| cur_inv_rec (idx).major_head);
		dbms_output.put_line('Schedule type :'|| cur_inv_rec (idx) .schedule_type);


      l_recpt_amount      := 0;
      l_inv_amount        := NULL;
      l_inv_amount        := cur_inv_rec (idx).amount_due_remaining;
      l_num_tot_apply_amt := 0;
      l_chr_exe_location  := 'INVAPP_006';
	  dbms_output.put_line('l_chr_exe_location'||l_chr_exe_location);

      l_stmt_processing   := ' Checking is Schedule Type DDT and Major Head 200 Case' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      --IF cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (idx)
      -- .schedule_type = 'DDT' THEN
      IF ((cur_inv_rec (idx).major_head  = '0020' AND cur_inv_rec (idx) .schedule_type = 'DDT') OR ( cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (idx) .schedule_type = 'BBS' ) ) THEN
        IF (cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (idx) .schedule_type = 'DDT') THEN --Added for BBS
          -- Seperation
		   --dbms_output.put_line('l_chr_exe_location'||'INVAPP_DDT_007');
          l_chr_exe_location := 'INVAPP_DDT_007';
          l_stmt_processing  := ' Schedule Type DDT and Major Head 200 Case' ;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          -- start of code added for refd whitelisting
          l_num_claim_amt :=0;
          SELECT NVL(SUM(to_number(global_attribute10)),0) -- ADDED ON 13-JUN-2013
            -- to capture records in whitelisting error
          INTO l_num_claim_amt
          FROM ar_cash_receipts_all
          WHERE attribute15  IN('MATCHED','PARTIALLY MATCHED')
          AND status         <>'REV'
          AND attribute12     =cur_inv_rec(idx).irt_id
          AND attribute1      =cur_inv_rec(idx).major_head
          AND attribute2      ='106';

		  dbms_output.put_line('ar_cash_receipts_all Amount '||l_num_claim_amt);
          l_chr_exe_location := 'INVAPP_DDT_008';
          l_stmt_processing  := ' Getting Claim Amount ' ;
          write_debug( g_debug_flag ,l_stmt_processing ||' - ' || l_num_claim_amt );
          write_debug( g_debug_flag ,'cur_inv_rec.global_attribute2:' || cur_inv_rec(idx).global_attribute2);
		  dbms_output.put_line('cur_inv_rec.global_attribute2:' || cur_inv_rec(idx).global_attribute2);

          IF l_num_claim_amt   <> TO_NUMBER (cur_inv_rec(idx).global_attribute2) THEN
            l_chr_exe_location := 'INVAPP_DDT_009';
            l_stmt_processing  := ' Checking if any Claim Hold on IRT' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_ins_chk := 0;
            SELECT COUNT('X')
            INTO l_ins_chk
            FROM xx_irt_fas_prcsng_hold
            WHERE irt_id        = cur_inv_rec(idx).irt_id
            AND hold_flag       = 'IRT CLAIM HOLD'
            AND release_flag   IS NULL;
            l_chr_exe_location := 'INVAPP_DDT_010';
            l_stmt_processing  := ' Claim Hold on IRT is '|| l_ins_chk ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            IF l_ins_chk          = 0 THEN
              l_chr_exe_location := 'INVAPP_DDT_011';
              l_stmt_processing  := ' No Claim Hold on IRT , creating a Hold' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              INSERT
              INTO xx_irt_fas_prcsng_hold
                (
                  irt_id,
                  id,
                  ay,
                  hold_flag,
                  creation_date,
                  last_update_date,
                  matched_amount, --Added for Hotfix 146632
                  claimed_amount  --Added for Hotfix 146632
                )
                VALUES
                (
                  cur_inv_rec(idx).irt_id,
                  cur_inv_rec(idx).customer_number,
                  cur_inv_rec(idx).assmt_year,
                  'IRT CLAIM HOLD',
                  SYSDATE,
                  SYSDATE,
                  l_num_claim_amt,                   --Added for Hotfix 146632
                  cur_inv_rec(idx).global_attribute2 --Added for Hotfix 146632
                );
            END IF; -- IF l_ins_chk = 0
          END IF;   -- IF l_num_claim_amt <> TO_NUMBER (cur_inv_rec(idx).
          -- End of code for refd whitelisting
          l_chr_exe_location := 'INVAPP_DDT_012';
          l_stmt_processing  := ' OPening Cursor of Receipt for the IRT , Major head' ;
          write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
          OPEN cur_recpt ( cur_inv_rec (idx).customer_number, cur_inv_rec (idx).assmt_year, cur_inv_rec (idx).major_head, '106', NULL, NULL, NULL,NULL,NULL,NULL,NULL, cur_inv_rec (idx).irt_id, cur_inv_Rec(idx).schedule_type --Added  one more parameter for Minor Head 'OTH' as part of CR#0613(5A-SPI)-Phase2, added NULL for CR - 661 for in_irt_schedule_type
          -- Added 3.1.1
          ) ;
          LOOP
		  dbms_output.put_line ('Fetching the receipt details');
            l_chr_exe_location := 'INVAPP_DDT_013';
            l_stmt_processing  := ' Fetching Receipt for the IRT , Major head' ;
            write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
            --Bulk collecting into by limiting the number of records
            FETCH cur_recpt BULK COLLECT
            INTO cur_recpt_rec LIMIT 500;
            -- use a variable for this limit
            EXIT
          WHEN cur_recpt_rec.COUNT = 0;
            l_chr_exe_location    := 'INVAPP_DDT_014';
            l_stmt_processing     := ' About to Loop throught the Receipt and Apply' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            FOR idx1 IN cur_recpt_rec.FIRST .. cur_recpt_rec.LAST
            LOOP
              g_rcpt_cnt        := g_rcpt_cnt +1;
              l_receipt_avl_flg := 'Y';
              l_msg_count       := NULL;
              l_msg_data        := NULL;
              l_return_status   := NULL;
              l_apply_amount    := NULL;
              IF l_inv_amount   <= cur_recpt_rec (idx1).claim_amount THEN
                l_apply_amount  := l_inv_amount;
              ELSE--IF l_inv_amount <= cur_recpt_rec (idx1).claim_amount
                l_apply_amount := cur_recpt_rec (idx1).claim_amount;
              END IF; --IF l_inv_amount <= cur_recpt_rec (idx1).claim_amount
              l_num_tot_apply_amt := l_num_tot_apply_amt + l_apply_amount;
              l_chr_exe_location  := 'INVAPP_DDT_015';
              l_stmt_processing   := ' Computed Apply Amt before Apply' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              IF l_inv_amount      <> 0 THEN
                l_chr_exe_location := 'INVAPP_DDT_016';
                l_stmt_processing  := ' Calling Receipt Apply API ' ;
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                write_debug( g_debug_flag , 'Start of Application - '|| cur_recpt_rec (idx1).cash_receipt_id);
                write_debug( g_debug_flag , sysdate);
                --AR_RECEIPT_API_PUB.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec (idx).customer_trx_id, p_cash_receipt_id => cur_recpt_rec (idx1).cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => TO_DATE ( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data );  --Commented for Hotfix_199485 on 13-MAR-2019
              Dbms_output.put_line(l_stmt_processing||l_stmt_processing);

			  AR_RECEIPT_API_PUB.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec (idx).customer_trx_id, p_cash_receipt_id => cur_recpt_rec (idx1).cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => TO_DATE ( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), p_apply_gl_date => TO_DATE ( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data ); --Added for Hotfix_199485 on 13-MAR-2019

   Dbms_output.put_line('INVAPP_DDT_017'||l_return_status);
			  IF l_return_status    = 'S' THEN
                  l_chr_exe_location := 'INVAPP_DDT_017';
                  l_stmt_processing  := ' Calling Receipt Apply API Successful' ;
                  write_debug( g_debug_flag , 'Receipt Number : '|| cur_recpt_rec (idx1).receipt_number || ' - Assmt Year :'|| cur_recpt_rec (idx1).assmt_year || ' - Receipt Date : '|| cur_recpt_rec (idx1).receipt_date );
                  write_debug( g_debug_flag ,'Intermediate');
                  write_debug( g_debug_flag , ' Status for apply invoice amount '|| l_apply_amount || ' to Receipt Number : '|| cur_recpt_rec (idx1).receipt_number || ' - ' || l_return_status );
                  --
                  -- TO update the claim amount
                  --
                  l_chr_exe_location := 'INVAPP_DDT_018';
                  l_stmt_processing  := 'updating cash receipts for apply amount';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  UPDATE ar_cash_receipts_all arc
                  SET arc.global_attribute10 = TO_NUMBER (arc.global_attribute10) - l_apply_amount
                  WHERE arc.cash_receipt_id  = cur_recpt_rec (idx1).cash_receipt_id;
                  write_debug( g_debug_flag , 'After updating cash receipts for apply amount'|| SQLERRM);
                  l_chr_exe_location := 'INVAPP_DDT_019';
                  l_stmt_processing  :='updating cash receipts status in Att15' ;
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  --
                  --To Update the Receipt Flag = 'CLAIMED' once receipt amount
                  -- = 0 for matched receipts
                  --
                  UPDATE ar_cash_receipts_all arc
                  SET arc.attribute15                    = 'CLAIMED'
                  WHERE arc.cash_receipt_id              = cur_recpt_rec (idx1).cash_receipt_id
                  AND arc.attribute15                    = 'MATCHED'
                  AND TO_NUMBER (arc.global_attribute10) = 0;

				  dbms_output.put_line('Updated the status of receipt to CLAIMED');
                  --
                  -- To Update the Status = 'CLOSED' once the invoice amount =
                  -- 0
                  --
                  l_chr_exe_location := 'INVAPP_DDT_020';
                  l_stmt_processing  :='updating Invoice status PCM CLOSED';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
				  dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
                  --
                  UPDATE ra_customer_trx_all rat
                  SET rat.attribute9        = 'PCM CLOSED'
                  WHERE rat.customer_trx_id =
                    (SELECT customer_trx_id
                    FROM ar_payment_schedules_all
                    WHERE customer_trx_id    =cur_inv_rec (idx).customer_trx_id
                    AND status               = 'CL'
                    AND amount_due_remaining = 0
                    AND CLASS                = 'INV'
                    );
                  write_debug( g_debug_flag , 'after updating ra_customer_trx_all for attribute9'|| SQLERRM );
				  dbms_output.put_line('after updating ra_customer_trx_all for attribute9'|| SQLERRM );
                  l_inv_amount := l_inv_amount - l_apply_amount;
                  EXIT
                WHEN l_inv_amount = 0;
                ELSE -- IF l_return_status = 'S'
                  l_chr_exe_location := 'INVAPP_DDT_021';
                  l_stmt_processing  :='API Call Failed ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  write_debug( g_debug_flag , 'Receipt API Status for apply invoice number ' || cur_inv_rec (idx).trx_number || ' for amount Rs ' || l_apply_amount || ' to Receipt Number : ' || cur_recpt_rec (idx1) .receipt_number || ' is ' || l_return_status );
				  dbms_output.put_line('Receipt API Status for apply invoice number ' || cur_inv_rec (idx).trx_number || ' for amount Rs ' || l_apply_amount || ' to Receipt Number : ' || cur_recpt_rec (idx1) .receipt_number || ' is ' || l_return_status );
                  IF l_msg_count > 1 THEN
                    FOR i IN 1 .. l_msg_count
                    LOOP
                      p_out_chr_errbuff := p_out_chr_errbuff ||i|| '. '|| SUBSTR(fnd_msg_pub.get (p_encoded => fnd_api.g_false),1, 355);
                    END LOOP; -- FOR i IN 1 .. l_msg_count
                    write_msg( g_write_logfile,p_out_chr_errbuff );
                  ELSE
                    p_out_chr_errbuff := l_msg_data;
                  END IF; -- IF l_msg_count > 1
                  l_stmt_processing := ' Printed the Error details above of Receipt APi and returning back parent call' ;
                  -- l_chr_exe_location :='INVAPP_022';
                  write_msg( g_write_logfile, l_chr_exe_location ||'-'|| l_stmt_processing );
                  p_out_chr_retcode := g_chr_failure_code;
                  RAISE CUSTOM_EXCEPTION;
                  RETURN;
                END IF; -- -- IF l_return_status = 'S'
              END IF;   -- IF l_inv_amount <> 0
            END LOOP;   -- FOR idx1 IN cur_recpt_rec.FIRST ..
            -- cur_recpt_rec.LAST
            cur_recpt_rec.DELETE;
          END LOOP; -- OPEN cur_recpt (cur_inv_rec (
          CLOSE cur_recpt;
          l_stmt_processing  := ' Checking if Receipt flagis Y';
          l_chr_exe_location :='INVAPP_DDT_023';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          IF (l_receipt_avl_flg = 'Y') THEN
            l_stmt_processing  := ' Updating the status to Refd CrossMajor ';
            l_chr_exe_location :='INVAPP_DDT_024';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            UPDATE ar_cash_receipts_all acr
            SET acr.attribute15        = 'REFD CROSSMAJOR IN PROCESS'
            WHERE acr.cash_receipt_id IN
              (SELECT arc.cash_receipt_id
              FROM ar_cash_receipts_all arc
              WHERE arc.attribute5                   =cur_inv_rec (idx).customer_number
              AND TO_NUMBER (arc.attribute4)        <= TO_NUMBER(cur_inv_rec (idx) .assmt_year)
              AND arc.attribute15                    = 'MATCHED'
              AND arc.status                         = 'UNAPP'
              AND arc.attribute12                    =cur_inv_rec (idx).irt_id
              AND arc.attribute1                     =cur_inv_rec (idx).major_head
              AND TO_NUMBER (arc.global_attribute10) > 0
              AND arc.attribute2                     = '106'
              );
            l_stmt_processing  := ' Updating the status to Invoice to Dmd if Payment Schedule is Open' ;
            l_chr_exe_location :='INVAPP_DDT_024';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            UPDATE ra_customer_trx_all rat
            SET rat.attribute9 = 'DMD',
              rat.attribute12  =
              (SELECT ABS (amount_due_remaining)
              FROM ar_payment_schedules_all
              WHERE customer_trx_id = rat.customer_trx_id
              )
            WHERE rat.customer_trx_id =
              (SELECT customer_trx_id
              FROM ar_payment_schedules_all
              WHERE customer_trx_id =cur_inv_rec (idx).customer_trx_id
              AND status            = 'OP'
              AND CLASS             = 'INV'
              );
          ELSIF(l_receipt_avl_flg = 'N') THEN
            l_stmt_processing    := ' Receipt Flag is N, so recomputing Amount due remaining';
            l_chr_exe_location   :='INVAPP_DDT_025';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
			dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
            UPDATE ra_customer_trx_all rat
            SET rat.attribute9 = 'DMD',
              rat.attribute12  =
              (SELECT ABS (amount_due_remaining)
              FROM ar_payment_schedules_all
              WHERE customer_trx_id = rat.customer_trx_id
              )
            WHERE rat.customer_trx_id =
              (SELECT customer_trx_id
              FROM ar_payment_schedules_all
              WHERE customer_trx_id = cur_inv_rec (idx).customer_trx_id
              AND status            = 'OP'
              AND CLASS             = 'INV'
              );
          END IF;
          l_stmt_processing  := ' End of Processing for DDT';
          l_chr_exe_location :='INVAPP_DDT_027';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
		  dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
          --Added as a Part of BBS Starts Here - 03-Mar-2015
        ELSE
          IF (cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (idx) .schedule_type = 'BBS') THEN
            l_chr_exe_location            := 'INVAPP_BBS_007';
            l_stmt_processing             := ' Schedule Type DDT and Major Head 200 Case' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            -- start of code added for refd whitelisting
            l_num_claim_amt :=0;
            SELECT NVL(SUM(to_number(global_attribute10)),0) -- ADDED ON 13-JUN-2013
              -- to capture records in whitelisting error
            INTO l_num_claim_amt
            FROM ar_cash_receipts_all
            WHERE attribute15  IN('MATCHED','PARTIALLY MATCHED')
            AND status         <>'REV'
            AND attribute12     =cur_inv_rec(idx).irt_id
            AND attribute1      =cur_inv_rec(idx).major_head
            AND attribute2      ='107';
            l_chr_exe_location := 'INVAPP_BBS_008';
            l_stmt_processing  := ' Getting Claim Amount ' ;
			dbms_output.put_line('Claim amount l_num_claim_amt: '||l_num_claim_amt);
            write_debug( g_debug_flag ,l_stmt_processing ||' - ' || l_num_claim_amt );
            write_debug( g_debug_flag ,'cur_inv_rec.global_attribute2:' || cur_inv_rec(idx).global_attribute2);
            IF l_num_claim_amt   <> TO_NUMBER (cur_inv_rec(idx).global_attribute2 ) THEN
              l_chr_exe_location := 'INVAPP_BBS_009';
              l_stmt_processing  := ' Checking if any Claim Hold on IRT' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_ins_chk := 0;
              SELECT COUNT('X')
              INTO l_ins_chk
              FROM xx_irt_fas_prcsng_hold
              WHERE irt_id        = cur_inv_rec(idx).irt_id
              AND hold_flag       = 'IRT CLAIM HOLD'
              AND release_flag   IS NULL;
              l_chr_exe_location := 'INVAPP_BBS_010';
              l_stmt_processing  := ' Claim Hold on IRT is '|| l_ins_chk ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              IF l_ins_chk          = 0 THEN
                l_chr_exe_location := 'INVAPP_BBS_011';
                l_stmt_processing  := ' No Claim Hold on IRT , creating a Hold' ;
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                INSERT
                INTO xx_irt_fas_prcsng_hold
                  (
                    irt_id,
                    id,
                    ay,
                    hold_flag,
                    creation_date,
                    last_update_date,
                    matched_amount, --Added for Hotfix 146632
                    claimed_amount  --Added for Hotfix 146632
                  )
                  VALUES
                  (
                    cur_inv_rec(idx).irt_id,
                    cur_inv_rec(idx).customer_number,
                    cur_inv_rec(idx).assmt_year,
                    'IRT CLAIM HOLD',
                    SYSDATE,
                    SYSDATE,
                    l_num_claim_amt,                   --Added for Hotfix 146632
                    cur_inv_rec(idx).global_attribute2 --Added for Hotfix
                    -- 146632
                  );
              END IF; -- IF l_ins_chk = 0
            END IF;   -- IF l_num_claim_amt <> TO_NUMBER (cur_inv_rec(idx).
            -- End of code for refd whitelisting
            l_chr_exe_location := 'INVAPP_BBS_012';
            l_stmt_processing  := ' OPening Cursor of Receipt for the IRT , Major head' ;
            write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
            OPEN cur_recpt ( cur_inv_rec (idx).customer_number, cur_inv_rec (idx).assmt_year, cur_inv_rec (idx).major_head, '107', NULL, NULL, NULL,NULL,NULL,NULL,NULL, cur_inv_rec (idx).irt_id, cur_inv_rec(idx).schedule_type --Added  one more parameter as NULL for Minor Head 'OTH' as part of  CR#0613(5A-SPI)-Phase2, added NULL for CR - 661 for in_irt_schedule_type
            -- Added 3.1.1
            ) ;
            LOOP
              l_chr_exe_location := 'INVAPP_BBS_013';
              l_stmt_processing  := ' Fetching Receipt for the IRT , Major head' ;
              write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
              --Bulk collecting into by limiting the number of records
              FETCH cur_recpt BULK COLLECT
              INTO cur_recpt_rec LIMIT 500;
              -- use a variable for this limit
              EXIT
            WHEN cur_recpt_rec.COUNT = 0;
              l_chr_exe_location    := 'INVAPP_BBS_014';
              l_stmt_processing     := ' About to Loop throught the Receipt and Apply' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              FOR idx1 IN cur_recpt_rec.FIRST .. cur_recpt_rec.LAST
              LOOP
                g_rcpt_cnt        := g_rcpt_cnt +1;
                l_receipt_avl_flg := 'Y';
                l_msg_count       := NULL;
                l_msg_data        := NULL;
                l_return_status   := NULL;
                l_apply_amount    := NULL;
                IF l_inv_amount   <= cur_recpt_rec (idx1).claim_amount THEN
                  l_apply_amount  := l_inv_amount;
                ELSE--IF l_inv_amount <= cur_recpt_rec (idx1).claim_amount
                  l_apply_amount := cur_recpt_rec (idx1).claim_amount;
                END IF; --IF l_inv_amount <= cur_recpt_rec (idx1).claim_amount
                l_num_tot_apply_amt := l_num_tot_apply_amt + l_apply_amount;
                l_chr_exe_location  := 'INVAPP_BBS_015';
                l_stmt_processing   := ' Computed Apply Amt before Apply' ;
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                IF l_inv_amount      <> 0 THEN
                  l_chr_exe_location := 'INVAPP_BBS_016';
                  l_stmt_processing  := ' Calling Receipt Apply API ' ;
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  write_debug( g_debug_flag , 'Start of Application - '|| cur_recpt_rec (idx1).cash_receipt_id);
                  write_debug( g_debug_flag , sysdate);
                  --AR_RECEIPT_API_PUB.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec (idx).customer_trx_id, p_cash_receipt_id => cur_recpt_rec ( idx1).cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => TO_DATE (cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data );  --Commented for Hotfix_199485 on 13-MAR-2019
                  AR_RECEIPT_API_PUB.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec (idx).customer_trx_id, p_cash_receipt_id => cur_recpt_rec ( idx1).cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => TO_DATE (cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), p_apply_gl_date => TO_DATE (cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data ); --Added for Hotfix_199485 on 13-MAR-2019
                  IF l_return_status    = 'S' THEN
                    l_chr_exe_location := 'INVAPP_BBS_017';
                    l_stmt_processing  := ' Calling Receipt Apply API Successful' ;
                    write_debug( g_debug_flag , 'Receipt Number : '|| cur_recpt_rec (idx1).receipt_number || ' - Assmt Year :'|| cur_recpt_rec (idx1).assmt_year || ' - Receipt Date : '|| cur_recpt_rec (idx1).receipt_date );
                    write_debug( g_debug_flag ,'Intermediate');
                    write_debug( g_debug_flag , ' Status for apply invoice amount '|| l_apply_amount || ' to Receipt Number : '|| cur_recpt_rec (idx1) .receipt_number || ' - ' || l_return_status );
                    --
                    -- TO update the claim amount
                    --
                    l_chr_exe_location := 'INVAPP_BBS_018';
                    l_stmt_processing  := 'updating cash receipts for apply amount';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    UPDATE ar_cash_receipts_all arc
                    SET arc.global_attribute10 = TO_NUMBER ( arc.global_attribute10) - l_apply_amount
                    WHERE arc.cash_receipt_id  = cur_recpt_rec (idx1) .cash_receipt_id;
                    write_debug( g_debug_flag , 'After updating cash receipts for apply amount'|| SQLERRM);
                    l_chr_exe_location := 'INVAPP_BBS_019';
                    l_stmt_processing  := 'updating cash receipts status in Att15';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    --
                    --To Update the Receipt Flag = 'CLAIMED' once receipt
                    -- amount = 0 for matched receipts
                    --
                    UPDATE ar_cash_receipts_all arc
                    SET arc.attribute15                    = 'CLAIMED'
                    WHERE arc.cash_receipt_id              = cur_recpt_rec (idx1) .cash_receipt_id
                    AND arc.attribute15                    = 'MATCHED'
                    AND TO_NUMBER (arc.global_attribute10) = 0;
                    --
                    -- To Update the Status = 'CLOSED' once the invoice amount
                    -- = 0
                    --
                    l_chr_exe_location := 'INVAPP_BBS_020';
                    l_stmt_processing  :='updating Invoice status PCM CLOSED';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    --
                    UPDATE ra_customer_trx_all rat
                    SET rat.attribute9        = 'PCM CLOSED'
                    WHERE rat.customer_trx_id =
                      (SELECT customer_trx_id
                      FROM ar_payment_schedules_all
                      WHERE customer_trx_id    =cur_inv_rec (idx).customer_trx_id
                      AND status               = 'CL'
                      AND amount_due_remaining = 0
                      AND CLASS                = 'INV'
                      );
                    write_debug( g_debug_flag , 'after updating ra_customer_trx_all for attribute9'|| SQLERRM);
                    l_inv_amount := l_inv_amount - l_apply_amount;
                    EXIT
                  WHEN l_inv_amount = 0;
                  ELSE -- IF l_return_status = 'S'
                    l_chr_exe_location := 'INVAPP_BBS_021';
                    l_stmt_processing  :='API Call Failed ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    write_debug( g_debug_flag , 'Receipt API Status for apply invoice number ' || cur_inv_rec (idx).trx_number || ' for amount Rs ' || l_apply_amount || ' to Receipt Number : ' || cur_recpt_rec (idx1).receipt_number || ' is ' || l_return_status );
                    IF l_msg_count > 1 THEN
                      FOR i IN 1 .. l_msg_count
                      LOOP
                        p_out_chr_errbuff := p_out_chr_errbuff ||i|| '. '|| SUBSTR(fnd_msg_pub.get (p_encoded => fnd_api.g_false),1 ,355);
                      END LOOP; -- FOR i IN 1 .. l_msg_count
                      write_msg( g_write_logfile,p_out_chr_errbuff );
                    ELSE
                      p_out_chr_errbuff := l_msg_data;
                    END IF; -- IF l_msg_count > 1
                    l_stmt_processing := ' Printed the Error details above of Receipt APi and returning back parent call' ;
                    -- l_chr_exe_location :='INVAPP_022';
                    write_msg( g_write_logfile, l_chr_exe_location ||'-'|| l_stmt_processing );
                    p_out_chr_retcode := g_chr_failure_code;
					dbms_output.put_line('Step18'||g_chr_failure_code);
                    RAISE CUSTOM_EXCEPTION;
                    RETURN;
                  END IF; -- -- IF l_return_status = 'S'
                END IF;   -- IF l_inv_amount <> 0
              END LOOP;   -- FOR idx1 IN cur_recpt_rec.FIRST ..
              -- cur_recpt_rec.LAST
              cur_recpt_rec.DELETE;
            END LOOP; -- OPEN cur_recpt (cur_inv_rec (
            CLOSE cur_recpt;
            l_stmt_processing  := ' Checking if Receipt flagis Y';
            l_chr_exe_location :='INVAPP_BBS_023';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            IF (l_receipt_avl_flg = 'Y') THEN
              l_stmt_processing  := ' Updating the status to Refd CrossMajor ';
              l_chr_exe_location :='INVAPP_BBS_024';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE ar_cash_receipts_all acr
              SET acr.attribute15        = 'REFD CROSSMAJOR IN PROCESS'
              WHERE acr.cash_receipt_id IN
                (SELECT arc.cash_receipt_id
                FROM ar_cash_receipts_all arc
                WHERE arc.attribute5                   =cur_inv_rec (idx).customer_number
                AND TO_NUMBER (arc.attribute4)        <= TO_NUMBER(cur_inv_rec (idx) .assmt_year)
                AND arc.attribute15                    = 'MATCHED'
                AND arc.status                         = 'UNAPP'
                AND arc.attribute12                    =cur_inv_rec (idx).irt_id
                AND arc.attribute1                     =cur_inv_rec (idx).major_head
                AND TO_NUMBER (arc.global_attribute10) > 0
                AND arc.attribute2                     = '107'
                );
              l_stmt_processing  := ' Updating the status to Invoice to Dmd if Payment Schedule is Open' ;
              l_chr_exe_location :='INVAPP_BBS_024';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE ra_customer_trx_all rat
              SET rat.attribute9 = 'DMD',
                rat.attribute12  =
                (SELECT ABS (amount_due_remaining)
                FROM ar_payment_schedules_all
                WHERE customer_trx_id = rat.customer_trx_id
                )
              WHERE rat.customer_trx_id =
                (SELECT customer_trx_id
                FROM ar_payment_schedules_all
                WHERE customer_trx_id =cur_inv_rec (idx).customer_trx_id
                AND status            = 'OP'
                AND CLASS             = 'INV'
                );
            ELSIF(l_receipt_avl_flg = 'N') THEN
              l_stmt_processing    := ' Receipt Flag is N, so recomputing Amount due remaining';
              l_chr_exe_location   :='INVAPP_BBS_025';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE ra_customer_trx_all rat
              SET rat.attribute9 = 'DMD',
                rat.attribute12  =
                (SELECT ABS (amount_due_remaining)
                FROM ar_payment_schedules_all
                WHERE customer_trx_id = rat.customer_trx_id
                )
              WHERE rat.customer_trx_id =
                (SELECT customer_trx_id
                FROM ar_payment_schedules_all
                WHERE customer_trx_id = cur_inv_rec (idx).customer_trx_id
                AND status            = 'OP'
                AND CLASS             = 'INV'
                );
            END IF;
          END IF; --IF (cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (
          -- idx).schedule_type = 'BBS')
          l_stmt_processing  := ' End of Processing for BBS';
          l_chr_exe_location :='INVAPP_BBS_027';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
        END IF; --IF (cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (
        -- idx).schedule_type = 'DDT')
      ELSIF ( ( cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (idx) .schedule_type = 'IT') OR ( cur_inv_rec (idx).major_head = '0026' AND cur_inv_rec (idx) .schedule_type = 'FBT' ) OR ( cur_inv_rec (idx).major_head = '0021' AND cur_inv_rec (idx) .schedule_type = 'IT') ) THEN
        l_stmt_processing                   := ' Start Processing for IT and FBT ';
        l_chr_exe_location                  :='INVAPP_028';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_tot_apply_amt     := 0;
        l_num_claim_amt         :=0;
        l_num_claim_amt_ts     := 0;                    -- Added for 661
        l_num_claim_amt_ch := 0;                    -- Added for 661
        SELECT NVL(SUM(to_number(global_attribute10)),0) -- ADDED ON 13-JUN-2013 to
          -- capture records in whitelisting error
          --into l_num_claim_amt -- Commented for CR - 661
        INTO l_num_claim_amt_ts --Added for CR - 661
        FROM ar_cash_receipts_all acr
        WHERE attribute15 IN ('MATCHED','PARTIALLY MATCHED','SPI PARTIALLY MATCHED') --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
        AND status        <>'REV'
        AND attribute12    =cur_inv_rec(idx).irt_id
        AND attribute1     =cur_inv_rec(idx).major_head
          -- AND attribute2                IN ( '100', '200', '300', 'XCL','PMR','SPI','5A','OTH') -- Added Major Head 'PMR' as part of CR#0653 --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
        AND attribute2 IN ('200', 'XCL','PMR','SPI','5A','OTH') ;-- Added for CR - 661
        write_debug( g_debug_flag ,'l_num_claim_amt_ts: ' ||' - ' || l_num_claim_amt_ts);
        /*Changes for CR - 661*/
        BEGIN
          SELECT NVL(SUM(GLOBAL_ATTRIBUTE10), 0)
          INTO l_num_claim_amt_ch
          FROM AR_CASH_RECEIPTS_ALL ARC
          WHERE ATTRIBUTE12        = cur_inv_rec(idx).irt_id
          AND ATTRIBUTE1           = cur_inv_rec(idx).major_head
          AND ATTRIBUTE15         IN ('MATCHED','PARTIALLY MATCHED','SPI PARTIALLY MATCHED')
          AND attribute2          IN ( '100', '300') -- Added Major Head 'PMR' as part of CR#0653 --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
          /*AND ARC.CASH_RECEIPT_ID IN
            (SELECT FAS_ID
            FROM IRT_MATCHING.IRT_CLAIMS_MATCHING
            WHERE IRT_ID          = TO_NUMBER(ARC.ATTRIBUTE12)
            AND SCHEDULE_TYPE_TXT = cur_inv_rec(idx).schedule_type
            )*/   
          /*HAVING NVL(SUM(ARC.GLOBAL_ATTRIBUTE10),0) =
            (SELECT NVL(SUM(MATCHED_AMT),0)
            FROM IRT_MATCHING.IRT_CLAIMS_MATCHING
            WHERE IRT_ID          = TO_NUMBER(ARC.ATTRIBUTE12)
            AND SCHEDULE_TYPE_TXT = cur_inv_rec(idx).schedule_type
            )*/
	--commented IRT_MATCHING.IRT_CLAIMS_MATCHING table in ABC-2.0 - Bhagya
          GROUP BY ARC.ATTRIBUTE12; -- Added for CR - 661 on 12-MAR-2019
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          l_num_claim_amt_ch :=0;
        END;
        WRITE_DEBUG( G_DEBUG_FLAG ,'l_num_claim_amt_ch: ' ||' - ' || l_num_claim_amt_ch );
		dbms_output.put_line('l_num_claim_amt_ch: ' ||' - ' || l_num_claim_amt_ch );
        l_num_claim_amt := l_num_claim_amt_ts + l_num_claim_amt_ch;
        /*Changes for CR - 661 end */
        l_stmt_processing  := ' Getting Sum of Claim Amount for IT and FBT values for IRT';
        l_chr_exe_location :='INVAPP_029';
        write_debug( g_debug_flag ,l_stmt_processing ||' - ' || l_num_claim_amt );
        write_debug( g_debug_flag ,'cur_inv_rec.global_attribute2:' || cur_inv_rec(idx).global_attribute2);
        IF l_num_claim_amt   <> TO_NUMBER (cur_inv_rec(idx).global_attribute2) THEN
          l_stmt_processing  := ' Claim Amount and global_Attribute2 not equal checking for Hold';
          l_chr_exe_location :='INVAPP_030';
          write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
		  dbms_output.put_line(l_chr_exe_location ||' - ' || l_stmt_processing );
          SELECT COUNT('x')
          INTO l_ins_chk
          FROM xx_irt_fas_prcsng_hold
          WHERE irt_id          = cur_inv_rec(idx).irt_id
          AND hold_flag         = 'IRT CLAIM HOLD'
          AND release_flag     IS NULL;
          IF l_ins_chk          = 0 THEN
            l_stmt_processing  := ' Putting a Claim Hold entry in the fas Hold Table ';
            l_chr_exe_location :='INVAPP_032';
            write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
			dbms_output.put_line(l_chr_exe_location ||' - ' || l_stmt_processing );
            INSERT
            INTO xx_irt_fas_prcsng_hold
              (
                irt_id,
                id,
                ay,
                hold_flag,
                creation_date,
                last_update_date,
                matched_amount, --Added for Hotfix 146632
                claimed_amount  --Added for Hotfix 146632
              )
              VALUES
              (
                cur_inv_rec(idx).irt_id,
                cur_inv_rec(idx).customer_number,
                cur_inv_rec(idx).assmt_year,
                'IRT CLAIM HOLD',
                SYSDATE,
                SYSDATE,
                l_num_claim_amt,                   --Added for Hotfix 146632
                cur_inv_rec(idx).global_attribute2 --Added for Hotfix 146632
              );
          END IF; -- IF l_ins_chk = 0
        END IF;   -- IF L_NUM_CLAIM_AMT <> TO_NUMBER (cur_inv_rec(idx)
        -- .global_attribute2)
        l_stmt_processing  := ' Open cursor to Fetch Receipt for the IRT';
        l_chr_exe_location :='INVAPP_033';
        write_debug ( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing ) ;
        OPEN cur_recpt ( cur_inv_rec (idx).customer_number, cur_inv_rec (idx).assmt_year, cur_inv_rec (idx).major_head, '100', '200', '300', 'XCL','PMR','SPI','5A','OTH', cur_inv_rec (idx).irt_id, cur_inv_rec (idx).schedule_type ---- Added Major Head 'PMR' as part of CR#0653  --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2, Added cur_inv_rec (idx).schedule_type for CR - 661
        ) ;
        LOOP
          FETCH cur_recpt BULK COLLECT INTO cur_recpt_rec1 LIMIT 500;
          --use a variable for the LIMIT
          EXIT
        WHEN cur_recpt_rec1.COUNT = 0;
          l_stmt_processing      := ' Pick Receipt to Apply from bulk rec type ';
          l_chr_exe_location     :='INVAPP_034';
          write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
          FOR idx2 IN cur_recpt_rec1.FIRST .. cur_recpt_rec1.LAST
          LOOP
            g_rcpt_cnt        := g_rcpt_cnt +1;
            l_receipt_avl_flg := 'Y';
            l_msg_count       := NULL;
            l_msg_data        := NULL;
            l_return_status   := NULL;
            l_apply_amount    := NULL;
            IF l_inv_amount   <= cur_recpt_rec1 (idx2).claim_amount THEN
              l_apply_amount  := l_inv_amount;
            ELSE -- IF l_inv_amount <= cur_recpt_rec1 (idx2).claim_amount
              l_apply_amount :=cur_recpt_rec1 (idx2).claim_amount;
            END IF; -- IF l_inv_amount <= cur_recpt_rec1 (idx2).claim_amount
            l_num_tot_apply_amt := l_num_tot_apply_amt + l_apply_amount;
            l_stmt_processing   := ' Cheking Invoice Amount before calling API' ;
            l_chr_exe_location  :='INVAPP_035';
            write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
			dbms_output.put_line('Line amount : l_inv_amount : '||l_inv_amount);
            IF l_inv_amount <> 0 THEN
              write_debug( g_debug_flag , 'Start of Application '|| cur_inv_rec (idx).customer_trx_id);
			 dbms_output.put_line('Calling the STd program to apply invoice.');
              --ar_receipt_api_pub.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec (idx).customer_trx_id, p_cash_receipt_id => cur_recpt_rec1 (idx2).cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => TO_DATE( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data );  --Commented for Hotfix_199485 on 13-MAR-2019
       begin
	   dbms_output.put_line('Customer trx id : '||cur_inv_rec (idx).customer_trx_id||' Receipt id : '||cur_recpt_rec1 (idx2).cash_receipt_id||'Approval date:'||cur_inv_rec (idx).irt_approval_date);
	   ar_receipt_api_pub.APPLY (p_api_version => 1.0, 
							   p_init_msg_list => fnd_api.g_true, 
							   p_commit => fnd_api.g_false, 
							   p_validation_level => fnd_api.g_valid_level_full,
							   p_customer_trx_id => cur_inv_rec (idx).customer_trx_id,
							   p_cash_receipt_id => cur_recpt_rec1 (idx2).cash_receipt_id,
							   p_amount_applied => l_apply_amount, 
							   p_apply_date => TO_DATE( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), 
							   p_apply_gl_date => TO_DATE( cur_inv_rec (idx).irt_approval_date,
							   'DD-MON-RRRR'), x_return_status => l_return_status,
							   x_msg_count => l_msg_count, 
							   x_msg_data => l_msg_data ); --Added for Hotfix_199485 on 13-MAR-2019							   
							    dbms_output.put_line('ar_receipt_api_pub.APPLY return status :'||l_return_status||' msg data: '||l_msg_data||' msg count'||l_msg_count);
							   exception
							   when others then
							   dbms_output.put_line('ar_receipt_api_pub.APPLY exception :'||SQLERRM);
							   END;
              IF l_return_status    = 'S' THEN
                l_stmt_processing  := ' Status of the API Call is Success';
                l_chr_exe_location :='INVAPP_036';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                write_debug( g_debug_flag , 'Receipt Number : ' || cur_recpt_rec1 (idx2).receipt_number || ' - Assmt Year :' || cur_recpt_rec1 (idx2).assmt_year || ' - Receipt Date : ' || cur_recpt_rec1 (idx2).receipt_date );
                write_debug( g_debug_flag , ' Status for apply invoice amount ' || l_apply_amount || ' to Receipt Number : ' || cur_recpt_rec1 (idx2).receipt_number || ' - ' || l_return_status );
                l_stmt_processing  := ' Updating the Rcpt Remaining amount in Glb_attribute10 ';
                l_chr_exe_location :='INVAPP_036';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                --                remaining_amt := l_inv_amount -
                -- l_apply_amount;
                --
                -- TO update the claim amount
                --
                SELECT TO_NUMBER (arc.global_attribute10) - l_apply_amount
                INTO remaining_amt
                FROM ar_cash_receipts_all arc
                WHERE arc.cash_receipt_id =cur_recpt_rec1 (idx2).cash_receipt_id;
                write_debug( g_debug_flag ,'remaining_amt' ||' - ' || remaining_amt );
                UPDATE ar_cash_receipts_all arc
                SET arc.global_attribute10 = TO_NUMBER (arc.global_attribute10) - l_apply_amount
                WHERE arc.cash_receipt_id  =cur_recpt_rec1 (idx2).cash_receipt_id;
                l_stmt_processing         := ' Updating the status of receipt to Calimed if applied full';
                l_chr_exe_location        :='INVAPP_036';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                --
                --To Update the Receipt Flag = 'CLAIMED' once receipt amount =
                -- 0 for matched receipts
                --
                UPDATE ar_cash_receipts_all arc
                SET arc.attribute15                    = 'CLAIMED'
                WHERE arc.cash_receipt_id              = cur_recpt_rec1 (idx2).cash_receipt_id
                AND arc.attribute15                    = 'MATCHED'
                AND TO_NUMBER (arc.global_attribute10) = 0;
                write_debug( g_debug_flag ,'Number of rows updated 34: '|| sql%rowcount );
                l_stmt_processing  := ' Updating the Invoice status to 0 is amt_due_reamin is 0';
                l_chr_exe_location :='INVAPP_037';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                --
                -- To Update the Status = 'CLOSED' once the invoice amount = 0
                --
                UPDATE ra_customer_trx_all rat
                SET rat.attribute9        = 'PCM CLOSED'
                WHERE rat.customer_trx_id =
                  (SELECT customer_trx_id
                  FROM ar_payment_schedules_all
                  WHERE customer_trx_id    =cur_inv_rec (idx).customer_trx_id
                  AND payment_schedule_id  = cur_inv_rec (idx) .payment_schedule_id
                  AND status               = 'CL'
                  AND amount_due_remaining = 0
                  AND CLASS                = 'INV'
                  );
                l_inv_amount := l_inv_amount - l_apply_amount;
                EXIT
              WHEN l_inv_amount = 0;
              ELSE -- IF l_return_status = 'S'
                l_stmt_processing  := ' Status of Receipt Call is Failure';
                l_chr_exe_location :='INVAPP_038';
                write_msg( g_write_logfile ,l_chr_exe_location ||' - ' || l_stmt_processing );
                write_msg( g_write_logfile , 'Status for apply invoice number ' || cur_inv_rec (idx).trx_number || ' for amount Rs ' || l_apply_amount || ' to Receipt Number : ' || cur_recpt_rec1 ( idx2).receipt_number || ' is ' || l_return_status || ' ' || l_msg_data );
                IF l_msg_count > 1 THEN
                  FOR i IN 1 .. l_msg_count
                  LOOP
                    p_out_chr_errbuff := p_out_chr_errbuff ||i|| '. '|| SUBSTR( fnd_msg_pub.get (p_encoded => fnd_api.g_false),1,355);
                  END LOOP; -- FOR i IN 1 .. l_msg_count
                  write_msg( g_write_logfile,p_out_chr_errbuff );
                ELSE
                  p_out_chr_errbuff := l_msg_data;
                END IF; -- IF l_msg_count >= 1
                l_stmt_processing  := ' Printed the Error details above of Receipt APi and returning back parent call' ;
                l_chr_exe_location :='INVAPP_039';
                write_msg( g_write_logfile, l_chr_exe_location ||'-'|| l_stmt_processing );
                p_out_chr_retcode := g_chr_failure_code;
                RAISE CUSTOM_EXCEPTION;
                RETURN;
              END IF; -- IF l_return_status = 'S'
            END IF;   -- IF l_inv_amount <> 0
          END LOOP;   -- FOR idx2 IN cur_recpt_rec1.FIRST ..
          -- cur_recpt_rec1.LAST
          cur_recpt_rec1.DELETE;
        END LOOP; -- OPEN cur_recpt (cur_inv_rec (idx).customer_number
        CLOSE cur_recpt;
        write_debug( g_debug_flag , 'l_num_tot_apply_amt:'|| l_num_tot_apply_amt);
        write_debug( g_debug_flag , ' cur_inv_rec.global_attribute2:'|| cur_inv_rec(idx).global_attribute2);
        l_stmt_processing  := ' Checking Receipt Flag ';
        l_chr_exe_location :='INVAPP_040';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        IF (l_receipt_avl_flg = 'Y') THEN
          l_stmt_processing  := ' Updating the att15 to Refd CrossMjr in Process, if any Unapplied receipt found' ;
          l_chr_exe_location :='INVAPP_041';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          UPDATE ar_cash_receipts_all acr
          SET acr.attribute15        = 'REFD CROSSMAJOR IN PROCESS'
          WHERE acr.cash_receipt_id IN
            (SELECT arc.cash_receipt_id
            FROM ar_cash_receipts_all arc
            WHERE TO_NUMBER (arc.global_attribute10) > 0
            AND arc.attribute5                       =cur_inv_rec (idx) .customer_number
            AND TO_NUMBER (arc.attribute4)          <=TO_NUMBER (cur_inv_rec (idx) .assmt_year)
            AND arc.attribute15                      = 'MATCHED'
            AND arc.attribute12                      =cur_inv_rec (idx).irt_id
            AND arc.attribute1                       =cur_inv_rec (idx).major_head
            AND arc.status                           = 'UNAPP'
            AND arc.attribute2                      IN ('100', '200', '300','PMR','SPI','5A','OTH') -- Added Major Head 'PMR' as part of CR#0653  --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
            /*AND arc.cash_receipt_id                 IN
              (SELECT FAS_ID
              FROM IRT_MATCHING.IRT_CLAIMS_MATCHING icm
              WHERE icm.IRT_ID         =to_number(arc.attribute12)
              AND icm.SCHEDULE_TYPE_TXT=cur_inv_rec (idx).schedule_type
              AND NVL(MATCHED_AMT,0)   >0
              )*/  --commented IRT_MATCHING.IRT_CLAIMS_MATCHING table in ABC-2.0 - Bhagya
            );
          write_debug( g_debug_flag ,'Updating ARC for 115TD' ||'-'||sql%rowcount );          
          write_debug( g_debug_flag ,'Updating ARC' ||'-'||sql%rowcount );
          l_stmt_processing  := ' Updating the att9 to Dmd as an Open Payment Schedule found';
          l_chr_exe_location :='INVAPP_042';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          UPDATE ra_customer_trx_all rat
          SET rat.attribute9 = 'DMD',
            rat.attribute12  =
            (SELECT ABS (amount_due_remaining)
            FROM ar_payment_schedules_all
            WHERE customer_trx_id = rat.customer_trx_id
            )
          WHERE rat.customer_trx_id =
            (SELECT customer_trx_id
            FROM ar_payment_schedules_all
            WHERE customer_trx_id =cur_inv_rec (idx).customer_trx_id
            AND status            = 'OP'
            AND CLASS             = 'INV'
            )
          AND trx_number = cur_inv_rec (idx) .trx_number; -- Added for CR - 661
          write_debug( g_debug_flag ,'No. of rows updated4452: '||sql%rowcount);
        ELSIF (l_receipt_avl_flg = 'N') THEN
          l_stmt_processing     := ' Receipt Flag is N, Updating the att9 to Dmd as an Open Payment Schedule found' ;
          l_chr_exe_location    :='INVAPP_043';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          UPDATE ra_customer_trx_all rat
          SET rat.attribute9 = 'DMD',
            rat.attribute12  =
            (SELECT ABS (amount_due_remaining)
            FROM ar_payment_schedules_all
            WHERE customer_trx_id = rat.customer_trx_id
            )
          WHERE rat.customer_trx_id =
            (SELECT customer_trx_id
            FROM ar_payment_schedules_all
            WHERE customer_trx_id =cur_inv_rec (idx).customer_trx_id
            AND status            = 'OP'
            AND CLASS             = 'INV'
            )
          AND trx_number = cur_inv_rec (idx) .trx_number; -- Added for CR - 661
          write_debug( g_debug_flag ,'No. of rows updated4453: '||sql%rowcount);
        END IF; -- ELSIF (l_receipt_avl_flg = 'N')
        --added for CR_661 on 31-Jan-2019--start---
      ELSIF ( ( cur_inv_rec (idx).major_head = '0020' AND cur_inv_rec (idx) .schedule_type = '115TD') OR ( cur_inv_rec (idx).major_head = '0021' AND cur_inv_rec (idx) .schedule_type = '115TD') ) THEN -- Added v_irt_Schd_type for CR -- 661
        l_stmt_processing                   := ' Start Processing for 115TD and FBT ';
        l_chr_exe_location                  :='INVAPP_028';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_tot_apply_amt := 0;
        l_num_claim_amt     :=0;

        BEGIN
          SELECT NVL(SUM(GLOBAL_ATTRIBUTE10), 0)
          INTO l_num_claim_amt
          FROM AR_CASH_RECEIPTS_ALL ARC
          WHERE ATTRIBUTE12 = cur_inv_rec(idx).irt_id
          AND ATTRIBUTE1    = cur_inv_rec(idx).major_head
          AND ATTRIBUTE15  IN ('MATCHED','PARTIALLY MATCHED','SPI PARTIALLY MATCHED')
            --AND attribute2                IN ( '100', '200', '300', 'XCL','PMR','SPI','5A','OTH') -- Added Major Head 'PMR' as part of CR#0653 --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
          AND attribute2          IN ( '100','300')
          /*AND ARC.CASH_RECEIPT_ID IN
            (SELECT FAS_ID
            FROM IRT_MATCHING.IRT_CLAIMS_MATCHING
            WHERE IRT_ID          = TO_NUMBER(ARC.ATTRIBUTE12)
            AND SCHEDULE_TYPE_TXT = cur_inv_rec(idx).schedule_type
            )
          HAVING NVL(SUM(ARC.GLOBAL_ATTRIBUTE10),0) =
            (SELECT NVL(SUM(MATCHED_AMT),0)
            FROM IRT_MATCHING.IRT_CLAIMS_MATCHING
            WHERE IRT_ID          = TO_NUMBER(ARC.ATTRIBUTE12)
            AND SCHEDULE_TYPE_TXT = cur_inv_rec(idx).schedule_type
            )*/
			--commented IRT_MATCHING.IRT_CLAIMS_MATCHING table in ABC-2.0 - Bhagya
          GROUP BY ARC.ATTRIBUTE12; -- Added for CR - 661 on 12-MAR-2019
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          l_num_claim_amt := 0;
        END;
        l_stmt_processing  := ' Getting Sum of Claim Amount for IT and FBT values for IRT';
        l_chr_exe_location :='INVAPP_029';
        write_debug( g_debug_flag ,l_stmt_processing ||' - ' || l_num_claim_amt );
        write_debug( g_debug_flag ,'cur_inv_rec.global_attribute2:' || cur_inv_rec(idx).global_attribute2);
        IF l_num_claim_amt   <> TO_NUMBER (cur_inv_rec(idx).global_attribute2) THEN
          l_stmt_processing  := ' Claim Amount and global_Attribute2 not equal checking for Hold';
          l_chr_exe_location :='INVAPP_030';
          write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
          SELECT COUNT('x')
          INTO l_ins_chk
          FROM xx_irt_fas_prcsng_hold
          WHERE irt_id          = cur_inv_rec(idx).irt_id
          AND hold_flag         = 'IRT CLAIM HOLD'
          AND release_flag     IS NULL;
          IF l_ins_chk          = 0 THEN
            l_stmt_processing  := ' Putting a Claim Hold entry in the fas Hold Table ';
            l_chr_exe_location :='INVAPP_032';
            write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
            INSERT
            INTO xx_irt_fas_prcsng_hold
              (
                irt_id,
                id,
                ay,
                hold_flag,
                creation_date,
                last_update_date,
                matched_amount, --Added for Hotfix 146632
                claimed_amount  --Added for Hotfix 146632
              )
              VALUES
              (
                cur_inv_rec(idx).irt_id,
                cur_inv_rec(idx).customer_number,
                cur_inv_rec(idx).assmt_year,
                'IRT CLAIM HOLD',
                SYSDATE,
                SYSDATE,
                l_num_claim_amt,                   --Added for Hotfix 146632
                cur_inv_rec(idx).global_attribute2 --Added for Hotfix 146632
              );
          END IF; -- IF l_ins_chk = 0
        END IF;   -- IF L_NUM_CLAIM_AMT <> TO_NUMBER (cur_inv_rec(idx)
        -- .global_attribute2)
        l_stmt_processing  := ' Open cursor to Fetch Receipt for the IRT';
        l_chr_exe_location :='INVAPP_033';
        write_debug ( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing ) ;
        OPEN cur_recpt (
        --cur_inv_rec (idx).customer_number, cur_inv_rec (idx).assmt_year, cur_inv_rec (idx).major_head, '100', '200', '300', 'XCL','PMR','SPI','5A','OTH', cur_inv_rec (idx).irt_id ---- Added Major Head 'PMR' as part of CR#0653  --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2--commented for CR_661 on 31-Jan-2019
        cur_inv_rec (idx).customer_number, cur_inv_rec (idx).assmt_year, cur_inv_rec (idx).major_head, '100', NULL, '300', NULL,NULL,NULL,NULL,NULL, cur_inv_rec (idx).irt_id, cur_inv_rec(idx).schedule_type ---- Added Major Head 'PMR' as part of CR#0653  --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2 --added for CR_661 on 31-Jan-2019
        ) ;
        LOOP
          FETCH cur_recpt BULK COLLECT INTO cur_recpt_rec1 LIMIT 500;
          --use a variable for the LIMIT
          EXIT
        WHEN cur_recpt_rec1.COUNT = 0;
          l_stmt_processing      := ' Pick Receipt to Apply from bulk rec type ';
          l_chr_exe_location     :='INVAPP_034';
          write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
          FOR idx2 IN cur_recpt_rec1.FIRST .. cur_recpt_rec1.LAST
          LOOP
            g_rcpt_cnt        := g_rcpt_cnt +1;
            l_receipt_avl_flg := 'Y';
            l_msg_count       := NULL;
            l_msg_data        := NULL;
            l_return_status   := NULL;
            l_apply_amount    := NULL;
            IF l_inv_amount   <= cur_recpt_rec1 (idx2).claim_amount THEN
              l_apply_amount  := l_inv_amount;
            ELSE -- IF l_inv_amount <= cur_recpt_rec1 (idx2).claim_amount
              l_apply_amount :=cur_recpt_rec1 (idx2).claim_amount;
            END IF; -- IF l_inv_amount <= cur_recpt_rec1 (idx2).claim_amount
            l_num_tot_apply_amt := l_num_tot_apply_amt + l_apply_amount;
            l_stmt_processing   := ' Cheking Invoice Amount before calling API' ;
            l_chr_exe_location  :='INVAPP_035';
            write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
            IF l_inv_amount <> 0 THEN
              write_debug( g_debug_flag , 'Start of Application '|| cur_inv_rec (idx).customer_trx_id);
              --ar_receipt_api_pub.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec (idx).customer_trx_id, p_cash_receipt_id => cur_recpt_rec1 (idx2).cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => TO_DATE( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data );  --Commented for Hotfix_199485 on 13-MAR-2019
              ar_receipt_api_pub.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec (idx).customer_trx_id, p_cash_receipt_id => cur_recpt_rec1 (idx2).cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => TO_DATE( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), p_apply_gl_date => TO_DATE( cur_inv_rec (idx).irt_approval_date, 'DD-MON-RRRR'), x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data ); --Added for Hotfix_199485 on 13-MAR-2019
              IF l_return_status    = 'S' THEN
                l_stmt_processing  := ' Status of the API Call is Success';
                l_chr_exe_location :='INVAPP_036';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                write_debug( g_debug_flag , 'Receipt Number : ' || cur_recpt_rec1 (idx2).receipt_number || ' - Assmt Year :' || cur_recpt_rec1 (idx2).assmt_year || ' - Receipt Date : ' || cur_recpt_rec1 (idx2).receipt_date );
                write_debug( g_debug_flag , ' Status for apply invoice amount ' || l_apply_amount || ' to Receipt Number : ' || cur_recpt_rec1 (idx2).receipt_number || ' - ' || l_return_status );
                l_stmt_processing  := ' Updating the Rcpt Remaining amount in Glb_attribute10 ';
                l_chr_exe_location :='INVAPP_036';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                --                remaining_amt := l_inv_amount -
                -- l_apply_amount;
                --
                -- TO update the claim amount
                --
                SELECT TO_NUMBER (arc.global_attribute10) - l_apply_amount
                INTO remaining_amt
                FROM ar_cash_receipts_all arc
                WHERE arc.cash_receipt_id =cur_recpt_rec1 (idx2).cash_receipt_id;
                write_debug( g_debug_flag ,'remaining_amt' ||' - ' || remaining_amt );
                UPDATE ar_cash_receipts_all arc
                SET arc.global_attribute10 = TO_NUMBER (arc.global_attribute10) - l_apply_amount
                WHERE arc.cash_receipt_id  =cur_recpt_rec1 (idx2).cash_receipt_id;
                l_stmt_processing         := ' Updating the status of receipt to Calimed if applied full';
                l_chr_exe_location        :='INVAPP_036';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                --
                --To Update the Receipt Flag = 'CLAIMED' once receipt amount =
                -- 0 for matched receipts
                --
                UPDATE ar_cash_receipts_all arc
                SET arc.attribute15                    = 'CLAIMED'
                WHERE arc.cash_receipt_id              = cur_recpt_rec1 (idx2).cash_receipt_id
                AND arc.attribute15                    = 'MATCHED'
                AND TO_NUMBER (arc.global_attribute10) = 0;
                write_debug( g_debug_flag ,'Number of rows updated 34: '|| sql%rowcount );
                l_stmt_processing  := ' Updating the Invoice status to 0 is amt_due_reamin is 0';
                l_chr_exe_location :='INVAPP_037';
                write_debug( g_debug_flag ,l_chr_exe_location ||' - ' || l_stmt_processing );
                --
                -- To Update the Status = 'CLOSED' once the invoice amount = 0
                --
                UPDATE ra_customer_trx_all rat
                SET rat.attribute9        = 'PCM CLOSED'
                WHERE rat.customer_trx_id =
                  (SELECT customer_trx_id
                  FROM ar_payment_schedules_all
                  WHERE customer_trx_id    =cur_inv_rec (idx).customer_trx_id
                  AND payment_schedule_id  = cur_inv_rec (idx) .payment_schedule_id
                  AND status               = 'CL'
                  AND amount_due_remaining = 0
                  AND CLASS                = 'INV'
                  );
                l_inv_amount := l_inv_amount - l_apply_amount;
                EXIT
              WHEN l_inv_amount = 0;
              ELSE -- IF l_return_status = 'S'
                l_stmt_processing  := ' Status of Receipt Call is Failure';
                l_chr_exe_location :='INVAPP_038';
                write_msg( g_write_logfile ,l_chr_exe_location ||' - ' || l_stmt_processing );
                write_msg( g_write_logfile , 'Status for apply invoice number ' || cur_inv_rec (idx).trx_number || ' for amount Rs ' || l_apply_amount || ' to Receipt Number : ' || cur_recpt_rec1 ( idx2).receipt_number || ' is ' || l_return_status || ' ' || l_msg_data );
                IF l_msg_count > 1 THEN
                  FOR i IN 1 .. l_msg_count
                  LOOP
                    p_out_chr_errbuff := p_out_chr_errbuff ||i|| '. '|| SUBSTR( fnd_msg_pub.get (p_encoded => fnd_api.g_false),1,355);
                  END LOOP; -- FOR i IN 1 .. l_msg_count
                  write_msg( g_write_logfile,p_out_chr_errbuff );
                ELSE
                  p_out_chr_errbuff := l_msg_data;
                END IF; -- IF l_msg_count >= 1
                l_stmt_processing  := ' Printed the Error details above of Receipt APi and returning back parent call' ;
                l_chr_exe_location :='INVAPP_039';
                write_msg( g_write_logfile, l_chr_exe_location ||'-'|| l_stmt_processing );
                p_out_chr_retcode := g_chr_failure_code;
                RAISE CUSTOM_EXCEPTION;
                RETURN;
              END IF; -- IF l_return_status = 'S'
            END IF;   -- IF l_inv_amount <> 0
          END LOOP;   -- FOR idx2 IN cur_recpt_rec1.FIRST ..
          -- cur_recpt_rec1.LAST
          cur_recpt_rec1.DELETE;
        END LOOP; -- OPEN cur_recpt (cur_inv_rec (idx).customer_number
        CLOSE cur_recpt;
        write_debug( g_debug_flag , 'l_num_tot_apply_amt:'|| l_num_tot_apply_amt);
        write_debug( g_debug_flag , ' cur_inv_rec.global_attribute2:'|| cur_inv_rec(idx).global_attribute2);
        l_stmt_processing  := ' Checking Receipt Flag ';
        l_chr_exe_location :='INVAPP_040';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        IF (l_receipt_avl_flg = 'Y') THEN
          l_stmt_processing  := ' Updating the att15 to Refd CrossMjr in Process, if any Unapplied receipt found' ;
          l_chr_exe_location :='INVAPP_041';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          --added while testing 115TD--start--
          FOR j IN
          (SELECT arc.attribute15 attribute15,
            arc.GLOBAL_ATTRIBUTE10 GLOBAL_ATTRIBUTE10,
            arc.status status,
            arc.attribute2 attribute2,
            arc.CASH_RECEIPT_ID CASH_RECEIPT_ID,
            arc.RECEIPT_NUMBER RECEIPT_NUMBER
          FROM ar_cash_receipts_all arc
          WHERE arc.attribute5           =cur_inv_rec (idx) .customer_number
          AND TO_NUMBER (arc.attribute4) =TO_NUMBER (cur_inv_rec (idx) .assmt_year)
          AND arc.attribute12            =cur_inv_rec (idx).irt_id
          AND arc.attribute1             =cur_inv_rec (idx).major_head
          ORDER BY arc.attribute12
          )
          LOOP
            write_msg( g_write_logfile ,'j.attribute15: ' ||j.attribute15 );
            write_msg( g_write_logfile ,'j.GLOBAL_ATTRIBUTE10: '||j.GLOBAL_ATTRIBUTE10 );
            write_msg( g_write_logfile ,'j.status: '||j.status );
            write_msg( g_write_logfile ,'j.attribute2: '||j.attribute2 );
            write_msg( g_write_logfile ,'j.CASH_RECEIPT_ID: '||j.CASH_RECEIPT_ID );
            write_msg( g_write_logfile ,'j.RECEIPT_NUMBER: '||j.RECEIPT_NUMBER );
          END LOOP;
          --added while testing 115TD--end--
          UPDATE ar_cash_receipts_all acr
          SET acr.attribute15        = 'REFD CROSSMAJOR IN PROCESS'
          WHERE acr.cash_receipt_id IN
            (SELECT arc.cash_receipt_id
            FROM ar_cash_receipts_all arc
            WHERE TO_NUMBER (arc.global_attribute10) > 0
            AND arc.attribute5                       =cur_inv_rec (idx) .customer_number
            AND TO_NUMBER (arc.attribute4)           =TO_NUMBER (cur_inv_rec (idx) .assmt_year)
            AND arc.attribute15                      = 'MATCHED'
            AND arc.attribute12                      =cur_inv_rec (idx).irt_id
            AND arc.attribute1                       =cur_inv_rec (idx).major_head
            AND arc.status                           = 'UNAPP'
              --AND arc.attribute2                      IN ('100', '200', '300','PMR','SPI','5A','OTH') -- Added Major Head 'PMR' as part of CR#0653  --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2--commented for CR_661 on 31-Jan-2019
            AND arc.attribute2 IN ( '100','300') --added for CR_661 on 31-Jan-2019
            );
          write_debug( g_debug_flag ,'Updating ARC' ||'-'||sql%rowcount );
          l_stmt_processing  := ' Updating the att9 to Dmd as an Open Payment Schedule found';
          l_chr_exe_location :='INVAPP_042';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          UPDATE ra_customer_trx_all rat
          SET rat.attribute9 = 'DMD',
            rat.attribute12  =
            (SELECT ABS (amount_due_remaining)
            FROM ar_payment_schedules_all
            WHERE customer_trx_id = rat.customer_trx_id
            )
          WHERE rat.customer_trx_id =
            (SELECT customer_trx_id
            FROM ar_payment_schedules_all
            WHERE customer_trx_id =cur_inv_rec (idx).customer_trx_id
            AND status            = 'OP'
            AND CLASS             = 'INV'
            )
          AND trx_number         = cur_inv_rec (idx) .trx_number ;-- Added for CR - 661
        ELSIF (l_receipt_avl_flg = 'N') THEN
          l_stmt_processing     := ' Receipt Flag is N, Updating the att9 to Dmd as an Open Payment Schedule found' ;
          l_chr_exe_location    :='INVAPP_043';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          UPDATE ra_customer_trx_all rat
          SET rat.attribute9 = 'DMD',
            rat.attribute12  =
            (SELECT ABS (amount_due_remaining)
            FROM ar_payment_schedules_all
            WHERE customer_trx_id = rat.customer_trx_id
            )
          WHERE rat.customer_trx_id =
            (SELECT customer_trx_id
            FROM ar_payment_schedules_all
            WHERE customer_trx_id =cur_inv_rec (idx).customer_trx_id
            AND status            = 'OP'
            AND CLASS             = 'INV'
            )
          AND trx_number = cur_inv_rec (idx) .trx_number; -- Added for CR - 661
        END IF;                                           -- ELSIF (l_receipt_avl_flg = 'N')
        --added for CR_661 on 31-Jan-2019--end---
      END IF; -- ELSIF ( ( cur_inv_rec (idx).major_head = '0020'
      FOR i IN
      (SELECT ABS (arp.amount_due_remaining) remaining_amt ,
        rat.attribute7 schedule_type ,
        rat.attribute11 irt_id ,
        rat.global_attribute2 global_attribute2,
        rat.attribute9 attribute9,
        arp.status status
      FROM ra_customer_trx_all rat ,
        ar_payment_schedules_all arp
      WHERE rat.customer_trx_id           = arp.customer_trx_id
      AND rat.interface_header_attribute1 = p_in_irt_id
        --    AND rat.attribute9                  = 'NEW'
        --    AND arp.status                      = 'OP'
      AND rat.attribute4 IS NOT NULL
      AND rat.attribute5 IS NOT NULL
      AND rat.attribute1 IS NOT NULL
        --    AND arp.amount_due_remaining       <> 0
      ORDER BY TO_NUMBER (rat.attribute4),
        TO_NUMBER (rat.attribute1) ASC,
        rat.attribute7 DESC
      )
      LOOP
        write_msg( g_write_logfile ,'v_remaining_amt: '||i.remaining_amt );
        write_msg( g_write_logfile ,'v_irt_sch_type: '||i.schedule_type );
        write_msg( g_write_logfile ,'v_irt_id: '||i.irt_id );
        write_msg( g_write_logfile ,'v_glob2: '||i.global_attribute2 );
        write_msg( g_write_logfile ,'v_att9: '||i.attribute9 );
        write_msg( g_write_logfile ,'v_arp_status: '||i.status );

		dbms_output.put_line('v_remaining_amt: '||i.remaining_amt );
        dbms_output.put_line('v_irt_sch_type: '||i.schedule_type );
        dbms_output.put_line('v_irt_id: '||i.irt_id );
        dbms_output.put_line('v_glob2: '||i.global_attribute2 );
        dbms_output.put_line('v_att9: '||i.attribute9 );
        dbms_output.put_line('v_arp_status: '||i.status );
      END LOOP;
    END LOOP; -- FOR idx IN cur_inv_rec.FIRST .. cur_inv_rec.LAST
    cur_inv_rec.DELETE;
  END LOOP; -- OPEN cur_inv(p_in_irt_id)
  CLOSE cur_inv;
  write_debug( g_debug_flag, '-----------------------------------------------------------------------------------' );
  write_debug( g_debug_flag , '*** APPS. Apply Invoice to Receipts Program - ENDS ***');
  write_debug( g_debug_flag, '----------------------------------------------------------------------------------' );
EXCEPTION
WHEN CUSTOM_EXCEPTION THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name || '-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || p_out_chr_errbuff;
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  dbms_output.put_line('Error: '||p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name || '-' ||l_chr_errbuff );
    END IF;
  END IF;
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := ' Unexpected Error -' || l_chr_proc_name || ' - ' || l_chr_exe_location || ' - ' || l_stmt_processing || ' - ' || SUBSTR(sqlerrm,1 ,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff);
  dbms_output.put_line('Error: '||p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff);
    END IF;
  END IF;
END inv_apply;
-- ***************** End of Function / Procedure **********************--
PROCEDURE Prior_refd_receipt_adjust(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_id_num  IN VARCHAR2,
    p_in_irt_id   IN VARCHAR2,
    p_in_rrd_call IN VARCHAR2 DEFAULT NULL --added for CR_HWSW_102
  )
AS
  /****************************************************************************
  *********
  * Type : Procedure
  * Name : Prior_refd_receipt_adjust
  * Input Parameters : None
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : Procedure for Prior Refd Receivable Adjustment
  Program added as a part of revctification solution
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 10-Jan-2012
  * Last Reviewed By :
  * Last Reviewed Date :
  *****************************************************************************
  *********
  * Modified Date Modified By Version Modification Type Modification Details
  * ------------- ------------ -------- -----------------
  --------------------------
  *.10-Jan-2012 Infosys 1.0 Base Version
  *****************************************************************************
  **********/
  --
  -- User defined exception for Commit with Warning
  --
  l_inv_amount       NUMBER;
  l_apply_amount     NUMBER;
  l_msg_count        NUMBER;
  l_msg_index_out    NUMBER;
  l_msg_data         VARCHAR2 (5000);
  l_return_status    VARCHAR2 (1);
  x_msg_data         VARCHAR2 (2000);
  l_stmt_processing  VARCHAR2 (200);
  l_chr_proc_name    VARCHAR2(50) :='Prior_refd_receipt_adjust';
  l_chr_exe_location VARCHAR2(50) :='';
  l_chr_errbuff      VARCHAR2 (5000);
  l_chr_retcode      VARCHAR2 (10);
  custom_exception   EXCEPTION;
  l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
  v_refdem_amt_400_cnt NUMBER := 0; --added for hotfix: 40077
  v_refdem_amt_400     NUMBER;      --added for hotfix: 40077
  --Cursor Declaration
  -- Cursor to Fetch the all the refd records with status PCM APPROVED
  CURSOR cur_cmajor_inv( p_id_num VARCHAR2)
  IS
    SELECT *
    FROM
      ( SELECT DISTINCT rat.attribute5 customer_number,
        rat.attribute4 assmt_year
      FROM ra_customer_trx_all rat ,
        xx_refd_headers head
      WHERE rat.attribute9         = 'RR REF DEM PADJ'
      AND head.refd_status       = 'PCM APPROVED'
      AND head.id_number          = rat.attribute5
      AND head.irt_ay              = rat.attribute4
      AND head.total_refd_amount > 0
      AND head.id_number          = p_id_num
      AND p_in_rrd_call           IS NULL
      AND NOT EXISTS
        (SELECT 1
        FROM xx_400_rrd_int xri
        WHERE xri.customer_trx_id = rat.customer_trx_id
        AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
        )
    -- ORDER BY TO_NUMBER (rat.attribute4) ASC
    UNION --condition added for CR_HWSW_102 for RRD adjustment to happen
    --after 400 interest calculation if the RRD has 400 interest component
    SELECT DISTINCT rat.attribute5 customer_number,
      rat.attribute4 assmt_year
    FROM ra_customer_trx_all rat ,
      xx_refd_headers head
    WHERE rat.attribute9         = 'RR REF DEM PADJ'
    AND head.refd_status       = 'PCM APPROVED'
    AND head.id_number          = rat.attribute5
    AND head.irt_ay              = rat.attribute4
    AND head.total_refd_amount > 0
    AND head.id_number          = p_id_num
    AND p_in_rrd_call            = 'E400'
    AND EXISTS
      (SELECT 1
      FROM xx_400_rrd_int xri
      WHERE xri.customer_trx_id = rat.customer_trx_id
      AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
      )
      )
    ORDER BY TO_NUMBER (2) ASC;
    -- Cursor to Fetch Invoice which has amount due remaining > 0 for a
    -- specified
    -- ID and Assmt_year
    CURSOR cur_crossmajor_inv ( in_num_customer VARCHAR2, in_num_assmt_year VARCHAR2 )
    IS
      SELECT rat.customer_trx_id ,
        rat.trx_number ,
        rat.bill_to_customer_id ,
        rat.attribute4 assmt_year ,
        rat.attribute5 customer_number ,
        rat.attribute2 bank_account ,
        rat.attribute3 irt_approval_date ,
        ABS (arp.amount_due_remaining) amount_due_remaining ,
        rat.attribute1 major_head ,
        rat.attribute9 status,
        rat.attribute7 schedule_type,
        rat.attribute10 dmd_serv_date
      FROM ar_payment_schedules_all arp ,
        ra_customer_trx_all rat
      WHERE rat.attribute9    = 'RR REF DEM PADJ'
      AND arp.customer_trx_id = rat.customer_trx_id
      AND rat.attribute5      = in_num_customer
        --AND rat.attribute1 = in_num_major_head
      AND rat.attribute4                 = in_num_assmt_year
      AND rat.attribute10               IS NULL
      AND ABS (arp.amount_due_remaining) > 0
      ORDER BY TO_NUMBER (rat.attribute4),
        TO_NUMBER (rat.attribute1) ASC;
    -- Cursor to Fetch refd records where receipt UNAPPlied amount > 0
    -- ID and Assmt_year
    CURSOR cur_crossmajor_recpt ( in_num_customer VARCHAR2, in_num_assmt_year VARCHAR2 )
    IS
      SELECT line.cash_receipt_id ,
        (line.excess_receipt_amount + NVL (line.refd_roundoff_amount, 0) - NVL (line.refd_crossadjust_amount, 0) - NVL (line.rr_refdemadj_amount , 0) ) amount ,
        head.id_number ,
        line.receipt_date ,
        line.receipt_ay assmt_year ,
        ( line.excess_receipt_amount + NVL (line.refd_roundoff_amount, 0) - NVL (line.refd_crossadjust_amount, 0) - NVL (line.rr_refdemadj_amount , 0) ) claim_amount
      FROM xx_refd_headers head ,
        xx_refd_lines line
      WHERE head.refd_status                                                                                                                                 = 'PCM APPROVED'
      AND head.id_number                                                                                                                                      = in_num_customer
      AND head.irt_ay                                                                                                                                          = in_num_assmt_year
      AND line.reference_id                                                                                                                                    = head.reference_id
      AND ( line.excess_receipt_amount + NVL (line.refd_roundoff_amount, 0) - NVL (line.refd_crossadjust_amount, 0) - NVL ( line.rr_refdemadj_amount, 0) ) > 0
      ORDER BY line.reference_id,
        line.receipt_date,
        line.cash_receipt_id ASC;
  BEGIN -- main program
    p_out_chr_errbuff  := ' ';
    p_out_chr_retcode  := g_chr_success_code;
    l_stmt_processing  := ' Entering into Prior Refd Receipt Adjustment Rouitne';
    l_chr_exe_location :='PRRADJ001';
    write_debug( g_debug_flag , '---------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Prior Refd Receivable Adjustment Program - STARTS ***');
    write_debug( g_debug_flag , '----------------------------------------------------------------');
    l_stmt_processing  := ' RR Ref Dem Invoice INTERMEDIATE status update';
    l_chr_exe_location :='PRRADJ002';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- Updating the status of the invoice to RR RED DEM PADJ if any invoice for
    -- ID , ASsmt_year
    -- is Dmd or PCM CLOSED
    IF p_in_rrd_call IS NULL THEN -- For CR_HWSW_102
      UPDATE ra_customer_trx_all rat
      SET rat.attribute9   = 'RR REF DEM PADJ'
      WHERE rat.attribute9 = 'RR REF DEM'
      AND rat.attribute5   = p_in_id_num -- Included to restrict the update to
        -- selected ID
      AND EXISTS
        (SELECT 1
        FROM ra_customer_trx_all rat1
        WHERE rat1.attribute9 IN ('DMD', 'PCM CLOSED')
        AND rat1.attribute5    = rat.attribute5
        AND rat1.attribute4    = rat.attribute4
        )
      AND NOT EXISTS
        (SELECT 1
        FROM xx_400_rrd_int xri
        WHERE xri.customer_trx_id = rat.customer_trx_id
        AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
        );
      l_stmt_processing  := 'RR Ref Dem Invoice status update for no excess collections';
      l_chr_exe_location :='PRRADJ003';
      WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
      -- Updating the status of the invoice to Dmd if no refd records
      -- available
      UPDATE ra_customer_trx_all rat
      SET rat.attribute9   = 'DMD'
      WHERE rat.attribute9 = 'RR REF DEM PADJ'
      AND rat.attribute5   = p_in_id_num -- Included to restrict the update to
        -- selected ID
      AND NOT EXISTS
        (SELECT 1
        FROM xx_refd_headers head
        WHERE head.refd_status     = 'PCM APPROVED'
        AND head.id_number          = rat.attribute5
        AND head.irt_ay              = rat.attribute4
        AND head.total_refd_amount > 0
        )
      AND NOT EXISTS
        (SELECT 1
        FROM xx_400_rrd_int xri
        WHERE xri.customer_trx_id = rat.customer_trx_id
        AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
        );
    elsif p_in_rrd_call = 'E400' THEN
      UPDATE ra_customer_trx_all rat
      SET rat.attribute9 = 'RR REF DEM PADJ'
        -- WHERE rat.attribute9 = 'RR REF DEM' --Commented as a Part of
        -- Hotfix#113275
      WHERE rat.attribute9 IN ('RR REF DEM','THRESHOLD DMD IDENTIFIED') --
        -- Modified as a Part of Hotfix#113275
      AND rat.attribute5 = p_in_id_num -- Included to restrict the update to
        -- selected ID
      AND EXISTS
        (SELECT 1
        FROM ra_customer_trx_all rat1
          -- WHERE rat1.attribute9 IN ('DMD', 'PCM CLOSED','DMD
          -- IDENTIFIED','CLOSED') --Commented as a Part of Hotfix#113275
        WHERE rat1.attribute9 IN ('DMD', 'PCM CLOSED','DMD IDENTIFIED', 'CLOSED','THRESHOLD DMD IDENTIFIED') --Modified as a Part of
          -- Hotfix#113275
        AND rat1.attribute5 = rat.attribute5
        AND rat1.attribute4 = rat.attribute4
        )
      AND EXISTS
        (SELECT 1
        FROM xx_400_rrd_int xri
        WHERE xri.customer_trx_id = rat.customer_trx_id
        AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
        );
      l_stmt_processing  := 'RR Ref Dem Invoice status update for no excess collections';
      l_chr_exe_location :='PRRADJ003_01';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      write_debug( g_debug_flag , 'status updating to RR REF DEM PADJ PRRADJ003_002: '||sql%rowcount);
      -- Updating the status of the invoice to Dmd if no refd records
      -- available
      UPDATE ra_customer_trx_all rat
      SET rat.attribute9   = 'DMD'
      WHERE rat.attribute9 = 'RR REF DEM PADJ'
      AND rat.attribute5   = p_in_id_num -- Included to restrict the update to
        -- selected ID
      AND NOT EXISTS
        (SELECT 1
        FROM xx_refd_headers head
        WHERE head.refd_status     = 'PCM APPROVED'
        AND head.id_number          = rat.attribute5
        AND head.irt_ay              = rat.attribute4
        AND head.total_refd_amount > 0
        )
      AND EXISTS
        (SELECT 1
        FROM xx_400_rrd_int xri
        WHERE xri.customer_trx_id = rat.customer_trx_id
        AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
        );
      WRITE_DEBUG( G_DEBUG_FLAG ,'status updating to dmd PRRADJ003_02: '|| sql%rowcount);
    END IF;
    l_stmt_processing  := ' Opening For Loop of Main Cursor';
    l_chr_exe_location :='PRRADJ004';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    FOR cur_cmajor_inv_rec IN cur_cmajor_inv(p_in_id_num)
    LOOP
      l_stmt_processing  := 'Opening the Loop for Inv Cursor for ID ';
      l_chr_exe_location :='PRRADJ005';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || cur_cmajor_inv_rec.customer_number ||' ASSMT year ' || cur_cmajor_inv_rec.assmt_year);
      FOR cur_crossmajor_inv_rec IN cur_crossmajor_inv ( cur_cmajor_inv_rec.customer_number ,cur_cmajor_inv_rec.assmt_year )
      LOOP
        l_stmt_processing  := 'In Invoice Loop ';
        l_chr_exe_location :='PRRADJ006';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing) ;
        l_inv_amount := NULL;
        l_inv_amount := cur_crossmajor_inv_rec.amount_due_remaining;
        write_debug( g_debug_flag , '************');
        write_debug( g_debug_flag ,'Invoice number :'|| cur_crossmajor_inv_rec.trx_number);
        write_debug( g_debug_flag ,'Invoice Amount :'|| cur_crossmajor_inv_rec.amount_due_remaining);
        write_debug( g_debug_flag ,'Id Number :'|| cur_crossmajor_inv_rec.customer_number);
        write_debug( g_debug_flag ,'Assessment Year:'|| cur_crossmajor_inv_rec.assmt_year);
        write_debug( g_debug_flag ,'Major Head :'|| cur_crossmajor_inv_rec.major_head);
        write_debug( g_debug_flag ,'Schedule type :'|| cur_crossmajor_inv_rec.schedule_type);
        --
        -- Apply Invoice to receipt for current Assesment year
        --
        FOR cur_crossmajor_recpt_rec IN cur_crossmajor_recpt( cur_crossmajor_inv_rec.customer_number, cur_crossmajor_inv_rec.assmt_year )
        LOOP
          l_stmt_processing  := 'In the Loop for Receipt Cursor for ID ';
          l_chr_exe_location :='PRRADJ007';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_cmajor_inv_rec.customer_number || ' ASSMT year ' || cur_cmajor_inv_rec.assmt_year);
          l_msg_count      := NULL;
          l_msg_data       := NULL;
          l_return_status  := NULL;
          l_apply_amount   := NULL;
          IF l_inv_amount  <= cur_crossmajor_recpt_rec.claim_amount THEN
            l_apply_amount := l_inv_amount;
          ELSE -- IF l_inv_amount <= cur_crossmajor_recpt_rec.claim_amount
            l_apply_amount := cur_crossmajor_recpt_rec.claim_amount;
          END IF; -- IF l_inv_amount <= cur_crossmajor_recpt_rec.claim_amount
          l_stmt_processing  := 'Checking if Invoice Amount is <> 0 ';
          l_chr_exe_location :='PRRADJ008';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          IF l_inv_amount      <> 0 THEN
            l_stmt_processing  := 'Calling the Receipt Apply API ';
            l_chr_exe_location :='PRRADJ009';
			dbms_output.put_line('PRRADJ009');
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||' Invoice ' || cur_crossmajor_inv_rec.customer_trx_id ||' Receipt ' || cur_crossmajor_recpt_rec.cash_receipt_id );
            l_attribute_rec.attribute4 := 'PRIOR REFD ADJUSTED';
            --AR_RECEIPT_API_PUB.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_crossmajor_inv_rec.customer_trx_id, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_attribute_rec => l_attribute_rec, p_apply_date => TO_DATE (cur_crossmajor_inv_rec.irt_approval_date, 'DD-MON-RRRR' ), p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data );  --Commented for Hotfix_199485 on 13-MAR-2019
            AR_RECEIPT_API_PUB.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_crossmajor_inv_rec.customer_trx_id, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_attribute_rec => l_attribute_rec, p_apply_date => TO_DATE (cur_crossmajor_inv_rec.irt_approval_date, 'DD-MON-RRRR' ), p_apply_gl_date => TO_DATE (cur_crossmajor_inv_rec.irt_approval_date, 'DD-MON-RRRR' ), x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data ); --Added for Hotfix_199485 on 13-MAR-2019
            IF l_return_status    = 'S' THEN
              l_stmt_processing  := 'Receipt API status is Success ';
              l_chr_exe_location :='PRRADJ010';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing) ;
              write_debug( g_debug_flag ,' Receipt ID : ' || cur_crossmajor_recpt_rec.cash_receipt_id || ' - Assmt Year :' || cur_crossmajor_recpt_rec.assmt_year || ' - Receipt Date : ' || cur_crossmajor_recpt_rec.receipt_date );
              write_debug( g_debug_flag ,' Status for apply invoice amount ' || l_apply_amount || ' to Receipt Number : ' || cur_crossmajor_recpt_rec.cash_receipt_id || ' - ' || l_return_status );
              l_stmt_processing  := ' Updating Refd Ajustment Information ';
			  dbms_output.put_line(' Updating Refd Ajustment Information ');
              l_chr_exe_location :='PRRADJ011';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing) ;
              --
              -- TO update the receipt claim amount
              --
              UPDATE xx_refd_lines
              SET rr_refdemadj_amount =NVL (rr_refdemadj_amount, 0) + l_apply_amount
              WHERE cash_receipt_id   =cur_crossmajor_recpt_rec.cash_receipt_id;
              l_inv_amount           := l_inv_amount - l_apply_amount;
              IF l_inv_amount         = 0 THEN
                l_stmt_processing    := ' Closing the status of the Invoice as Inv amt is zero';
                l_chr_exe_location   :='PRRADJ012';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing) ;
                --
                -- To Update the Status = 'CLOSED' once the invoice amount = 0
                --
                UPDATE ra_customer_trx_all rat
                SET rat.attribute9        = 'PCM CLOSED'
                WHERE rat.customer_trx_id =cur_crossmajor_inv_rec.customer_trx_id;
              END IF; -- IF l_inv_amount = 0
              EXIT
            WHEN l_inv_amount = 0;
            ELSE -- IF l_return_status = 'S'
              write_debug( g_debug_flag , 'Status for apply invoice number ' || cur_crossmajor_inv_rec.trx_number || ' for amount Rs ' || l_apply_amount || ' to Receipt Number : ' || cur_crossmajor_recpt_rec.cash_receipt_id || ' is ' || l_return_status);
              IF l_msg_count > 1 THEN
                FOR i IN 1 .. l_msg_count
                LOOP
                  fnd_msg_pub.get(p_msg_index => -1, p_encoded => 'F', p_data => x_msg_data, p_msg_index_out => l_msg_index_out);
                  p_out_chr_errbuff := p_out_chr_errbuff ||' - ' || x_msg_data;
                END LOOP;
                write_msg( g_write_logfile,p_out_chr_errbuff );
              ELSE
                p_out_chr_errbuff := l_msg_data;
              END IF; --IF l_msg_count > 1
              l_stmt_processing  := ' Receipt API Status is Error';
              l_chr_exe_location :='PRRADJ013';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing) ;
              p_out_chr_retcode := g_chr_failure_code;
              RAISE CUSTOM_EXCEPTION;
              RETURN;
            END IF; --IF l_return_status = 'S'
          END IF;   -- IF l_inv_amount <> 0
        END LOOP;   -- FOR cur_crossmajor_recpt_rec IN
        l_stmt_processing  := ' Setting the Status of Invoice as Dmd as the payment sched is Open' ;
        l_chr_exe_location :='PRRADJ014';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing) ;
        UPDATE ra_customer_trx_all rat
        SET rat.attribute9        = 'DMD'
        WHERE rat.customer_trx_id =
          (SELECT customer_trx_id
          FROM ar_payment_schedules_all
          WHERE customer_trx_id =cur_crossmajor_inv_rec.customer_trx_id
          AND status            = 'OP'
          AND CLASS             = 'INV'
          );
      END LOOP; -- FOR cur_crossmajor_inv_rec IN cur_crossmajor_inv
    END LOOP;   -- FOR cur_cmajor_inv_rec IN cur_cmajor_inv
    l_stmt_processing  := ' ReComputing the refd Adjustment Amount ';
    l_chr_exe_location :='PRRADJ015';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing) ;
    -- RR Refd Dmd adjustment update
    IF p_in_rrd_call IS NULL -- this condition added for hotfix: 40077
      THEN
      UPDATE xx_refd_headers head
      SET head.rr_refdemadj_amount =
        (SELECT NVL (SUM (rr_refdemadj_amount), 0)
        FROM xx_refd_lines
        WHERE reference_id = head.reference_id
        )
      WHERE head.refd_status = 'PCM APPROVED'
      AND head.id_number      = p_in_id_num;
      l_stmt_processing       := ' ReComputing the Total refd Amount ';
      l_chr_exe_location      :='PRRADJ016';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing) ;
      UPDATE xx_refd_headers head
      SET head.total_refd_amount = head.total_refd_amount - head.rr_refdemadj_amount
      WHERE head.refd_status     = 'PCM APPROVED'
      AND head.id_number          = p_in_id_num;
      write_msg( g_write_logfile , 'No of rows updated: '||sql%rowcount);
    END IF;
    IF p_in_rrd_call = 'E400' -- this condition added for hotfix: 40077
      THEN
      BEGIN
        FOR j IN
        (SELECT rr_refdemadj_amount,
          reference_id
        FROM xx_REFD_HEADERS
        WHERE refd_status = 'PCM APPROVED'
        AND id_number      = p_in_id_num
        )
        LOOP
          v_refdem_amt_400               := NULL;
          IF NVL(j.rr_refdemadj_amount,0) > 0 THEN
            SELECT COUNT(1)
            INTO v_refdem_amt_400_cnt
            FROM xx_refd_lines xrl,
              xx_refd_headers xrh
            WHERE xrl.reference_id  = xrh.reference_id
            AND xrh.refd_status   = 'PCM APPROVED'
            AND xrh.id_number      = p_in_id_num
            AND xrh.reference_id    = j.reference_id
            AND xrl.minor_head     IN ('400','IRF4');
            IF v_refdem_amt_400_cnt > 0 THEN
              UPDATE xx_refd_headers head
              SET head.rr_refdemadj_amount =
                (SELECT NVL (SUM (rr_refdemadj_amount), 0)
                FROM xx_refd_lines
                WHERE reference_id = head.reference_id
                )
              WHERE head.refd_status = 'PCM APPROVED'
              AND head.id_number      = p_in_id_num
              AND head.reference_id    = j.reference_id;
              SELECT NVL (SUM (xrl.rr_refdemadj_amount), 0)
              INTO v_refdem_amt_400
              FROM xx_refd_lines xrl,
                xx_refd_headers xrh
              WHERE xrl.reference_id = xrh.reference_id
              AND xrh.refd_status  = 'PCM APPROVED'
              AND xrh.id_number     = p_in_id_num
              AND xrh.reference_id   = j.reference_id
              AND xrl.minor_head    IN ('400','IRF4');
              UPDATE xx_refd_headers head
              SET head.total_refd_amount = head.total_refd_amount - v_refdem_amt_400
              WHERE head.refd_status     = 'PCM APPROVED'
              AND head.id_number          = p_in_id_num
              AND head.reference_id        = j.reference_id;
            END IF;
            write_msg( g_write_logfile , 'No of 400 rows updated: '|| sql%rowcount);
          ELSIF NVL(j.rr_refdemadj_amount,0) = 0 THEN
            UPDATE xx_refd_headers head
            SET head.rr_refdemadj_amount =
              (SELECT NVL (SUM (rr_refdemadj_amount), 0)
              FROM xx_refd_lines
              WHERE reference_id = head.reference_id
              )
            WHERE head.refd_status = 'PCM APPROVED'
            AND head.id_number      = p_in_id_num
            AND head.reference_id    = j.reference_id;
            UPDATE xx_refd_headers head
            SET head.total_refd_amount = head.total_refd_amount - head.rr_refdemadj_amount
            WHERE head.refd_status     = 'PCM APPROVED'
            AND head.id_number          = p_in_id_num
            AND head.reference_id        = j.reference_id;
          END IF;
        END LOOP;
      END ;
    END IF;
    l_stmt_processing  := ' Settimg the header to Approved is total refd is 0' ;
    l_chr_exe_location :='PRRADJ017';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing) ;
    -- Error in status update from PCM Approved to APPROVED '
    UPDATE xx_refd_headers head
    SET head.refd_status             = 'APPROVED'
    WHERE head.refd_status           = 'PCM APPROVED'
    AND head.total_refd_amount       = 0
    AND head.REFD_CROSSADJUST_AMOUNT = 0 -- Added for CR - 690 on 08-JUN-2018 for DDT-BBS ABC changes
    AND head.id_number                = p_in_id_num;
    write_debug( g_debug_flag , '----------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Prior Refd Receivable Adjustment Program - ENDS ***');
    write_debug( g_debug_flag , '----------------------------------------------------------------');
  EXCEPTION
  WHEN CUSTOM_EXCEPTION THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := ' Error ' || l_chr_proc_name || ' - ' || l_chr_exe_location || ' - ' || l_stmt_processing || ' - ' || p_out_chr_errbuff;
    write_msg( g_write_logfile , p_out_chr_errbuff);
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff) ;
      END IF;
    END IF;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := ' Unexpected Error -' || l_chr_proc_name || ' - ' || l_chr_exe_location || ' - ' || l_stmt_processing || ' - ' || SUBSTR(sqlerrm ,1,255);
    write_msg( g_write_logfile , p_out_chr_errbuff);
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff) ;
      END IF;
    END IF;
  END ;
  -- ***************** End of Function / Procedure **********************--
  PROCEDURE writeoff_proc(
      p_out_chr_errbuff OUT NOCOPY VARCHAR2,
      p_out_chr_retcode OUT NOCOPY VARCHAR2,
      in_num_cash_receipt_id IN NUMBER,
      in_num_writeoff_amount IN NUMBER,
      in_chr_appl_flag       IN VARCHAR2,
      in_chr_major_head      IN VARCHAR2,
      in_chr_assmt_year      IN VARCHAR2,
      in_dte_apply_date      IN DATE,
      p_in_irt_id            IN VARCHAR2 )
    /****************************************************************************
    ************
    * Type : PROCEDURE
    * Name : WRITEOFF_PROC
    * Input Parameters : in_num_cash_receipt_id, in_chr_appl_flag,
    in_num_writeoff_amount
    in_chr_major_head, in_chr_assmt_year, in_dte_apply_date,p_in_irt_id
    * Output Parameters : out_chr_errbuff, out_chr_retcode
    * Purpose : To perform writeoff operation in receipt
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 04-Jan-2012
    * Last Reviewed By :
    * Last Reviewed Date : 04-Jan-2012
    *****************************************************************************
    ************
    * Modified Date Modified By Version Modification Type Modification Details
    * ------------- ------------ -------- -----------------
    --------------------------
    * 04-Jan-2012 Infosys 1.0 Created
    *****************************************************************************
    ***********/
  AS
    l_count            NUMBER;
    l_msg_count        NUMBER;
    l_msg_data         VARCHAR2 (5000);
    l_return_status    VARCHAR2 (1);
    l_stmt_processing  VARCHAR2 (200);
    l_chr_proc_name    VARCHAR2(50) :='writeoff_proc';
    l_chr_exe_location VARCHAR2(50) :='';
    l_chr_errbuff      VARCHAR2 (5000);
    l_chr_retcode      VARCHAR2 (10);
    l_secondary_application_ref_id ar_receivable_applications.secondary_application_ref_id%TYPE;
    l_application_ref_type ar_receivable_applications.application_ref_type%TYPE;
    l_application_ref_id ar_receivable_applications.application_ref_id%TYPE;
    l_application_ref_num ar_receivable_applications.application_ref_num%TYPE;
    l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
    l_receivable_application_id ar_receivable_applications.receivable_application_id%TYPE;
    l_exc_exit_error_proc EXCEPTION;
    l_exc_exit_warn_proc  EXCEPTION;
    v_attribute1 ar_receivable_applications.attribute1%type;
    v_attribute2 ar_receivable_applications.attribute2%type;
    v_attribute3 ar_receivable_applications.attribute3%type;
    v_attribute4 ar_receivable_applications.attribute4%type;
    V_ATTRIBUTE5 ar_receivable_applications.attribute5%type;
    V_STATUS ar_receivable_applications.status%type;
    v_applied_payment_schedule_id ar_receivable_applications.applied_payment_schedule_id%type;
  BEGIN
    l_chr_proc_name            := 'Writeoff_proc';
    l_chr_exe_location         := 'WP_001';
    p_out_chr_retcode          := g_chr_success_code;
    p_out_chr_errbuff          := '';
    l_stmt_processing          := ' Setting the variable before calling the API for Writeoff';
    l_chr_exe_location         := 'WP_003';
    l_msg_count                := NULL;
    l_return_status            := NULL;
    l_attribute_rec            := NULL;
    l_attribute_rec.attribute4 := in_chr_appl_flag;
    l_attribute_rec.attribute1 := in_chr_major_head;
    l_attribute_rec.attribute3 := in_chr_assmt_year;
    l_stmt_processing          := ' Setting the variable before calling the API for Writeoff';
    l_chr_exe_location         := 'WP_004';
    write_debug( g_debug_flag , 'Before calling activity application at WP_004 ');
    --ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => in_num_cash_receipt_id, p_amount_applied => in_num_writeoff_amount, p_apply_date => TO_DATE (in_dte_apply_date, 'DD-MON-RRRR'), p_apply_gl_date => g_dte_sys_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id, p_org_id => g_num_org_id );  --Commented for Hotfix_199485 on 13-MAR-2019
    ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => in_num_cash_receipt_id, p_amount_applied => in_num_writeoff_amount, p_apply_date => TO_DATE (in_dte_apply_date, 'DD-MON-RRRR'), p_apply_gl_date => TO_DATE (in_dte_apply_date, 'DD-MON-RRRR'), p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id, p_org_id => g_num_org_id ); --Added for Hotfix_199485 on 13-MAR-2019
    l_stmt_processing  := ' Checking the status of the API call';
    l_chr_exe_location := 'WP_005';
    write_debug( g_debug_flag , 'Apply receipt writeoff for receipt ID ' || in_num_cash_receipt_id || ' for amount ' || in_num_writeoff_amount || ' - ' || l_return_status ||'for l_receivable_application_id: '||l_receivable_application_id);
	dbms_output.put_line('Apply receipt writeoff for receipt ID ' || in_num_cash_receipt_id || ' for amount ' || in_num_writeoff_amount || ' - ' || l_return_status ||'for l_receivable_application_id: '||l_receivable_application_id);
    SELECT ATTRIBUTE1,
      ATTRIBUTE2,
      ATTRIBUTE3,
      ATTRIBUTE4,
      ATTRIBUTE5,
      STATUS,
      APPLIED_PAYMENT_SCHEDULE_ID
    INTO v_attribute1,
      v_attribute2,
      v_attribute3,
      v_attribute4,
      V_ATTRIBUTE5,
      V_STATUS,
      v_applied_payment_schedule_id
    FROM AR_RECEIVABLE_APPLICATIONS_ALL
    WHERE RECEIVABLE_APPLICATION_ID = L_RECEIVABLE_APPLICATION_ID;
    WRITE_DEBUG( G_DEBUG_FLAG , 'L_RECEIVABLE_APPLICATION_ID: '||L_RECEIVABLE_APPLICATION_ID);
    WRITE_DEBUG( G_DEBUG_FLAG , 'V_STATUS: '||V_STATUS);
    WRITE_DEBUG( G_DEBUG_FLAG , 'v_applied_payment_schedule_id: '||v_applied_payment_schedule_id);
    write_debug( g_debug_flag , 'ATTRIBUTE1 '|| v_ATTRIBUTE1|| ' ATTRIBUTE2 '|| v_ATTRIBUTE2||'ATTRIBUTE3 '||v_ATTRIBUTE3||' ATTRIBUTE4 '||v_ATTRIBUTE4||' ATTRIBUTE5 '||v_ATTRIBUTE5);
	dbms_output.put_line('ATTRIBUTE1 '|| v_ATTRIBUTE1|| ' ATTRIBUTE2 '|| v_ATTRIBUTE2||'ATTRIBUTE3 '||v_ATTRIBUTE3||' ATTRIBUTE4 '||v_ATTRIBUTE4||' ATTRIBUTE5 '||v_ATTRIBUTE5);
    IF l_return_status    != 'S' THEN
      l_chr_exe_location  := 'WP_006';
      IF l_msg_count       = 1 THEN
        p_out_chr_errbuff := p_out_chr_errbuff || 'l_msg_data ' || RTRIM (LTRIM ( l_msg_data)) || '****';
      ELSIF l_msg_count    > 1 --IF l_msg_count = 1
        THEN
        l_chr_exe_location := 'WP_006';
        LOOP
          l_count       := l_count + 1;
          l_msg_data    := fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false);
          IF l_msg_data IS NULL THEN
            EXIT;
          END IF;
          p_out_chr_errbuff := p_out_chr_errbuff || 'Message' || l_count || ' --' || l_msg_data;
        END LOOP; -- LOOP
      END IF;     -- IF l_msg_count = 1
      p_out_chr_errbuff := 'Error in procedure ' ||l_chr_proc_name || '- ' || p_out_chr_errbuff ;
      p_out_chr_retcode := g_chr_failure_code;
      write_msg( g_write_logfile ,p_out_chr_errbuff );
    END IF; -- IF l_return_status != g_chr_success_code
    l_chr_exe_location := 'WP_007';
  EXCEPTION
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' ||l_chr_proc_name ||'-'|| l_chr_exe_location ||'-'|| l_stmt_processing || '- ' ||SUBSTR(sqlerrm,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff);
      END IF;
    END IF;
  END writeoff_proc;
/******************************************************************************
**********
* Type : PROCEDURE
* Name : refd_interest
* Input Parameters : p_in_irt_id
* Output Parameters : out_chr_errbuff, out_chr_retcode
* Purpose : Computes the Interest Amount for the Refd amount
*******************************************************************************
**********
* Modified Date Modified By Version Modification Type Modification Details
* ------------- ------------ -------- -----------------
*******************************************************************************
*********/
  PROCEDURE refd_interest(
      p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
      p_out_chr_retcode OUT NOCOPY VARCHAR2,
      p_in_irt_id IN VARCHAR2 )
  AS
    l_interest_amount      NUMBER;
    l_num_chk_cnt          NUMBER;
    l_num_min              NUMBER;
    l_num_max              NUMBER;
    l_amt_int_calc_max     NUMBER;
    l_amt_int_calc_min     NUMBER;
    l_tot_interest_amount  NUMBER;
    l_interest_calc_amount NUMBER;
    end_of_analysis        BOOLEAN;
    l_chr_proc_name        VARCHAR2(50) :='';
    l_chr_exe_location     VARCHAR2(50) :='';
    l_stmt_processing      VARCHAR2(200);
    l_chr_errbuff          VARCHAR2 (5000);
    l_chr_retcode          VARCHAR2 (10);
    P_START_DATE           DATE;       --Added For SAT Payment Interests - 11-Jun-2016
    V_FILING_DT            DATE;       --Added For SAT Payment Interests - 11-Jun-2016
    L_SAT_INTEREST_AMT     NUMBER :=0; --Added For SAT Payment Interests - 11-Jun-
    -- 2016
    L_SAT_ELIGIBLE_AMT NUMBER :=0; --Added For SAT Payment Interests - 11-Jun-
    -- 2016
    L_REC_INTEREST_AMT NUMBER :=0; --Added For SAT Payment Interests - 11-Jun-
    -- 2016
    L_SAT_INT_MONTHS NUMBER :=0;                                        --Added For SAT Payment Interests - 11-Jun-2016
    V_REC_COUNT      NUMBER :=0;                                        --Added For SAT Payment Interests - 11-Jun-2016
    V_TYPE_OF_RETURN IRT_STDCMP.INTEREST_ON_REFD.TYPE_OF_RETURN%TYPE; --Added
    -- For SAT Payment Interests - 11-Jun-2016
    V_DEFECTIVE_COMM_SENT_DT IRT_STDCMP.INTEREST_ON_REFD.DEFECTIVE_COMM_SENT_DT%TYPE; --Added For SAT
    -- Payment Interests - 11-Jun-2016
    V_CORRECTIVE_FILIING_DATE IRT_STDCMP.INTEREST_ON_REFD.CORRECTIVE_FILIING_DATE%TYPE; --Added For SAT
    -- Payment Interests - 11-Jun-2016
    L_DEF_DELAY_MONTHS NUMBER :=0; --Added For SAT Payment Interests - 11-Jun-
    -- 2016
    L_DELAY_MONTH          NUMBER       :=0;  --Added For SAT Payment Interests - 11-Jun-2016
    L_VAL_FILING_STATUS_CD VARCHAR2(50) :=''; --ADDED AS PART OF HOTFIX#126136
    ------158813------
    L_INPUT_ERR_FLAG VARCHAR2(50) :=''; --Added For SAT Payment Interests--
    -- HOTFIX#158813-07-Nov-2017
    L_INP_ERR_FLG    VARCHAR2(100);
    LV_ID_NO        VARCHAR2(100);
    LV__ayr VARCHAR2(100);
    L_ORIG_FILE_DT IRT_STDCMP.INTEREST_ON_REFD.FILING_DT%type;--hotfix#158813
    L_ORIG_IRT_ID IRT_STDCMP.INTEREST_ON_REFD.ORIG_IRT_ID%type;
    lv_val_filing_status IRT_STDCMP.INTEREST_ON_REFD.VAL_FILING_STATUS_CD%type;
    --Added by Sudha on 18-Jan-2018 for HF#171927 starts
    v_prev_irt_id irt_stdcmp.interest_on_refd.ORIG_IRT_ID%type;
    V_PREV_REF_ID xx_REFD_HEADERS.REFERENCE_ID%type;
    L_ELIGIBLE_AMT_300      NUMBER := 0;
    L_ELIGIBLE_PREV_300     NUMBER := 0;
    L_ELIGIBLE_INCR_AMT_300 NUMBER := 0;
    L_PREV_INT_AMT          NUMBER := 0;
    L_REFD_IDENTIFIED_DT xx_REFD_HEADERS.REFD_IDENTIFIED_DATE%TYPE;
    L_DELAY_MONTHS_300 NUMBER :=0;
    L_TOT_DELAY_MONTHS NUMBER :=0;
    V_FIRST_CLAIM_DT "process_store"."irt_process_control_mstr"."x_e_ack_recpt_dt"@psql_process_fas%type;
    V_FILING_DT_ORG irt_stdcmp.interest_on_refd.filing_dt%type;
    V_MIN_CLAIM_IRT_ID IRT_MATCHING.IRT_CLAIMS_MATCHING.IRT_ID%type;
    -- Added by Sudha on 18-Jan-2018 for HF#171927 ends
    --V_RECT_FILE_DT irt_stdcmp.interest_on_refd.RECT_FILE_DT%type; -- Added by Sudha on 22-Jan-2018 for HF#158813 -- Removed INPUT_ERROR_FLAG check on 23-Jan-2018
    --V_FILING_DT_UPC irt_stdcmp.interest_on_refd.filing_dt%type; -- Added for UPC orders on 08-Feb-2018 for HF#171927 by sudha
    -- Added by Sudha for HF#171927 on 09-Feb-2018 -- 100/200 -- starts
    L_START_MONTH VARCHAR2 (11);
    V_PREV_IRT_ID_100 IRT_STDCMP.INTEREST_ON_REFD.ORIG_IRT_ID%type;
    v_prev_ref_id_100 xx_REFD_HEADERS.REFERENCE_ID%type;
    L_ELIGIBLE_AMT_100    NUMBER := 0;
    L_ELIGIBLE_PREV_100   NUMBER := 0;
    L_AT_TS_ELIGIBLE_AMT NUMBER := 0;
    L_AT_TS_INTEREST_AMT NUMBER := 0;
    L_AT_TS_INT_MONTHS   NUMBER := 0;
    L_DELAY_MONTHS_100    NUMBER := 0;
    L_PREV_INT_AMT_100    NUMBER := 0;
    L_IRTV_EVC_VALIDATED_DATE IRT_STDCMP.INTEREST_ON_REFD.IRTV_EVC_VALIDATED_DATE%TYPE;
    L_TYPE_OF_RETURN IRT_STDCMP.INTEREST_ON_REFD.TYPE_OF_RETURN%type;
    L_DEFECTIVE_COMM_SENT_DT IRT_STDCMP.INTEREST_ON_REFD.DEFECTIVE_COMM_SENT_DT%type;
    L_CORRECTIVE_FILIING_DATE IRT_STDCMP.INTEREST_ON_REFD.CORRECTIVE_FILIING_DATE%TYPE;
    l_start_filing_mon NUMBER :=0;
    l_evc_app_mon      NUMBER :=0;
    l_fil_evc_mon      NUMBER :=0;
    L_DEF_EVC_MON      NUMBER :=0;
    L_COR_DEF_MON      NUMBER :=0;
    L_COR_APP_MON      NUMBER :=0;
    L_TOT_INT_MONTHS   NUMBER :=0;
    -- Added by Sudha for HF#171927 on 09-Feb-2018 -- 100/200 -- ends
    L_FILING_CODE "process_store"."irt_process_control_mstr"."x_val_filing_status_cd"@psql_process_fas%TYPE; -- Added for HF#171927 by Sudha on 10-Jan-2018
    v_current_filing_dt DATE;                                         -- Added for HF#171927 by Sudha on 10-Jan-2018
    -- Added for HF#171927 on 28-Feb-2018 by Sudha -- starts
    L_INT_AMT NUMBER :=0;
    L_INT_SAT NUMBER :=0;
    L_INT_DDT NUMBER :=0;
    -- Added for HF#171927 on 28-Feb-2018 by Sudha -- ends
    V_EXCESS_RECEIPT_AMOUNT NUMBER := 0 ;                           -- Added for HF#171927 on 6-Mar-2018 by Sudha - Round off issue
    V_count_orig            NUMBER := 0;                            -- Added for HF#171927 on 6-Mar-2018 by Sudha
    v_previous_filing_dt    DATE ;                                  -- Added for HF#171927 on 6-Mar-2018 by Sudha
    L_1192B_FLAG IRT_PERSONAL_INFO.REFD_244A_INT_1192B_FLAG%TYPE; --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha
    l_tot_eligible_amt NUMBER;                                      -- Added for HF#171927 on 8-May-2018
    -- Added below for DDT/BBS for CR#690 on 07-May-2018 - starts
    /*L_DEF_DELAY_MONTHS_DDT_BBS NUMBER := 0;
    L_ELIGIBLE_AMT_DDT_BBS     NUMBER := 0;
    L_ELIGIBLE_PREV_DDT_BBS    NUMBER := 0;
    V_PREV_IRT_ID_DDT_BBS IRT_STDCMP.INTEREST_ON_REFD.ORIG_IRT_ID%type;
    V_PREV_REF_ID_DDT_BBS xx_REFD_HEADERS.REFERENCE_ID%type;
    L_DDT_BBS_ELIGIBLE_AMT     NUMBER := 0;
    L_DDT_BBS_INTEREST_AMT     NUMBER := 0;
    L_DDT_BBS_INT_MONTHS       NUMBER := 0;
    L_DELAY_MONTHS_DDT_BBS     NUMBER := 0;
    L_TOT_DELAY_MONTHS_DDT_BBS NUMBER := 0;
    L_PREV_INT_AMT_DDT_BBS     NUMBER := 0;*/
    -- Commented on 08-JUN-2018 for DDT-BBS ABC changes - CR - 690
    -- Added below for DDT/BBS for CR#690 on 07-May-2018 - ends
    L_SOURCE "process_store"."irt_process_control_mstr"."x_source_name"@psql_process_fas%TYPE;                -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018
    v_approval_flag IRT_STDCMP.IBA_REFD_RETURNS.approval_flag%TYPE; -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018
    l_241a_flag "process_store"."irt_process_control_mstr"."x_flag_241a"@psql_process_fas%TYPE;               --Added for CR#729 - 241a - 22-Oct-2018
    l_amt NUMBER;
	l_num_irt NUMBER;    -- to store the to_number(p_in_irt_id).
  TYPE g_req_rec
IS
  RECORD
  (
    request_id NUMBER);
  l_chk NUMBER := 0;
TYPE tbl_req
IS
  TABLE OF g_req_rec INDEX BY BINARY_INTEGER;
  G_REQ_TBL TBL_REQ;
  CUSTOM_EXCEPTION EXCEPTION ;
  CURSOR cur_refd_headers (p_in_irt_id VARCHAR2)
  IS
    SELECT reference_id ,
      irt_id ,
      customer_trx_id ,
      id_number ,
      irt_ay ,
      major_head ,
      irt_schedule_type ,
      total_refd_amount ,
      refd_adjustment_amount ,
      refd_interest_amount ,
      eligible_interest_amount refd_identified_amount ,
      refd_identified_date ,
      total_xx_computed ,
      approval_date ,
      irt_returns_due_date ,
      customer_trx_date ,
      ref_to_date ,
      vld_orgirt_date
    FROM xx_refd_headers
    WHERE REFD_STATUS = 'AWAITING APPROVAL'
      --  AND eligible_interest_amount        > 0
    AND NVL (refd_interest_amount, 0) = 0
    AND irt_id                          = p_in_irt_id;
BEGIN
dbms_output.put_line('Start of Refd Interest');
  p_out_chr_errbuff  := ' ';
  p_out_chr_retcode  := g_chr_success_code;
  l_chr_exe_location := 'RIP_0001';
  l_stmt_processing  := ' Entering Invoice Apply API ' ;
  write_debug( g_debug_flag ,l_stmt_processing );
  write_debug( g_debug_flag , '*** REFD INTEREST CALCULATION - STARTS ***');
  l_chr_exe_location := 'RIP_0002';
  l_stmt_processing  := 'Eligible Interest Amount population ' ;
  WRITE_DEBUG( G_DEBUG_FLAG ,L_STMT_PROCESSING );
  --Added as a Part of Delay Attribute - Starts Here - 11-jun-2016
  V_REC_COUNT :=0;
  BEGIN
    SELECT COUNT(1)
    INTO V_REC_COUNT
    FROM "process_store"."interest_on_refd"@psql_process_fas
    WHERE "irt_id"=P_IN_IRT_ID;
  EXCEPTION
  WHEN OTHERS THEN
    L_CHR_EXE_LOCATION := 'RIP_0002';
    L_STMT_PROCESSING  := SQLERRM ;
    WRITE_DEBUG( G_DEBUG_FLAG ,L_STMT_PROCESSING );
    RAISE CUSTOM_EXCEPTION;
  END;
IF V_REC_COUNT        = 0 THEN
  L_CHR_EXE_LOCATION := 'RIP_0002';
  L_STMT_PROCESSING  := 'No Entry In Refd Table ' ;
  WRITE_DEBUG( G_DEBUG_FLAG ,L_STMT_PROCESSING );
  RAISE CUSTOM_EXCEPTION;
END IF;
--Added as a Part of Delay Attribute - Ends Here - 11-jun-2016
-- Eligible Interest Amount population
/*SELECT NVL(SOURCE_NAME, 'X') INTO L_SOURCE
FROM "process_store"."irt_process_control_mstr"@psql_process_fas
WHERE IRT_ID = P_IN_IRT_ID; -- aDDED FOR DDT BBS CHANGES CR - 690 ON 18-MAY-2018
*/
-- Commented for CR - 690 - DDT-BBS ABC Changes
UPDATE xx_refd_headers
SET eligible_interest_amount = total_collect_calc (reference_id),
  refd_status              = 'AWAITING APPROVAL'
WHERE refd_status          = 'NEW'
AND major_head              IN ('0020', '0021', '0026')
AND IRT_ID                   = P_IN_IRT_ID
  --AND NVL (total_collect_calc (REFERENCE_ID), 0) > (0.1 *
  -- TOTAL_XX_COMPUTED); --commented as a part of Hotfix#120438 - 23-JUN-
  -- 2016
  --AND NVL (TOTAL_300_COLLECT_CALC (REFERENCE_ID, L_SOURCE), 0) > (0.1 * TOTAL_XX_COMPUTED); --Modified as a Part of Hotfix#120438 - 23-JUN-2016 -- Added total_collect_calc by Neha on 24-NOV-2017 for checking issue in Refd interest , -- aDDED L_SOURCE FOR DDT BBS CHANGES CR - 690 ON 18-MAY-2018 -- Commented for CR - 690 - DDT-BBS ABC Changes
AND NVL (TOTAL_300_COLLECT_CALC (REFERENCE_ID), 0) > (0.1 * TOTAL_XX_COMPUTED); --Modified as a Part of Hotfix#120438 - 23-JUN-2016 -- Added total_collect_calc by Neha on 24-NOV-2017 for checking issue in Refd interest -- Added for CR - 690 - DDT-BBS ABC changes on 08-JUN-2018
WRITE_DEBUG( G_DEBUG_FLAG ,' updating refd headers after 300 - '||sql%rowcount);
dbms_output.put_line('updating refd headers after 300 - '||sql%rowcount);
--  IF sql%rowcount > 1 THEN
--    SELECT NVL(eligible_interest_amount,0)
--    INTO L_amt
--    FROM xx_REFD_HEADERS
--    WHERE IRT_ID=P_IN_IRT_ID;
--    write_debug( g_debug_flag ,'L_amt: '||L_amt);
--  END IF;
-- Commented below update for HF#171927 (Jtrac#381) on 10-Dec-2018
/*UPDATE xx_refd_headers
SET eligible_interest_amount = total_300_collect_calc(reference_id),
REFD_STATUS              = 'AWAITING APPROVAL'
WHERE refd_status         IN ('NEW', 'AWAITING APPROVAL')
AND major_head              IN ('0020', '0021', '0026')
AND IRT_ID                   = P_IN_IRT_ID
--AND NVL (total_300_collect_calc(reference_id, L_SOURCE), 0) > (0.1 * total_xx_computed ); -- aDDED L_SOURCE FOR DDT BBS CHANGES CR - 690 ON 18-MAY-2018 , -- Commented for CR - 690 - DDT-BBS ABC Changes
AND NVL (total_300_collect_calc(reference_id), 0) > (0.1 * total_xx_computed ); -- Added for CR - 690 - DDT-BBS ABC changes on 08-JUN-2018
write_debug( g_debug_flag ,'Number of rows updated in XRH: '||sql%rowcount);*/
l_chr_exe_location := 'RIP_0003';
l_stmt_processing  :='For Loop started';
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
write_debug( g_debug_flag ,' updating refd headers afetr 300 second one - ' );

---------------------------------------------------------------------------------------------
--Commented the L_1192B_FLAG fetch from irt_personal_info and assigned X as default case for POC. - Bhagya
-------------------------------------------------------------------------------------------------------------
  L_1192B_FLAG := 'X';    -- Assigning to X by default for ABC-2.0 POC
FOR cur_refd_headers_rec IN cur_refd_headers(p_in_irt_id)
LOOP

  --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha -- starts
 /* BEGIN
    SELECT NVL(UPPER(REFD_244A_INT_1192B_FLAG),'X')
    INTO L_1192B_FLAG
    FROM IRT_PERSONAL_INFO    --not changed. Get the corresponding postgres column. ABC 2.0 Bhagya
    WHERE IRT_ID=P_IN_IRT_ID;
    write_debug( g_debug_flag ,'L_1192B_FLAG: '||L_1192B_FLAG);
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    l_stmt_processing := 'No data found in IRT_PERSONAL_INFO table for IRT_ID: '||P_IN_IRT_ID;
    RAISE CUSTOM_EXCEPTION;
  END;
  */
 ------------------------------------------------------------------------------ 
  IF L_1192B_FLAG = 'N' THEN
    UPDATE xx_REFD_HEADERS
    SET TOTAL_REFD_AMOUNT  = ROUND(REFD_IDENTIFY_AMOUNT),
      REFD_INTEREST_AMOUNT = 0
    WHERE REFERENCE_ID       =cur_refd_headers_rec.REFERENCE_ID;
    write_debug( g_debug_flag ,'Updated Refd interest as zero for 119(2)(B)');

  ELSIF L_1192B_FLAG IN ('Y','X') THEN
    --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha -- ends
    write_debug( g_debug_flag ,'cur_refd_headers_rec.refd_identified_amount: '||cur_refd_headers_rec.refd_identified_amount);
    write_debug( g_debug_flag ,' Ref id - ' || cur_refd_headers_rec.reference_id || ' irt_ay - ' || cur_refd_headers_rec.irt_ay || ' excces recpt amt ' || ( cur_refd_headers_rec.refd_identified_amount -
    MOD(cur_refd_headers_rec.refd_identified_amount,100) ) || ' approval date ' || NVL (cur_refd_headers_rec.ref_to_date, SYSDATE) || ' Irt returns date ' || TO_CHAR ( cur_refd_headers_rec.irt_returns_due_date,'DD-MON-YYYY') || ' trx date ' || cur_refd_headers_rec.vld_orgirt_date );
    l_num_chk_cnt      := 0;
    l_chr_exe_location := 'RIP_0004';
    l_stmt_processing  :='Prior Refd check';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    BEGIN
      SELECT COUNT (1)
      INTO l_num_chk_cnt
      FROM xx_refd_headers xrh,
        xx_refd_lines xrl
      WHERE xrh.reference_id                                     = xrl.reference_id
      AND NVL (xrh.eligible_interest_amount, 0)                 >= 0
      AND xrl.minor_head                                        IN ('100', '200', 'XCL','PMR','SPI','5A','OTH') --Added PMR as part of CR#0653 --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
      AND xrl.reference_id                                       = xrh.reference_id
      AND xrh.irt_id                                             = cur_refd_headers_rec.irt_id
      AND ( xrh.id_number, xrh.irt_ay, xrh.irt_schedule_type ) IN
        (SELECT xrh.id_number,
          xrh.irt_ay,
          xrh.irt_schedule_type
        FROM ra_customer_trx_all rcta,
          ra_cust_trx_types_all rctt,
          xx_refd_headers xrh
        WHERE xrh.customer_trx_id                  = rcta.customer_trx_id
        AND rcta.cust_trx_type_id                  = rctt.cust_trx_type_id
        AND rctt.attribute2                       IN ('RECTIFICATION', 'REVISED')
        AND NVL (xrh.eligible_interest_amount, 0) >= 0
        AND xrh.id_number                         = cur_refd_headers_rec.id_number
        AND xrh.irt_ay                             = cur_refd_headers_rec.irt_ay
        AND xrh.irt_schedule_type                  = cur_refd_headers_rec.irt_schedule_type
        AND xrh.reference_id                       = cur_refd_headers_rec.reference_id
        )
      GROUP BY xrh.id_number,
        xrh.irt_ay,
        xrh.irt_schedule_type
      HAVING COUNT (1) >= 1;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      l_num_chk_cnt := 0;
    END;
    write_debug( g_debug_flag ,' l_num_chk_cnt - ' ||l_num_chk_cnt);
    IF l_num_chk_cnt     <> 0 THEN
      l_chr_exe_location := 'RIP_0005';
      write_debug( g_debug_flag ,l_chr_exe_location);
      l_num_min := 0;
      l_num_max := 0;
      DELETE FROM xx_rfnd_inst_gtt;
      l_chr_exe_location := 'RIP_0006';
      l_stmt_processing  :='Insert into xx_rfnd_inst_gtt';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO xx_rfnd_inst_gtt
        (
          ref_to_date ,
          eligible_interest_amount ,
          amt_for_int_calc ,
          prev_ref_id
        )
        (SELECT NVL (ref_to_date, refd_identified_date),
            NVL (eligible_interest_amount, 0),
            NVL (eligible_interest_amount, 0),
            reference_id
          FROM xx_refd_headers
          WHERE id_number                       = cur_refd_headers_rec.id_number
          AND irt_ay                             = cur_refd_headers_rec.irt_ay
          AND irt_schedule_type                  = cur_refd_headers_rec.irt_schedule_type
          AND NVL (eligible_interest_amount, 0) >= 0
        );
      l_chr_exe_location := 'RIP_0007';
      l_stmt_processing  := 'Updating irt_id ,rect_ref_id in xx_rfnd_inst_gtt ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      UPDATE xx_rfnd_inst_gtt
      SET rect_ref_id     = cur_refd_headers_rec.reference_id ,
        irt_id            = cur_refd_headers_rec.irt_id;
      l_chr_exe_location := 'RIP_0009';
      write_debug( g_debug_flag ,l_chr_exe_location);
      FOR l_rec IN
      (SELECT prev_ref_id,
        RANK () OVER (ORDER BY prev_ref_id) AS drank
      FROM xx_rfnd_inst_gtt
      ORDER BY prev_ref_id
      )
      LOOP
        l_chr_exe_location := 'RIP_0010';
        l_stmt_processing  :='Updating seq in xx_rfnd_inst_gtt ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        UPDATE xx_rfnd_inst_gtt
        SET seq           = l_rec.drank
        WHERE prev_ref_id = l_rec.prev_ref_id ;
      END LOOP;
      l_chr_exe_location := 'RIP_0011';
      l_stmt_processing  :='min and max seq fetch ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT MIN (seq),
        MAX (seq)
      INTO l_num_min,
        l_num_max
      FROM xx_rfnd_inst_gtt
      WHERE amt_for_int_calc > 0
      AND int_244_calc_flag IS NULL
      AND irt_id             = p_in_irt_id;
      IF l_num_min          <> l_num_max THEN
        l_amt_int_calc_max  := 0;
        l_amt_int_calc_min  := 0;
        end_of_analysis     := FALSE;
        WHILE NOT end_of_analysis
        LOOP
          l_chr_exe_location := 'RIP_0012';
          l_stmt_processing  :='AMT_FOR_INT_CALC fetch for max seq ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          SELECT amt_for_int_calc
          INTO l_amt_int_calc_max
          FROM xx_rfnd_inst_gtt
          WHERE seq           = l_num_max;
          l_chr_exe_location := 'RIP_0013';
          l_stmt_processing  :='AMT_FOR_INT_CALC fetch for min seq ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          SELECT amt_for_int_calc
          INTO l_amt_int_calc_min
          FROM xx_rfnd_inst_gtt
          WHERE seq              = l_num_min
          AND irt_id             = p_in_irt_id;
          IF l_amt_int_calc_max >= l_amt_int_calc_min THEN
            --increase in refd or same
            l_chr_exe_location := 'RIP_0014';
            l_stmt_processing  := 'updating amt_for_int_calc column in xx_rfnd_inst_gtt table ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            --updating amt_for_int_calc column in xx_rfnd_inst_gtt table
            UPDATE xx_rfnd_inst_gtt
            SET amt_for_int_calc     = amt_for_int_calc - l_amt_int_calc_min
            WHERE int_244_calc_flag IS NULL
            AND seq                 <> l_num_min
            AND irt_id               = p_in_irt_id;
            l_chr_exe_location      := 'RIP_0015';
            l_stmt_processing       := 'updating amt_for_int_calc column in xx_rfnd_inst_gtt table ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            --updating amt_for_int_calc column in xx_rfnd_inst_gtt table
            UPDATE xx_rfnd_inst_gtt
            SET amt_for_int_calc   = 0
            WHERE amt_for_int_calc < 0
            AND irt_id             = p_in_irt_id;
          ELSE -- IF l_amt_int_calc_max >= l_amt_int_calc_min
            IF l_amt_int_calc_max < l_amt_int_calc_min THEN
              --decrease in refd
              l_chr_exe_location := 'RIP_0016';
              l_stmt_processing  := 'updating amt_for_int_calc column in xx_rfnd_inst_gtt table ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              --updating amt_for_int_calc column in xx_rfnd_inst_gtt table
              UPDATE xx_rfnd_inst_gtt
              SET amt_for_int_calc = l_amt_int_calc_max
              WHERE seq            = l_num_min
              AND irt_id           = p_in_irt_id;
              l_chr_exe_location  := 'RIP_0017';
              l_stmt_processing   := 'updating amt_for_int_calc column in xx_rfnd_inst_gtt table ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              --updating amt_for_int_calc column in xx_rfnd_inst_gtt table
              UPDATE xx_rfnd_inst_gtt
              SET amt_for_int_calc   = 0
              WHERE seq             <> l_num_min
              AND int_244_calc_flag IS NULL
              AND irt_id             = p_in_irt_id;
            END IF; -- IF l_amt_int_calc_max < l_amt_int_calc_min
          END IF;   -- IF l_amt_int_calc_max >= l_amt_int_calc_min
          l_chr_exe_location := 'RIP_0018';
          l_stmt_processing  := 'updating int_244_calc_flag column in xx_rfnd_inst_gtt table ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          --updating int_244_calc_flag in xx_rfnd_inst_gtt table
          UPDATE xx_rfnd_inst_gtt
          SET int_244_calc_flag  = 'Y'
          WHERE amt_for_int_calc > 0
          AND seq                = l_num_min
          AND irt_id             = p_in_irt_id;
          l_num_min             := l_num_min + 1;
          IF l_num_min           = l_num_max THEN
            end_of_analysis     := TRUE;
          END IF; -- IF l_num_min = l_num_max
        END LOOP; -- WHILE NOT end_of_analysis
      END IF;     -- IF l_num_min <> l_num_max
      l_chr_exe_location := 'RIP_0019';
      l_stmt_processing  := 'updating int_244_calc_flag to Y column in xx_rfnd_inst_gtt table ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      -- int_244_calc_flag update
      UPDATE xx_rfnd_inst_gtt
      SET int_244_calc_flag = 'Y'
      WHERE seq             = l_num_max
      AND irt_id            = p_in_irt_id;
      l_chr_exe_location   := 'RIP_0020';
      l_stmt_processing    := 'updating int_244_calc_flag to N column in xx_rfnd_inst_gtt table';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      --Updating int_244_calc_flag in xx_rfnd_inst_gtt table
      UPDATE xx_rfnd_inst_gtt
      SET int_244_calc_flag  = 'N'
      WHERE amt_for_int_calc = 0
      AND irt_id             = p_in_irt_id;
      INSERT INTO xx_rfnd_inst
      SELECT *
      FROM xx_RFND_INST_GTT;
      FOR l_cnt_rec IN
      (SELECT xrig.seq seq ,
        xrig.ref_to_date ,
        xrig.amt_for_int_calc ,
        prev_ref_id ref_id ,
        xrh.irt_returns_due_date ,
        xrh.vld_orgirt_date ,
        xrh.irt_ay ,
        xrh.refd_identified_date,
        xrh.irt_id --ADDED AS PART OF HOTFIX#126136
      FROM xx_rfnd_inst_gtt xrig,
        xx_refd_headers xrh
      WHERE xrig.amt_for_int_calc > 0
      AND xrig.int_244_calc_flag  = 'Y'
      AND prev_ref_id             = xrh.reference_id
      AND xrig.irt_id             = p_in_irt_id
      )
      LOOP
        l_interest_calc_amount := NULL;
        l_chr_exe_location     := 'RIP_0021';
        l_stmt_processing      := 'Calling refd_interest_calc procedure to calculate Refd Interest';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        --Calling refd_interest_calc procedure to calculate Refd Interest
        /* l_interest_calc_amount := refd_interest_calc (p_in_irt_id,
        l_cnt_rec.ref_id, l_cnt_rec.irt_ay, ( l_cnt_rec.amt_for_int_calc - MOD
        (l_cnt_rec.amt_for_int_calc, 100) ),
        -- NVL (l_cnt_rec.ref_to_date,
        NVL( l_cnt_rec.refd_identified_date, l_cnt_rec.refd_identified_date
        ), l_cnt_rec.irt_returns_due_date, l_cnt_rec.vld_orgirt_date );*/
        --COMMENTED AS PART OF HOTFIX#126136
        --ADD CHANGES HERE--HOTFIX#126136
        SELECT "val_filing_status_cd"
        INTO L_VAL_FILING_STATUS_CD
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id"=p_in_irt_id;
        write_debug( g_debug_flag ,'val_filling status '|| L_VAL_FILING_STATUS_CD);
        /*START OF CHANGES FOR NEGATIVE INTEREST CALCULATION*/
        IF (L_VAL_FILING_STATUS_CD='O') THEN
          write_debug( g_debug_flag , 'l_cnt_rec.amt_for_int_calc'|| l_cnt_rec.amt_for_int_calc);
          l_interest_calc_amount := refd_interest_calc_new ( p_in_irt_id, --Added
          -- as a Part of CR_HWSW_0552 - 22-JUN-2016 -- created new function refd_interest_calc_new to calculate interest for HF#171927 on 8-May-2018
          l_cnt_rec.ref_id, l_cnt_rec.irt_ay, ( l_cnt_rec.amt_for_int_calc -
          MOD (l_cnt_rec.amt_for_int_calc, 100) ), NVL( l_cnt_rec.refd_identified_date, l_cnt_rec.refd_identified_date ), l_cnt_rec.irt_returns_due_date, l_cnt_rec.vld_orgirt_date );
          write_debug( g_debug_flag , 'l_interest_calc_amount'|| l_interest_calc_amount);
        ELSE
          l_interest_calc_amount := refd_interest_calc_new ( l_cnt_rec.irt_id, --
          -- Added as a Part of CR_HWSW_0552 - 22-JUN-2016 -- created new function refd_interest_calc_new to calculate interest for HF#171927 on 8-May-2018
          l_cnt_rec.ref_id, l_cnt_rec.irt_ay, ( l_cnt_rec.amt_for_int_calc -
          MOD (l_cnt_rec.amt_for_int_calc, 100) ), NVL( l_cnt_rec.refd_identified_date, l_cnt_rec.refd_identified_date ), l_cnt_rec.irt_returns_due_date, l_cnt_rec.vld_orgirt_date );
        END IF;
        /*END OF CHANGES FOR NEGATIVE INTEREST CALCULATION*/
        --End Of Changes HOTFIX#126136
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| ' Interest Computed ' || l_interest_calc_amount);
        l_chr_exe_location := 'RIP_0022';
        l_stmt_processing  :='Updating interest amount to xx_rfnd_inst_gtt ' ;
        WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
        IF (L_INTEREST_CALC_AMOUNT < 0) THEN
          L_CHR_EXE_LOCATION      := 'RIP_0021.5';
          L_STMT_PROCESSING       := 'Original Entry Not present in Interest On Refd Table';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          RAISE CUSTOM_EXCEPTION;
        END IF;
        -- Updating interest amount to xx_rfnd_inst_gtt
        UPDATE xx_rfnd_inst_gtt
        SET int_244_calc_amt = ROUND (l_interest_calc_amount, 0)
        WHERE prev_ref_id    = l_cnt_rec.ref_id
        AND seq              = l_cnt_rec.seq;
      END LOOP; -- FOR l_cnt_rec IN (SELECT xrig.seq seq
      l_chr_exe_location := 'RIP_0023';
      l_stmt_processing  :='inserting records to xx_REF_INT_LINES';
	  dbms_output.put_line('inserting records to xx_REF_INT_LINES');
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO xx_ref_int_lines
        (
          eligible_interest_amount,
          ref_to_date,
          amt_for_int_calc,
          int_244_calc_amt,
          int_244_calc_flag,
          rct_ref_id,
          prev_ref_id,
          irt_id,
          seq,
          creation_date
        )
        (SELECT eligible_interest_amount,
            ref_to_date,
            amt_for_int_calc,
            NVL (int_244_calc_amt, 0),
            int_244_calc_flag,
            rect_ref_id,
            prev_ref_id,
            irt_id,
            seq,
            --SYSDATE  --Commented for Hotfix_199485 on 13-MAR-2019
            ref_to_date --Added for Hotfix_199485 on 13-MAR-2019
          FROM xx_rfnd_inst_gtt
          WHERE irt_id = p_in_irt_id
        );
    ELSE -- IF l_num_chk_cnt <> 0
      l_chr_exe_location := 'RIP_0024';
      l_stmt_processing  := 'Calling refd_interest_calc procedure to calculate Interest';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      l_interest_amount := 0;
      l_interest_amount := refd_interest_calc_new -- created new function refd_interest_calc_new to calculate interest for HF#171927 on 8-May-2018
      ( p_in_irt_id,cur_refd_headers_rec.reference_id , cur_refd_headers_rec.irt_ay , ( cur_refd_headers_rec.refd_identified_amount - MOD ( cur_refd_headers_rec.refd_identified_amount, 100 ) )
      -- , NVL (cur_refd_headers_rec.ref_to_date
      ,NVL (cur_refd_headers_rec.refd_identified_date , cur_refd_headers_rec.refd_identified_date) , cur_refd_headers_rec.irt_returns_due_date , cur_refd_headers_rec.vld_orgirt_date ) ;
      IF ( L_INTEREST_CALC_AMOUNT < 0 ) THEN
        L_CHR_EXE_LOCATION       := 'RIP_0021.5';
        L_STMT_PROCESSING        := 'Original Entry Not present in Interest On Refd Table';
        write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
        RAISE CUSTOM_EXCEPTION;
      END IF;
      l_chr_exe_location := 'RIP_0024-A';
      l_stmt_processing  :='refd_interest Computed is ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || l_interest_amount ) ;
    END IF; -- IF l_num_chk_cnt <> 0
    BEGIN
      l_chr_exe_location := 'RIP_0025';
      l_stmt_processing  := 'Getting total interest amount from xx_rfnd_inst_gtt';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      l_tot_interest_amount := NULL;
      SELECT SUM (int_244_calc_amt),
        SUM (AMT_FOR_INT_CALC) -- Added for HF#171927 on 8-May-2018
      INTO l_tot_interest_amount,
        l_tot_eligible_amt -- Added for HF#171927 on 8-May-2018
      FROM xx_rfnd_inst_gtt
      WHERE int_244_calc_flag = 'Y'
      AND rect_ref_id         = cur_refd_headers_rec.reference_id
      AND amt_for_int_calc    > 0;
      write_debug ( g_debug_flag ,'l_tot_interest_amount: ' ||'-'||l_tot_interest_amount||'L_INTEREST_CALC_AMOUNT: '||L_INTEREST_CALC_AMOUNT ) ;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      l_tot_interest_amount := NULL;
    END;
    IF l_tot_interest_amount IS NOT NULL THEN
      l_chr_exe_location     := 'RIP_0026';
      l_stmt_processing      := 'Total Refd Interest Amount update -POST INTEREST CALC';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      write_debug( g_debug_flag ,'l_tot_interest_amount: ' ||'-'||l_tot_interest_amount );
      --Total Refd Interest Amount update -POST INTEREST CALC
      UPDATE xx_refd_headers header
      SET header.refd_interest_amount = ROUND (l_tot_interest_amount, 0),
        HEADER.ATTRIBUTE6               = L_TOT_ELIGIBLE_AMT,              -- Added to store the total eligible amt out of 100/200 for HF#171927 on 8-May-2018
        header.ATTRIBUTE7               = ROUND (L_TOT_INTEREST_AMOUNT, 0) -- Added to store the total interest amt out of 100/200 for HF#171927 on 8-May-2018
      WHERE header.reference_id         = cur_refd_headers_rec.reference_id;
    ELSE -- IF l_tot_interest_amount IS NOT NULL
      l_chr_exe_location := 'RIP_0027';
      l_stmt_processing  := 'Total Refd Interest Amount update -POST INTEREST CALC';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || l_interest_amount );
      --Total Refd Interest Amount update -POST INTEREST CALC
      UPDATE xx_refd_headers header
      SET header.refd_interest_amount = ROUND (l_interest_amount, 0),
        HEADER.ATTRIBUTE6               = CUR_REFD_HEADERS_REC.REFD_IDENTIFIED_AMOUNT, -- Added to store the total eligible amt out of 100/200 for HF#171927 on 8-May-2018
        HEADER.ATTRIBUTE7               = ROUND (L_INTEREST_AMOUNT, 0)                     -- Added to store the total interest amt out of 100/200 for HF#171927 on 8-May-2018
      WHERE header.reference_id         = cur_refd_headers_rec.reference_id;
    END IF; -- IF l_tot_interest_amount IS NOT NULL
    l_chr_exe_location := 'RIP_0028';
    l_stmt_processing  :='Total Refd Amount update -POST INTEREST CALC';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- Total Refd Amount update -POST INTEREST CALC
    --Added as a Part of Delay Attribute - Starts Here - 11-jun-2016
    --INTEREST CALCULATION STARTS FOR SAT PAYMENTS - Added on 11-Jun-2016
    BEGIN

      SELECT "filing_dt",
        "type_of_return",
        "defective_comm_sent_dt",
        "corrective_filiing_date",
        NVL("input_err_flag",'X')
        ,
        "val_filing_status_cd"
      INTO V_FILING_DT,

        V_TYPE_OF_RETURN,
        V_DEFECTIVE_COMM_SENT_DT,
        V_CORRECTIVE_FILIING_DATE,
        L_INPUT_ERR_FLAG 
        ,
        L_VAL_FILING_STATUS_CD
      FROM "process_store"."interest_on_refd"@psql_process_fas
      WHERE to_char("irt_id")        =P_IN_IRT_ID;
      IF V_TYPE_OF_RETURN ='CORRECTED' THEN
        --    L_DEF_DELAY_MONTHS := MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(
        -- V_CORRECTIVE_FILIING_DATE ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (
        -- TO_CHAR (V_DEFECTIVE_COMM_SENT_DT, 'MON-YYYY'), 'MON-YYYY'));
        L_DEF_DELAY_MONTHS := TRUNC(MONTHS_BETWEEN( TO_DATE (TO_CHAR ( V_CORRECTIVE_FILIING_DATE),'DD-MON-YYYY'), TO_DATE (TO_CHAR ( V_DEFECTIVE_COMM_SENT_DT), 'DD-MON-YYYY')));
      ELSE
        L_DEF_DELAY_MONTHS :=0;
      END IF;
    EXCEPTION
    WHEN OTHERS THEN
	dbms_output.put_line('Debug POST INTEREST CALC 1');
      L_CHR_EXE_LOCATION := 'RIP_0027_300';
      L_STMT_PROCESSING  :='SQLERRM ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing);
      RAISE CUSTOM_EXCEPTION;
    END;

    --Added by Sudha on 18-Jan-2018 for HF#171927 starts
    BEGIN
      IF NVL (total_300_collect_calc_ref(cur_refd_headers_rec.reference_id), 0) > (0.1 * cur_refd_headers_rec.total_xx_computed) THEN
        l_eligible_amt_300                                                       := NVL (total_300_collect_calc_ref(cur_refd_headers_rec.reference_id), 0);
      END IF;
      SELECT COUNT (1)
      INTO l_num_chk_cnt
      FROM xx_refd_headers xrh,
        xx_refd_lines xrl
      WHERE xrh.reference_id                                    = xrl.reference_id
      AND NVL (l_eligible_amt_300, 0)                          >= 0 -- To check if interest is out of 300 payment
      AND xrl.minor_head                                        = '300'
      AND xrl.reference_id                                      = xrh.reference_id
      AND xrh.irt_id                                            = cur_refd_headers_rec.irt_id
      AND (xrh.id_number, xrh.irt_ay, xrh.irt_schedule_type ) IN
        (SELECT xrh.id_number,
          xrh.irt_ay,
          xrh.irt_schedule_type
        FROM ra_customer_trx_all rcta,
          ra_cust_trx_types_all rctt,
          xx_refd_headers xrh
        WHERE xrh.customer_trx_id        = rcta.customer_trx_id
        AND rcta.cust_trx_type_id        = rctt.cust_trx_type_id
        AND rctt.attribute2             IN ('RECTIFICATION','REVISED')
        AND NVL (l_eligible_amt_300, 0) >= 0 --Changed eligible_interest_amount to l_eligible_amt_300 for HF#171927 (Jtrac#381) on 10-Dec-2018
        AND xrh.id_number               = cur_refd_headers_rec.id_number
        AND xrh.irt_ay                   = cur_refd_headers_rec.irt_ay
        AND xrh.irt_schedule_type        = cur_refd_headers_rec.irt_schedule_type
        AND xrh.reference_id             = cur_refd_headers_rec.reference_id
        )
      GROUP BY XRH.ID_NUMBER,
        xrh.irt_ay,
        xrh.irt_schedule_type
      HAVING COUNT (1) >= 1;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      l_num_chk_cnt := 0;
    END;
    IF l_num_chk_cnt     <> 0 THEN -- For Rectification and revised cases
      l_chr_exe_location := 'RIP_8000';
      write_debug( g_debug_flag ,l_chr_exe_location);
	  dbms_output.put_line(l_chr_exe_location);
      --IF ((L_VAL_FILING_STATUS_CD = 'T' AND L_INPUT_ERR_FLAG = 'N') OR (L_VAL_FILING_STATUS_CD = 'R')) THEN -- rectification with input error flag N and Revised orders -- Removed INPUT_ERROR_FLAG check on 23-Jan-2018
      BEGIN

        SELECT "orig_irt_id"
        INTO v_prev_irt_id
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id"      = cur_refd_headers_rec.irt_id;
        IF v_prev_irt_id IS NULL THEN
          write_debug( g_debug_flag ,'Original IRT_ID found null in interest on refd table' );
		  dbms_output.put_line('Original IRT_ID found null in interest on refd table' );
          raise CUSTOM_EXCEPTION;
        END IF;
      EXCEPTION
      WHEN no_data_found THEN
        write_debug( g_debug_flag ,'No entry found in interest on refd table' );
        raise CUSTOM_EXCEPTION;
        END;
      /*BEGIN
      SELECT reference_id
      INTO v_prev_ref_id
      FROM xx_REFD_HEADERS
      WHERE IRT_ID = TO_CHAR(V_PREV_IRT_ID);
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
      v_prev_ref_id := NULL;
      END; */
      FOR REFID IN
      (SELECT reference_id
      FROM xx_REFD_HEADERS
      WHERE IRT_ID = TO_CHAR(V_PREV_IRT_ID)
      )
      LOOP
        V_PREV_REF_ID       := REFID.REFERENCE_ID; -- Added due to multiple refd head issue on 25-JUN-2018
        L_ELIGIBLE_PREV_300 := NVL (TOTAL_300_COLLECT_CALC_REF(V_PREV_REF_ID), 0);
        L_ELIGIBLE_PREV_300 := NVL (TOTAL_300_COLLECT_CALC_REF(V_PREV_REF_ID), 0);
        write_debug( g_debug_flag ,'l_eligible_amt_300: '||l_eligible_amt_300);
        WRITE_DEBUG( G_DEBUG_FLAG ,'L_ELIGIBLE_PREV_300: '||L_ELIGIBLE_PREV_300);
        WRITE_DEBUG( G_DEBUG_FLAG ,'v_prev_ref_id: '||v_prev_ref_id);
		dbms_output.put_line('l_eligible_amt_300: '||l_eligible_amt_300);
		dbms_output.put_line('L_ELIGIBLE_PREV_300: '||L_ELIGIBLE_PREV_300);
        BEGIN -- to Update xx_REFD_LINES.ATTRIBUTE4 column with previous
          FOR IDX IN
          (SELECT NVL(ATTRIBUTE4,0) ATTRIBUTE4,
		    NVL(ATTRIBUTE12,0) ATTRIBUTE12,--Added for 244A requirement Anjali
            NVL(ATTRIBUTE13,0)attribute13,
            NVL(ATTRIBUTE14,0)attribute14,
            NVL(ATTRIBUTE15,0)attribute15,
            CASH_RECEIPT_ID -- Added attribute13, attribute14, attribute15 for delay calculation
          FROM xx_REFD_LINES
          WHERE REFERENCE_ID =TO_CHAR(v_prev_ref_id)
          AND MINOR_HEAD     ='300'
          )
          LOOP
            UPDATE xx_REFD_LINES
            SET ATTRIBUTE4     = IDX.ATTRIBUTE4,
				ATTRIBUTE12    = IDX.ATTRIBUTE12,--Added for 244A requirement Anjali
              attribute13      = IDX.attribute13, -- Added to update any previous delays due to defective filing
              attribute14      = IDX.attribute14, -- Added to update any previous delays inclusive of defective filing and 300 payment delays
              attribute15      = IDX.attribute15  -- Added to update any previous delays due to 300 payments
            WHERE REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
            AND CASH_RECEIPT_ID=IDX.CASH_RECEIPT_ID;
          END LOOP;
          WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: '||SQL%ROWCOUNT);
		  dbms_output.put_line('Updated attributes in xx_REFD_LINES: '||SQL%ROWCOUNT);
        END;
        IF l_eligible_amt_300 = l_eligible_prev_300 THEN-- For same eligible amount we would not calculate new interest Scenario # 1
          BEGIN
            WRITE_DEBUG( G_DEBUG_FLAG ,'Inside same refd amount check');
            SELECT ATTRIBUTE4,
              ATTRIBUTE5
            INTO L_SAT_ELIGIBLE_AMT,
              L_SAT_INTEREST_AMT
            FROM xx_refd_headers
            WHERE reference_id=v_prev_ref_id; -- To fetch eligible amount and interest amount
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            write_debug( g_debug_flag ,'No record found for reference_id: '||v_prev_ref_id);
			dbms_output.put_line('No record found for reference_id: '||v_prev_ref_id);
            --raise
          END;
          write_debug( g_debug_flag, 'L_SAT_ELIGIBLE_AMT:'||L_SAT_ELIGIBLE_AMT);
          write_debug( g_debug_flag, 'L_SAT_INTEREST_AMT:'||L_SAT_INTEREST_AMT);
        ELSIF l_eligible_amt_300 > l_eligible_prev_300 THEN -- For Increase in amount Scenario # 2
          write_debug( g_debug_flag ,'Inside increase refd amount check');
          L_SAT_INTEREST_AMT :=0;
          L_SAT_ELIGIBLE_AMT :=0;
          IF v_prev_ref_id   IS NOT NULL THEN
            FOR J IN -- For picking new 300 receipts
            /*(SELECT             *
            FROM xx_REFD_LINES
            WHERE REFERENCE_ID       =CUR_REFD_HEADERS_REC.REFERENCE_ID
            AND MINOR_HEAD           ='300'
            AND cash_receipt_id NOT IN
            (SELECT cash_receipt_id
            FROM xx_refd_lines
            WHERE reference_id = v_prev_ref_id
            AND minor_head     = '300'
            )
            )*/
            --Commented by Neha for issue for change in Refd out of same receipts
            (
            SELECT *
            FROM
              (SELECT A.RECEIPT_DATE,
                (A.EXCESS_RECEIPT_AMOUNT-B.EXCESS_RECEIPT_AMOUNT) EXCESS_RECEIPT_AMOUNT,
                A.CASH_RECEIPT_ID -- For existing 300 receipts interest to be calculated only on differential amount
              FROM xx_REFD_LINES A,
                xx_REFD_LINES B
              WHERE A.REFERENCE_ID        = CUR_REFD_HEADERS_REC.REFERENCE_ID
              AND B.REFERENCE_ID          = v_prev_ref_id
              AND A.MINOR_HEAD            ='300'
              AND A.CASH_RECEIPT_ID       = B.CASH_RECEIPT_ID
              AND A.EXCESS_RECEIPT_AMOUNT > B.EXCESS_RECEIPT_AMOUNT
              AND a.minor_head            = b.minor_head
              ) --Added by Neha for issue for change in Refd out of same receipts
            UNION
              (SELECT RECEIPT_DATE,
                EXCESS_RECEIPT_AMOUNT,
                CASH_RECEIPT_ID -- For new 300 receipts
              FROM xx_REFD_LINES
              WHERE REFERENCE_ID       =CUR_REFD_HEADERS_REC.REFERENCE_ID
              AND MINOR_HEAD           ='300'
              AND cash_receipt_id NOT IN
                (SELECT cash_receipt_id
                FROM xx_refd_lines
                WHERE reference_id = v_prev_ref_id
                AND MINOR_HEAD     = '300'
                )
              )
            )
            /*         (SELECT *
            FROM xx_REFD_LINES
            where REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
            AND MINOR_HEAD     ='300' -- Picking all receipts for interest calculation
            )*/
            LOOP L_REC_INTEREST_AMT :=0;
          SELECT "filing_dt"
          INTO V_FILING_DT_ORG
          FROM "process_store"."interest_on_refd"@psql_process_fas a
          WHERE "id_cd"             = cur_refd_headers_rec.id_number
          AND "assment_year"         = cur_refd_headers_rec.irt_ay
          AND "val_filing_status_cd" = 'O'
          AND "irt_id"               =
            (SELECT "irt_id"
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "id_number"             = a."id_cd"
            AND "assessment_year"        = a."assment_year"
            AND "x_val_filing_status_cd" = 'O'
            AND "process_status_code"       = 65
            ); -- To fetch the first Valid Original return processed in ABC
          IF V_FILING_DT_ORG > J.RECEIPT_DATE THEN
            P_START_DATE    :=V_FILING_DT_ORG;
          ELSE
            P_START_DATE :=J.RECEIPT_DATE;
          END IF;
          write_debug( g_debug_flag, 'V_FILING_DT_ORG:'||V_FILING_DT_ORG);
          write_debug( g_debug_flag, 'J.RECEIPT_DATE:'||J.RECEIPT_DATE);
          L_SAT_INT_MONTHS :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (CUR_REFD_HEADERS_REC.REFD_IDENTIFIED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE), 'DD-MON-YYYY'))))+1;
          write_debug( g_debug_flag, 'L_SAT_INT_MONTHS:'||L_SAT_INT_MONTHS);
          --To compute delay months
          BEGIN
            /*SELECT MIN(IRT_ID)
            INTO v_min_claim_irt_id
            FROM IRT_MATCHING.IRT_CLAIMS_MATCHING         --not commented for ABC-2.0 - Bhagya
            WHERE IRT_ID_CD      = CUR_REFD_HEADERS_REC.ID_NUMBER
            AND IRT_ASSMENT_YEAR  = CUR_REFD_HEADERS_REC.IRT_AY
            AND FAS_ID            = J.CASH_RECEIPT_ID
            AND IRT_MINOR_HEAD_CD = '300'
            AND EXISTS
              (SELECT 1
              FROM "process_store"."irt_process_control_mstr"@psql_process_fas
              WHERE "id_number"        = CUR_REFD_HEADERS_REC.ID_NUMBER
              AND "assessment_year"    = CUR_REFD_HEADERS_REC.IRT_AY
              AND "x_e_ack_recpt_dt" >= to_date(TO_CHAR((P_START_DATE)), 'DD-MON-YYYY')
              );*/

	--Replacing irt_claims_matching with ar_cash_receipts_all. ABC-2.0 -Bhagya
			  SELECT MIN(attribute12)
            INTO v_min_claim_irt_id
            FROM ar_cash_receipts_all         --not commented for ABC-2.0 - Bhagya
            WHERE attribute5      = CUR_REFD_HEADERS_REC.ID_NUMBER
            AND attribute4  = CUR_REFD_HEADERS_REC.IRT_AY
            AND cash_receipt_id            = J.CASH_RECEIPT_ID
            AND attribute2 = '300'
            AND EXISTS
              (SELECT 1
              FROM "process_store"."irt_process_control_mstr"@psql_process_fas
              WHERE "id_number"        = CUR_REFD_HEADERS_REC.ID_NUMBER
              AND "assessment_year"    = CUR_REFD_HEADERS_REC.IRT_AY
              AND "x_e_ack_recpt_dt" >= to_date(TO_CHAR((P_START_DATE)), 'DD-MON-YYYY')
              );

          EXCEPTION
          WHEN no_data_found THEN
            v_min_claim_irt_id := '';
            --        l_receipt_no := NULL;
          END;
          WRITE_DEBUG( G_DEBUG_FLAG, 'v_min_claim_irt_id: '||v_min_claim_irt_id);
          IF v_min_claim_irt_id IS NOT NULL THEN
            -- Added for HF#171927 by Sudha on 10-Jan-2018 -- starts
            -- For Original and Revised the filing date coming correctly in PCM.
            -- For Rectification, taking filing date from INTEREST_ON_REFD table.
            SELECT "x_val_filing_status_cd"
            INTO L_FILING_CODE
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "irt_id" =v_min_claim_irt_id;
            IF L_FILING_CODE IN ('O','R') THEN
              SELECT "x_e_ack_recpt_dt"
              INTO v_first_claim_dt
              FROM "process_store"."irt_process_control_mstr"@psql_process_fas
              WHERE "irt_id"      = v_min_claim_irt_id;
            ELSIF L_FILING_CODE = 'T' THEN
              SELECT "rect_file_dt"
              INTO v_first_claim_dt
              FROM "process_store"."interest_on_refd"@psql_process_fas
              WHERE "irt_id" = v_min_claim_irt_id;
            END IF;
            -- Added for HF#171927 by Sudha on 10-Jan-2018 -- ends
            WRITE_DEBUG( G_DEBUG_FLAG, 'V_FIRST_CLAIM_DT:'||V_FIRST_CLAIM_DT);
            WRITE_DEBUG( G_DEBUG_FLAG, 'P_START_DATE: '||P_START_DATE);
            L_DELAY_MONTHS_300 := ABS(TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (V_FIRST_CLAIM_DT), 'DD-MON-YYYY'))))); -- Delay from Start date to First Claim Date to be taken here -- Removed +1 for HF#171927 on 28-Feb-2018 by sudha
            WRITE_DEBUG( G_DEBUG_FLAG, 'L_DELAY_MONTHS_300:'||L_DELAY_MONTHS_300);
          elsif v_min_claim_irt_id IS NULL THEN
            L_DELAY_MONTHS_300     := ABS(TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (CUR_REFD_HEADERS_REC.REFD_IDENTIFIED_DATE), 'DD-MON-YYYY'))))); -- complete period is delay attributable to Customer, this scenario is possible only if the receipt is not claimed at all-- Removed +1 for HF#171927 on 28-Feb-2018 by sudha
          END IF;
          L_TOT_DELAY_MONTHS := L_DEF_DELAY_MONTHS + L_DELAY_MONTHS_300;
          write_debug( g_debug_flag, 'L_TOT_DELAY_MONTHS:'||L_TOT_DELAY_MONTHS);
          --L_REC_INTEREST_AMT :=((J.EXCESS_RECEIPT_AMOUNT -MOD(J.EXCESS_RECEIPT_AMOUNT,100))*(L_SAT_INT_MONTHS-L_DEF_DELAY_MONTHS) *.5)/100; Commented for total delay subtraction
          L_REC_INTEREST_AMT :=((J.EXCESS_RECEIPT_AMOUNT -MOD(J.EXCESS_RECEIPT_AMOUNT,100))*(L_SAT_INT_MONTHS-L_TOT_DELAY_MONTHS) *.5)/100; -- Changed L_DEF_DELAY_MONTHS to L_TOT_DELAY_MONTHS for delay subtraction
          write_debug( g_debug_flag, 'L_REC_INTEREST_AMT:'||L_REC_INTEREST_AMT);
          L_SAT_INTEREST_AMT :=L_SAT_INTEREST_AMT +L_REC_INTEREST_AMT;
          L_SAT_ELIGIBLE_AMT :=L_SAT_ELIGIBLE_AMT +J.EXCESS_RECEIPT_AMOUNT;
          UPDATE xx_REFD_LINES
          SET ATTRIBUTE4     =ROUND(L_REC_INTEREST_AMT,0),
			ATTRIBUTE12      = L_SAT_INT_MONTHS, --Added for 244A requirement Anjali
            attribute14      = L_TOT_DELAY_MONTHS, -- Added to store total delay inclusive of defective delay and 300 payment delay
            attribute15      = L_DELAY_MONTHS_300  -- Added to store delay value due to 300 payment
          WHERE REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
          AND CASH_RECEIPT_ID=J.CASH_RECEIPT_ID;
        END LOOP;
        L_SAT_ELIGIBLE_AMT := L_SAT_ELIGIBLE_AMT + L_ELIGIBLE_PREV_300; -- To add the previously calculated 300 interest amount
        SELECT NVL(attribute5,0)
        INTO L_PREV_INT_AMT
        FROM xx_REFD_HEADERS
        WHERE REFERENCE_ID  = V_PREV_REF_ID;
        L_SAT_INTEREST_AMT := L_SAT_INTEREST_AMT + L_PREV_INT_AMT;
        write_debug( g_debug_flag, 'L_SAT_ELIGIBLE_AMT:'||L_SAT_ELIGIBLE_AMT);
        write_debug( g_debug_flag, 'L_ELIGIBLE_PREV_300:'||L_ELIGIBLE_PREV_300);
        WRITE_DEBUG( G_DEBUG_FLAG, 'L_SAT_INTEREST_AMT:'||L_SAT_INTEREST_AMT);
        write_debug( g_debug_flag, 'L_PREV_INT_AMT:'||L_PREV_INT_AMT);
      elsif v_prev_ref_id IS NULL THEN
        write_debug( g_debug_flag ,'Inside increase refd amount check');
        L_SAT_INTEREST_AMT :=0;
        L_SAT_ELIGIBLE_AMT :=0;
        FOR J  IN -- For picking new 300 receipts
        (SELECT *
        FROM xx_REFD_LINES
        WHERE REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
        AND MINOR_HEAD     ='300' -- Picking all receipts for interest calculation
        )
        LOOP
          L_REC_INTEREST_AMT :=0;
          SELECT "filing_dt"
          INTO V_FILING_DT_ORG -- Changed from V_FILING_DT to V_FILING_DT_ORG for delay deduction
          FROM "process_store"."interest_on_refd"@psql_process_fas a
          WHERE "id_cd"             = cur_refd_headers_rec.id_number
          AND "assment_year"         = cur_refd_headers_rec.irt_ay
          AND "val_filing_status_cd" = 'O'
          AND "irt_id"               =
            (SELECT "irt_id"
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "id_number"            = a."id_cd"
            AND "assessment_year"         = a."assment_year"
            AND "x_val_filing_status_cd" = 'O'
            AND "process_status_code"       = 65
            ); -- To fetch the first Valid Original return processed in ABC
          IF V_FILING_DT_ORG > J.RECEIPT_DATE THEN
            P_START_DATE    :=V_FILING_DT_ORG;
          ELSE
            P_START_DATE :=J.RECEIPT_DATE;
          END IF;
          L_SAT_INT_MONTHS :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (CUR_REFD_HEADERS_REC.REFD_IDENTIFIED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE), 'DD-MON-YYYY'))))+1;
          write_debug( g_debug_flag, 'L_SAT_INT_MONTHS:'||L_SAT_INT_MONTHS);
          ---To compute delay months
          BEGIN
           /* SELECT MIN(IRT_ID)
            INTO v_min_claim_irt_id
            FROM IRT_MATCHING.IRT_CLAIMS_MATCHING
            WHERE IRT_ID_CD      = CUR_REFD_HEADERS_REC.ID_NUMBER
            AND IRT_ASSMENT_YEAR  = CUR_REFD_HEADERS_REC.IRT_AY
            AND FAS_ID            = J.CASH_RECEIPT_ID
            AND IRT_MINOR_HEAD_CD = '300'
            AND EXISTS
              (SELECT 1
              FROM "process_store"."irt_process_control_mstr"@psql_process_fas
              WHERE "id_number"        = CUR_REFD_HEADERS_REC.ID_NUMBER
              AND "assessment_year"    = CUR_REFD_HEADERS_REC.IRT_AY
              AND "x_e_ack_recpt_dt" >= to_date(TO_CHAR((P_START_DATE)), 'DD-MON-YYYY')
              );
			  */			  
 --Replacing irt_claims_matching with ar_cash_receipts_all. ABC-2.0 -Bhagya
			  SELECT MIN(attribute12)
            INTO v_min_claim_irt_id
            FROM ar_cash_receipts_all         --not commented for ABC-2.0 - Bhagya
            WHERE attribute5      = CUR_REFD_HEADERS_REC.ID_NUMBER
            AND attribute4  = CUR_REFD_HEADERS_REC.IRT_AY
            AND cash_receipt_id            = J.CASH_RECEIPT_ID
            AND attribute2 = '300'
            AND EXISTS
			(SELECT 1
              FROM "process_store"."irt_process_control_mstr"@psql_process_fas
              WHERE "id_number"        = CUR_REFD_HEADERS_REC.ID_NUMBER
              AND "assessment_year"    = CUR_REFD_HEADERS_REC.IRT_AY
              AND "x_e_ack_recpt_dt" >= to_date(TO_CHAR((P_START_DATE)), 'DD-MON-YYYY')
              );

          EXCEPTION
          WHEN no_data_found THEN
            v_min_claim_irt_id := '';
            --        l_receipt_no := NULL;
          END;
          WRITE_DEBUG( G_DEBUG_FLAG, 'v_min_claim_irt_id: '||v_min_claim_irt_id);
          IF v_min_claim_irt_id IS NOT NULL THEN
            -- Added for HF#171927 by Sudha on 10-Jan-2018 -- starts
            -- For Original and Revised the filing date coming correctly in PCM.
            -- For Rectification, taking filing date from INTEREST_ON_REFD table.
            SELECT "x_val_filing_status_cd"
            INTO L_FILING_CODE
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "irt_id" =v_min_claim_irt_id;
            IF L_FILING_CODE IN ('O','R') THEN
              SELECT "x_e_ack_recpt_dt"
              INTO v_first_claim_dt
              FROM "process_store"."irt_process_control_mstr"@psql_process_fas
              WHERE "irt_id"      = v_min_claim_irt_id;
            ELSIF L_FILING_CODE = 'T' THEN
              SELECT "rect_file_dt"
              INTO v_first_claim_dt
              FROM "process_store"."interest_on_refd"@psql_process_fas
              WHERE "irt_id" = v_min_claim_irt_id;
            END IF;
            -- Added for HF#171927 by Sudha on 10-Jan-2018 -- ends
            WRITE_DEBUG( G_DEBUG_FLAG, 'V_FIRST_CLAIM_DT:'||V_FIRST_CLAIM_DT);
            L_DELAY_MONTHS_300 := ABS(TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (V_FIRST_CLAIM_DT), 'DD-MON-YYYY'))))); -- Delay from Start date to First Claim Date to be taken here -- Removed +1 for HF#171927 on 28-Feb-2018 by sudha
            WRITE_DEBUG( G_DEBUG_FLAG, 'L_DELAY_MONTHS_300:'||L_DELAY_MONTHS_300);
          elsif v_min_claim_irt_id IS NULL THEN
            L_DELAY_MONTHS_300     := ABS(TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (CUR_REFD_HEADERS_REC.REFD_IDENTIFIED_DATE), 'DD-MON-YYYY'))))); -- complete period is delay attributable to Customer, this scenario is possible only if the receipt is not claimed at all -- Removed +1 for HF#171927 on 28-Feb-2018 by sudha
          END IF;
          L_TOT_DELAY_MONTHS := L_DEF_DELAY_MONTHS + L_DELAY_MONTHS_300;
          write_debug( g_debug_flag, 'L_TOT_DELAY_MONTHS:'||L_TOT_DELAY_MONTHS);
          L_REC_INTEREST_AMT :=((J.EXCESS_RECEIPT_AMOUNT -MOD(J.EXCESS_RECEIPT_AMOUNT,100))*(L_SAT_INT_MONTHS-L_TOT_DELAY_MONTHS) *.5)/100; -- Changed L_DEF_DELAY_MONTHS to L_TOT_DELAY_MONTHS for delay subtraction
          write_debug( g_debug_flag, 'L_REC_INTEREST_AMT:'||L_REC_INTEREST_AMT);
          L_SAT_INTEREST_AMT :=L_SAT_INTEREST_AMT +L_REC_INTEREST_AMT;
          L_SAT_ELIGIBLE_AMT :=L_SAT_ELIGIBLE_AMT +J.EXCESS_RECEIPT_AMOUNT;
          UPDATE xx_REFD_LINES
          SET ATTRIBUTE4     =ROUND(L_REC_INTEREST_AMT,0),
		    ATTRIBUTE12= L_SAT_INT_MONTHS,--Added for 244A requirement Anjali
            attribute14      = L_TOT_DELAY_MONTHS, -- Added to store total delay inclusive of defective delay and 300 payment delay
            attribute15      = L_DELAY_MONTHS_300  -- Added to store delay value due to 300 payment
          WHERE REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
          AND CASH_RECEIPT_ID=J.CASH_RECEIPT_ID;
        END LOOP;
        --    L_SAT_ELIGIBLE_AMT := L_SAT_ELIGIBLE_AMT + L_ELIGIBLE_PREV_300; -- To add the previously calculated 300 interest amount
        --    SELECT NVL(refd_interest_amount,0)
        --    INTO L_PREV_INT_AMT
        --    FROM xx_REFD_HEADERS
        --    WHERE REFERENCE_ID  = V_PREV_REF_ID;
        --    L_SAT_INTEREST_AMT := L_SAT_INTEREST_AMT + L_PREV_INT_AMT; -- Commented since all receipts are already taken
        write_debug( g_debug_flag, 'L_SAT_ELIGIBLE_AMT:'||L_SAT_ELIGIBLE_AMT);
        write_debug( g_debug_flag, 'L_ELIGIBLE_PREV_300:'||L_ELIGIBLE_PREV_300);
        WRITE_DEBUG( G_DEBUG_FLAG, 'L_SAT_INTEREST_AMT:'||L_SAT_INTEREST_AMT);
        write_debug( g_debug_flag, 'L_PREV_INT_AMT:'||L_PREV_INT_AMT);
      END IF;                                             -- v_prev_ref_id is null check
    ELSIF l_eligible_amt_300 < l_eligible_prev_300 THEN ---- For decrease in amount - Scenario # 3
      write_debug( g_debug_flag ,'Inside decrease refd amount check');
      L_SAT_INTEREST_AMT :=0;
      L_SAT_ELIGIBLE_AMT :=0;
      BEGIN
        SELECT REFD_IDENTIFIED_DATE
        INTO L_REFD_IDENTIFIED_DT
        FROM xx_REFD_HEADERS
        WHERE IRT_ID= TO_CHAR(V_PREV_IRT_ID);
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        write_debug( g_debug_flag ,'Refd Identified date cannot be null: '||L_REFD_IDENTIFIED_DT);
        raise CUSTOM_EXCEPTION;
      END;
      write_debug( g_debug_flag ,'L_REFD_IDENTIFIED_DT: '||L_REFD_IDENTIFIED_DT);
      FOR J  IN -- For picking all 300 receipts
      (SELECT *
      FROM xx_REFD_LINES
      WHERE REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
      AND MINOR_HEAD     ='300'
      )
      LOOP
        L_REC_INTEREST_AMT :=0;
        SELECT "filing_dt"
        INTO V_FILING_DT_ORG -- Changed from V_FILING_DT to V_FILING_DT_ORG for delay deduction
        FROM "process_store"."interest_on_refd"@psql_process_fas a
        WHERE "id_cd"             = cur_refd_headers_rec.id_number
        AND "assment_year"         = cur_refd_headers_rec.irt_ay
        AND "val_filing_status_cd" = 'O'
        AND "irt_id"               =
          (SELECT "irt_id"
          FROM "process_store"."irt_process_control_mstr"@psql_process_fas
          WHERE "id_number"             = a."id_cd"
          AND "assessment_year"         = a."assment_year"
          AND "x_val_filing_status_cd" = 'O'
          AND "process_status_code"       = 65
          ); -- To fetch the first Valid Original return processed in ABC
        IF V_FILING_DT_ORG > J.RECEIPT_DATE THEN
          P_START_DATE    :=V_FILING_DT_ORG;
        ELSE
          P_START_DATE :=J.RECEIPT_DATE;
        END IF;
        write_debug( g_debug_flag, 'P_START_DATE:'||P_START_DATE);
        write_debug( g_debug_flag, 'J.EXCESS_RECEIPT_AMOUNT:'||J.EXCESS_RECEIPT_AMOUNT);
        L_SAT_INT_MONTHS :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (L_REFD_IDENTIFIED_DT),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE), 'DD-MON-YYYY'))))+1; --Changed end date to previous order a/c completion date
        write_debug( g_debug_flag, 'L_SAT_INT_MONTHS:'||L_SAT_INT_MONTHS);
        --To compute delay months
        BEGIN
         /* SELECT MIN(IRT_ID)
          INTO v_min_claim_irt_id
          FROM IRT_MATCHING.IRT_CLAIMS_MATCHING
          WHERE IRT_ID_CD      = CUR_REFD_HEADERS_REC.ID_NUMBER
          AND IRT_ASSMENT_YEAR  = CUR_REFD_HEADERS_REC.IRT_AY
          AND FAS_ID            = J.CASH_RECEIPT_ID
          AND IRT_MINOR_HEAD_CD = '300'
          AND EXISTS
            (SELECT 1
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "id_number"        = CUR_REFD_HEADERS_REC.ID_NUMBER
            AND "assessment_year"    = CUR_REFD_HEADERS_REC.IRT_AY
            AND "x_e_ack_recpt_dt" >= to_date(TO_CHAR((P_START_DATE)), 'DD-MON-YYYY')
            );*/

	--Replacing irt_claims_matching with ar_cash_receipts_all. ABC-2.0 -Bhagya
			  SELECT MIN(attribute12)
            INTO v_min_claim_irt_id
            FROM ar_cash_receipts_all         --not commented for ABC-2.0 - Bhagya
            WHERE attribute5      = CUR_REFD_HEADERS_REC.ID_NUMBER
            AND attribute4  = CUR_REFD_HEADERS_REC.IRT_AY
            AND cash_receipt_id            = J.CASH_RECEIPT_ID
            AND attribute2 = '300'
			AND EXISTS
            (SELECT 1
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "id_number"        = CUR_REFD_HEADERS_REC.ID_NUMBER
            AND "assessment_year"    = CUR_REFD_HEADERS_REC.IRT_AY
            AND "x_e_ack_recpt_dt" >= to_date(TO_CHAR((P_START_DATE)), 'DD-MON-YYYY')
            );

        EXCEPTION
        WHEN no_data_found THEN
          v_min_claim_irt_id := '';
          --        l_receipt_no := NULL;
        END;
        WRITE_DEBUG( G_DEBUG_FLAG, 'v_min_claim_irt_id: '||v_min_claim_irt_id);
        IF v_min_claim_irt_id IS NOT NULL THEN
          -- Added for HF#171927 by Sudha on 10-Jan-2018 -- starts
          -- For Original and Revised the filing date coming correctly in PCM.
          -- For Rectification, taking filing date from INTEREST_ON_REFD table.
          SELECT "x_val_filing_status_cd"
          INTO L_FILING_CODE
          FROM "process_store"."irt_process_control_mstr"@psql_process_fas
          WHERE "irt_id" =v_min_claim_irt_id;
          IF L_FILING_CODE IN ('O','R') THEN
            SELECT "x_e_ack_recpt_dt"
            INTO v_first_claim_dt
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "irt_id"      = v_min_claim_irt_id;
          ELSIF L_FILING_CODE = 'T' THEN
            SELECT "rect_file_dt"
            INTO v_first_claim_dt
            FROM "process_store"."interest_on_refd"@psql_process_fas
            WHERE "irt_id" = v_min_claim_irt_id;
          END IF;
          -- Added for HF#171927 by Sudha on 10-Jan-2018 -- ends
          WRITE_DEBUG( G_DEBUG_FLAG, 'V_FIRST_CLAIM_DT:'||V_FIRST_CLAIM_DT);
          L_DELAY_MONTHS_300 := ABS(TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (V_FIRST_CLAIM_DT), 'DD-MON-YYYY'))))); -- Delay from Start date to First Claim Date to be taken here  -- Removed +1 for HF#171927 on 28-Feb-2018 by sudha
          WRITE_DEBUG( G_DEBUG_FLAG, 'L_DELAY_MONTHS_300:'||L_DELAY_MONTHS_300);
        elsif v_min_claim_irt_id IS NULL THEN
          L_DELAY_MONTHS_300     := ABS(TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (CUR_REFD_HEADERS_REC.REFD_IDENTIFIED_DATE), 'DD-MON-YYYY'))))); -- complete period is delay attributable to Customer, this scenario is possible only if the receipt is not claimed at all -- Removed +1 for HF#171927 on 28-Feb-2018 by sudha
        END IF;
        L_TOT_DELAY_MONTHS := L_DEF_DELAY_MONTHS + L_DELAY_MONTHS_300;
        write_debug( g_debug_flag, 'L_TOT_DELAY_MONTHS:'||L_TOT_DELAY_MONTHS);
        L_REC_INTEREST_AMT :=((J.EXCESS_RECEIPT_AMOUNT -MOD(J.EXCESS_RECEIPT_AMOUNT,100))*(L_SAT_INT_MONTHS-L_TOT_DELAY_MONTHS) *.5)/100; -- Changed from L_DEF_DELAY_MONTHS to L_TOT_DELAY_MONTHS for delay substraction
        write_debug( g_debug_flag, 'L_REC_INTEREST_AMT:'||L_REC_INTEREST_AMT);
        L_SAT_INTEREST_AMT :=L_SAT_INTEREST_AMT +L_REC_INTEREST_AMT;
        L_SAT_ELIGIBLE_AMT :=L_SAT_ELIGIBLE_AMT +J.EXCESS_RECEIPT_AMOUNT;
        UPDATE xx_REFD_LINES
        SET ATTRIBUTE4     =ROUND(L_REC_INTEREST_AMT,0),
		  ATTRIBUTE12      = L_SAT_INT_MONTHS, --Added for 244A requirement Anjali
          attribute14      = L_TOT_DELAY_MONTHS, -- Added to store total delay inclusive of defective delay and 300 payment delay
          attribute15      = L_DELAY_MONTHS_300  -- Added to store delay value due to 300 payment
        WHERE REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
        AND CASH_RECEIPT_ID=J.CASH_RECEIPT_ID;
      END LOOP;
    END IF; -- l_eligible_amt_300 > l_eligible_prev_300
    write_debug( g_debug_flag, 'L_SAT_ELIGIBLE_AMT:'||L_SAT_ELIGIBLE_AMT);
    write_debug( g_debug_flag, 'L_ELIGIBLE_PREV_300:'||L_ELIGIBLE_PREV_300);
    WRITE_DEBUG( G_DEBUG_FLAG, 'L_SAT_INTEREST_AMT:'||L_SAT_INTEREST_AMT);
    WRITE_DEBUG( G_DEBUG_FLAG, 'L_PREV_INT_AMT:'||L_PREV_INT_AMT);
  END LOOP; -- end of the loop for multiple refd heads added on 25-JUN-2018
  --Removed INPUT_ERROR_FLAG check on 23-Jan-2018

ELSE -- else of l_num_chk_cnt for Original processing
  WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'Inside Original check');
  dbms_output.put_line('Inside Original check');
  FOR J  IN
  (SELECT *
  FROM xx_REFD_LINES
  WHERE REFERENCE_ID=CUR_REFD_HEADERS_REC.REFERENCE_ID
  AND MINOR_HEAD    ='300'
  )
  LOOP
    L_REC_INTEREST_AMT :=0;
    BEGIN -- Added for HF#171927 on 6-Mar-2018 by Sudha -- starts
      SELECT COUNT(1)
      INTO V_count_orig
      FROM "process_store"."interest_on_refd"@psql_process_fas A
      WHERE "id_cd"             = cur_refd_headers_rec.id_number
      AND "assment_year"         = cur_refd_headers_rec.irt_ay
      AND "val_filing_status_cd" = 'O';
      IF v_count_orig          = 1 THEN
        SELECT "filing_dt"
        INTO V_FILING_DT
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id"     =cur_refd_headers_rec.IRT_ID;
      ELSIF v_count_orig > 1 THEN
        SELECT "filing_dt"
        INTO V_FILING_DT
        FROM "process_store"."interest_on_refd"@psql_process_fas
        WHERE "irt_id"=
          (SELECT MIN("irt_id")
          FROM "process_store"."interest_on_refd"@psql_process_fas
          WHERE "id_cd"             = cur_refd_headers_rec.id_number
          AND "assment_year"         = cur_refd_headers_rec.irt_ay
          AND "val_filing_status_cd" = 'O'
          );
      END IF;
    END; -- Added for HF#171927 on 6-Mar-2018 by Sudha -- ends
    IF V_FILING_DT  > J.RECEIPT_DATE THEN
      P_START_DATE :=V_FILING_DT;
    ELSE
      P_START_DATE :=J.RECEIPT_DATE;
    END IF;
    -- Added for UPC orders on 08-Feb-2018 for HF#171927 by sudha

    l_chr_exe_location := 'RIP_0027_300';
    l_stmt_processing  :='P_START_DATE FOR : ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || J.CASH_RECEIPT_ID ||'-'|| P_START_DATE);
    --        L_SAT_INT_MONTHS :=MONTHS_BETWEEN(TO_DATE (TO_CHAR (TRUNC(cur_refd_headers_rec.refd_identified_date ),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (P_START_DATE, 'MON-YYYY'), 'MON-YYYY'));
    L_SAT_INT_MONTHS :=TRUNC(MONTHS_BETWEEN( LAST_DAY(TO_DATE (TO_CHAR (CUR_REFD_HEADERS_REC.REFD_IDENTIFIED_DATE),'DD-MON-YYYY')), LAST_DAY(TO_DATE (TO_CHAR (P_START_DATE), 'DD-MON-YYYY'))))+1;
    write_debug( g_debug_flag, 'L_SAT_INT_MONTHS:'||L_SAT_INT_MONTHS);
    L_REC_INTEREST_AMT :=((J.EXCESS_RECEIPT_AMOUNT -MOD(J.EXCESS_RECEIPT_AMOUNT,100))*(L_SAT_INT_MONTHS-L_DEF_DELAY_MONTHS) *.5)/100;
    write_debug( g_debug_flag, 'L_REC_INTEREST_AMT:'||L_REC_INTEREST_AMT);
    L_SAT_INTEREST_AMT :=L_SAT_INTEREST_AMT +L_REC_INTEREST_AMT;
    L_SAT_ELIGIBLE_AMT :=L_SAT_ELIGIBLE_AMT +J.EXCESS_RECEIPT_AMOUNT;
    l_chr_exe_location := 'RIP_0027_300';
    l_stmt_processing  :='Refd Interest Amount For Receipt : ';
    WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING || J.CASH_RECEIPT_ID ||'-'|| 'Receipt Amount : '||J.EXCESS_RECEIPT_AMOUNT);
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || J.CASH_RECEIPT_ID ||'-'|| 'Interest Amount: '|| L_REC_INTEREST_AMT);
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| 'Eligible Receipt Amount: '|| L_SAT_ELIGIBLE_AMT);
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| 'Interest Amount: '|| L_SAT_INTEREST_AMT);
    UPDATE xx_REFD_LINES
    SET ATTRIBUTE4     =ROUND(L_REC_INTEREST_AMT,0),
		ATTRIBUTE12= L_SAT_INT_MONTHS,--Added for 244A requirement Anjali
      attribute13      = L_DEF_DELAY_MONTHS -- Added to store defective delay
    WHERE REFERENCE_ID =CUR_REFD_HEADERS_REC.REFERENCE_ID
    AND CASH_RECEIPT_ID=J.CASH_RECEIPT_ID;
  END LOOP;
  WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'Eligible Receipt Amount1: '|| L_SAT_ELIGIBLE_AMT);
  WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'Interest Amount1: '|| L_SAT_INTEREST_AMT);
END IF; -- l_num_chk_cnt
--Added by Sudha on 18-Jan-2018 for HF#171927 ends
BEGIN
  SELECT "x_source_name"
  INTO L_SOURCE
  FROM "process_store"."irt_process_control_mstr"@psql_process_fas
  WHERE "irt_id" =P_IN_IRT_ID;
EXCEPTION
WHEN OTHERS THEN
  WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'UNABLE TO FIND SOURCE_NAME');
END;
WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'L_SOURCE: '||L_SOURCE);

BEGIN
  SELECT "delayed_months"
  INTO L_DELAY_MONTH
  FROM "process_store"."interest_on_refd"@psql_process_fas
  WHERE "irt_id" IN
    (SELECT "orig_irt_id"
    FROM "process_store"."interest_on_refd"@psql_process_fas
    WHERE "irt_id"=P_IN_IRT_ID
    );	
EXCEPTION
WHEN NO_DATA_FOUND THEN
  NULL;
WHEN OTHERS THEN
  RAISE CUSTOM_EXCEPTION;
END;
WRITE_DEBUG( G_DEBUG_FLAG , 'SOMEHINGSKFMXDKLFNMSKFNKLFNZDKL44444444444444444444444');
l_num_irt := to_number(P_IN_IRT_ID);

-- Updateing the interest on refd commented out for ABC-2.0 testing Bhagya
/*UPDATE "process_store"."interest_on_refd"@psql_process_fas
SET "no_of_months"=L_SAT_INT_MONTHS
WHERE "irt_id"        =P_IN_IRT_ID;    
--AND "delayed_months" IS NULL;   --Commented the condition ABC-2.0 -Bhagya
*/
--    INTEREST CALCULATION ENDS FOR SAT PAYMENTS - Added on 11-Jun-2016
UPDATE xx_refd_headers
  --SET total_refd_amount = refd_identify_amount +
  -- refd_interest_amount, --Commented for Including SAT Payment
  -- Interests - 11-Jun-2016
SET TOTAL_REFD_AMOUNT    = ROUND(REFD_IDENTIFY_AMOUNT       + NVL( REFD_INTEREST_AMOUNT,0) +(L_SAT_INTEREST_AMT), 0), --Modified for SAT Payment Interests - 11-Jun-2016
  refd_interest_amount   = ROUND(NVL(refd_interest_amount,0)+ L_SAT_INTEREST_AMT,0),                                    --Added for SAT Interests - 11-Jun-2016
  ATTRIBUTE4               =ROUND(L_SAT_ELIGIBLE_AMT,0),                                                                    --Added for SAT Interests - 11-Jun-2016
  ATTRIBUTE5               =ROUND(L_SAT_INTEREST_AMT,0),                                                                    --Added for SAT Interests - 11- Jun-2016
  eligible_interest_amount = NVL(eligible_interest_amount,0) + NVL(l_eligible_amt_300,0)                                    --Added for HF#171927 (Jtrac#381) on 10-Dec-2018
WHERE REFERENCE_ID         = CUR_REFD_HEADERS_REC.REFERENCE_ID;
--END IF; --L_SOURCE IN ('IBA-P', 'IBA-E') -- Commented for CR - 690 - DDT-BBS ABC Changes
--Added for DDT/BBS 244A interest calculation for CR#690 on 07-May-2018 -- ends
--Added as a Part of Delay Attribute - Ends Here - 11-jun-2016
l_chr_exe_location := 'RIP_0029';
l_stmt_processing  := 'Getting refd_interest_amount from xx_refd_headers';
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
l_interest_amount := NULL;
SELECT NVL (refd_interest_amount, 0)
INTO l_interest_amount
FROM xx_refd_headers
WHERE reference_id  = cur_refd_headers_rec.reference_id;
l_chr_exe_location := 'RIP_0030-A';
l_stmt_processing  :=' Checking Interest Amt ';
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || l_interest_amount);
--refd interest creation -POST INTEREST CALC
IF l_interest_amount  > 0 THEN
  l_chr_exe_location := 'RIP_0030';
  l_stmt_processing  :='Calling interest_recpt_proc -POST INTEREST CALC';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || l_interest_amount);
  l_chr_errbuff := NULL;
  l_chr_retcode := NULL;
  interest_recpt_proc (p_out_chr_errbuff => l_chr_errbuff, p_out_chr_retcode => l_chr_retcode, in_num_reference_id => cur_refd_headers_rec.reference_id, in_num_receipt_amount => l_interest_amount, in_chr_flag => 'IRF', in_chr_irt_id => cur_refd_headers_rec.irt_id );
  IF l_chr_retcode    <> 0 THEN
    p_out_chr_errbuff := l_chr_errbuff;
    RAISE CUSTOM_EXCEPTION ;
  END IF;
END IF;   -- IF l_interest_amount > 0
END IF;   --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha
END LOOP; -- FOR cur_refd_headers_rec IN cur_refd_headers(p_in_irt_id)
l_chr_exe_location := 'RIP_0031';
l_stmt_processing  := 'Updating refd_status = PCM APPROVED in xx_refd_headers ';
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
-- updating refd_status
UPDATE xx_refd_headers
SET refd_status    = 'PCM APPROVED'
WHERE refd_status IN ('NEW', 'AWAITING APPROVAL')
AND irt_id           = p_in_irt_id;
-- INSERT INTO xx_rfnd_inst_temp SELECT * FROM xx_rfnd_inst_gtt;
write_debug( g_debug_flag , ' Apply refd interest calculation ends Program - ENDS ***');
-- Added for CR#729 - 241a - 22-Oct-2018 -- starts
l_chr_exe_location := 'RIP_0032';
l_stmt_processing  := 'Updating refd_status = TO PAY IDENTIFIED in xx_refd_headers for 241a cases..';
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
BEGIN
  SELECT NVL("x_flag_241a",'X')
  INTO l_241a_flag
  FROM "process_store"."irt_process_control_mstr"@psql_process_fas
  WHERE "irt_id"              =P_IN_IRT_ID
  AND NVL("x_source_name",'X') <> 'IBA-WS';
END;
IF l_241a_flag = 'Y' THEN
  BEGIN
    SELECT NVL(approval_flag,'X')
    INTO v_approval_flag
    FROM irt_stdcmp.IBA_refd_returns
    WHERE irt_id = P_IN_IRT_ID;
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    v_approval_flag := 'X';
    FND_FILE.PUT_LINE (FND_FILE.LOG, 'No approval_flag found for IRT_ID: '||P_IN_IRT_ID);
    dbms_output.put_line('No approval_flag found for IRT_ID: '||P_IN_IRT_ID);
  END;
  IF NVL(v_approval_flag,'X') = 'H' THEN
   dbms_output.put_line('Debug POST INTEREST CALC 18');
    UPDATE xx_refd_headers
    SET refd_status          = 'TO PAY IDENTIFIED',
      net_refd_amount        = NVL (total_refd_amount, 0) - NVL ( refd_adjustment_amount, 0),
      refd_adjustment_amount = NVL (refd_adjustment_amount, 0)
    WHERE refd_status        = 'PCM APPROVED'
    AND irt_id                 = p_in_irt_id;
  END IF; --NVL(v_approval_flag,'X') = 'H'
ELSE
  -- Added for CR#729 - 241a - 22-Oct-2018 -- ends
  -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018 -- starts
  l_chr_exe_location := 'RIP_0033';
  l_stmt_processing  := 'Updating refd_status = TO PAY IDENTIFIED in xx_refd_headers for IBA-P/IBA-E with Blocked refd..';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  BEGIN
    SELECT "x_source_name"
    INTO L_SOURCE
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id" =P_IN_IRT_ID;
  EXCEPTION
  WHEN OTHERS THEN
    WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'UNABLE TO FIND SOURCE_NAME');
  END;
  WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'L_SOURCE: '||L_SOURCE);
  IF L_SOURCE IN ('IBA-P', 'IBA-E') THEN
    BEGIN
      SELECT approval_flag
      INTO v_approval_flag
      FROM irt_stdcmp.IBA_refd_returns
      WHERE irt_id = P_IN_IRT_ID;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_approval_flag := 'X';
      FND_FILE.PUT_LINE (FND_FILE.LOG, 'No approval_flag found for the source_name: '||L_SOURCE);
      dbms_output.put_line('No approval_flag found for the source_name: '||L_SOURCE);
    END;
    IF NVL(v_approval_flag,'X') = 'B' THEN
      UPDATE xx_refd_headers
      SET refd_status          = 'TO PAY IDENTIFIED',
        net_refd_amount        = NVL (total_refd_amount, 0) - NVL ( refd_adjustment_amount, 0),
        refd_adjustment_amount = NVL (refd_adjustment_amount, 0)
      WHERE refd_status        = 'PCM APPROVED'
      AND irt_id                 = p_in_irt_id;
    END IF; --NVL(v_approval_flag,'X') = 'B'
  END IF;   --L_SOURCE IN ('IBA-P', 'IBA-E')
END IF;     --l_241a_flag = 'Y' -- Added for CR#729 - 241a - 22-Oct-2018
-- Added for CR#611 - Blocked refd from AO - 6-Jun-2018 -- ends
EXCEPTION
WHEN CUSTOM_EXCEPTION THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||p_out_chr_errbuff;
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff);
    END IF;
  END IF;
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff);
    END IF;
  END IF;
END REFD_INTEREST;
--+-******************************End of Procedure / Funcion ******************
-- **
PROCEDURE Create_interest_recpt(
    p_out_chr_errbuff OUT NOCOPY VARCHAR2,
    p_out_chr_retcode OUT NOCOPY VARCHAR2,
    p_in_num_reference_id   IN NUMBER,
    p_in_num_receipt_amount IN NUMBER,
    p_in_chr_flag           IN VARCHAR2,
    p_in_chr_irt_id         IN VARCHAR2 )
  /****************************************************************************
  **********
  * Type : PROCEDURE
  * Name : CREATE_INTEREST_RECPT
  * Input Parameters : in_num_reference_id
  * Output Parameters : out_chr_errbuff, out_chr_retcode
  * Purpose : Create_interest_recpt API would create receipt for the refd
  * interest and inserts a line on the refd lines table
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 03-Jan-2012
  * Last Reviewed By :
  * Last Reviewed Date : 03-Jan-2012
  *****************************************************************************
  ***********
  * Modified Date Modified By Version Modification Type Modification Details *
  * ------------- ------------ -------- - -----------------
  -------------------------- *
  * 03-Jan-2012 Infosys 1.0 Created
  *****************************************************************************
  **********/
AS
  -- Creating Local Variables
  l_customer_trx_id     NUMBER;
  l_num_customer_id     NUMBER;
  l_num_bank_acct_id    NUMBER;
  l_receipt_method_id   NUMBER;
  l_cash_receipt_id     NUMBER;
  l_msg_count           NUMBER;
  l_return_status       VARCHAR2 (1000);
  l_msg_data            VARCHAR2 (1000);
  l_msg_dummy           VARCHAR2 (2000);
  l_output              VARCHAR2 (2000);
  l_chr_major_head      VARCHAR2 (150);
  l_chr_assmt_year      VARCHAR2 (150);
  l_chr_customer_number VARCHAR2 (150);
  l_stmt_processing     VARCHAR2 (200);
  l_chr_proc_name       VARCHAR2(50) ;
  l_chr_exe_location    VARCHAR2(50) :='';
  l_chr_errbuff         VARCHAR2(5000);
  l_chr_retcode         VARCHAR2(10);
  l_approval_date       DATE;
  l_global_attributes ar_receipt_api_pub.global_attribute_rec_type;
  l_receipt_attributes ar_receipt_api_pub.attribute_rec_type;
  l_exc_exit_error_proc EXCEPTION;
BEGIN
  l_chr_proc_name    := 'Create_interest_recpt';
  l_chr_exe_location := 'CIR_001';
  l_stmt_processing  := ' Entering Create_interest_recpt Routine';
  write_debug( g_debug_flag , l_stmt_processing ||'-' ||l_chr_proc_name );
  p_out_chr_retcode := g_chr_success_code;
  p_out_chr_errbuff := '';
  l_stmt_processing := ' Fetching the Id, AY, Major Head for reference_id ';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  l_chr_exe_location := 'CIR_002';
  SELECT id_number ,
    irt_ay ,
    major_head ,
    customer_trx_id ,
    NVL (approval_date, SYSDATE)
  INTO l_chr_customer_number ,
    l_chr_assmt_year ,
    l_chr_major_head ,
    l_customer_trx_id ,
    l_approval_date
  FROM xx_refd_headers
  WHERE reference_id = p_in_num_reference_id
  AND irt_id         = p_in_chr_irt_id ;
  write_debug( g_debug_flag , l_stmt_processing || ' ID -'|| l_chr_customer_number || ' AY -' || l_chr_assmt_year || ' major_head -'|| l_chr_major_head );
  l_stmt_processing  := ' Getting Customer Id ';
  l_chr_exe_location := 'CIR_003';
  SELECT bill_to_customer_id
  INTO l_num_customer_id
  FROM ra_customer_trx_all
  WHERE customer_trx_id = l_customer_trx_id;
  write_debug( g_debug_flag , ' Bill to Customer id ' || l_num_customer_id);
  l_stmt_processing  := ' Getting Receipt Method based on Major head, Flag';
  l_chr_exe_location := 'CIR_004';
  SELECT receipt_method_id
  INTO l_receipt_method_id
  FROM ar_receipt_methods
  WHERE attribute1 = l_chr_major_head
  AND attribute2   = p_in_chr_flag;
  write_debug( g_debug_flag , ' Receipt Method id ' || l_receipt_method_id);
  l_stmt_processing  := ' Getting Bank Account Id ';
  l_chr_exe_location := 'CIR_005';
  SELECT remit_bank_acct_use_id
  INTO l_num_bank_acct_id
  FROM ar_receipt_method_accounts_all
  WHERE receipt_method_id = l_receipt_method_id;
  write_debug( g_debug_flag , ' remit_bank_acct_use_id ' || l_num_bank_acct_id );
  l_stmt_processing                := ' Setting Value requried for Receipt Creation ';
  l_chr_exe_location               := 'CIR_006';
  l_receipt_attributes.attribute1  := l_chr_major_head;
  l_receipt_attributes.attribute2  := p_in_chr_flag;
  l_receipt_attributes.attribute4  := l_chr_assmt_year;      -- assmt year
  l_receipt_attributes.attribute5  := l_chr_customer_number; -- Id
  l_receipt_attributes.attribute12 := p_in_chr_irt_id;
  l_receipt_attributes.attribute15 := 'REFD IN PROCESS';
  l_stmt_processing                := ' Calling Receipt API for Receipt Creation ';
  l_chr_exe_location               := 'CIR_007';
  --ar_receipt_api_pub.create_cash (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_currency_code => 'INR', p_amount => p_in_num_receipt_amount, p_receipt_number => p_in_chr_flag || '_' || l_chr_customer_number || '_' || l_chr_assmt_year || '_' || l_chr_major_head, p_receipt_date => TRUNC(l_approval_date), p_gl_date => TRUNC (SYSDATE), p_customer_id => l_num_customer_id, p_remittance_bank_account_id => l_num_bank_acct_id, p_receipt_method_id => l_receipt_method_id, p_attribute_rec => l_receipt_attributes, p_global_attribute_rec => l_global_attributes, p_org_id => g_num_org_id, p_cr_id => l_cash_receipt_id ) ;  --Commented for Hotfix_199485 on 13-MAR-2019
  ar_receipt_api_pub.create_cash (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_currency_code => 'INR', p_amount => p_in_num_receipt_amount, p_receipt_number => p_in_chr_flag || '_' || l_chr_customer_number || '_' || l_chr_assmt_year || '_' || l_chr_major_head, p_receipt_date => TRUNC(l_approval_date), p_gl_date => TRUNC(l_approval_date), p_customer_id => l_num_customer_id, p_remittance_bank_account_id => l_num_bank_acct_id, p_receipt_method_id => l_receipt_method_id, p_attribute_rec => l_receipt_attributes, p_global_attribute_rec => l_global_attributes, p_org_id => g_num_org_id, p_cr_id => l_cash_receipt_id ) ; --Added for Hotfix_199485 on 13-MAR-2019
  l_stmt_processing := ' Status of Receipt API is ' || l_return_status;
  write_debug( g_debug_flag , l_stmt_processing );
  IF l_return_status    = fnd_api.g_ret_sts_success THEN
    l_chr_exe_location := 'CIR_008';
    l_stmt_processing  := ' Creating refd Lines for receipt ';
    write_debug( g_debug_flag , l_stmt_processing );
    -- Insert a refd line for receipt line created
    INSERT
    INTO xx_refd_lines
      (
        reference_id ,
        cash_receipt_id ,
        receipt_ay ,
        minor_head ,
        excess_receipt_amount ,
        receipt_date ,
        last_updated_by ,
        last_update_date ,
        last_update_login ,
        created_by ,
        creation_date ,
        refd_roundoff_amount ,
        net_refd_amount ,
        refd_adjustment_amount ,
        refd_crossadjust_amount
      )
      VALUES
      (
        p_in_num_reference_id ,
        l_cash_receipt_id ,
        l_chr_assmt_year ,
        p_in_chr_flag ,
        p_in_num_receipt_amount ,
        l_approval_date ,
        g_num_user_id ,
        SYSDATE ,
        g_num_login_id ,
        g_num_user_id ,
        SYSDATE ,
        0 ,
        0 ,
        0 ,
        0
      );
  ELSE
    l_stmt_processing := ' Fetching Error Info for the API ';
    write_debug ( g_debug_flag , l_stmt_processing ) ;
    l_chr_exe_location := 'CIR_009';
    IF l_msg_count     >= 0 THEN
      FOR j IN 0 .. l_msg_count
      LOOP
        fnd_msg_pub.get
        (
          j,fnd_api.g_false,l_msg_data,l_msg_dummy
        )
        ;
        l_output          := ( TO_CHAR (j) || ': ' || l_msg_data ) ;
        p_out_chr_errbuff := p_out_chr_errbuff || SUBSTR ( l_output, 1, 255 ) ||'-';
      END LOOP; -- FOR j IN 0 .. l_msg_count
    END IF;     -- IF l_msg_count >= 0
    p_out_chr_retcode := g_chr_failure_code;
    write_msg ( g_write_logfile ,p_out_chr_errbuff ) ;
    p_out_chr_errbuff := l_chr_exe_location || '- Receipt API error while creating Interest Receipt Creation Failed ' || p_out_chr_errbuff ;
    write_debug ( g_debug_flag , p_out_chr_errbuff ) ;
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode , p_in_irt_id => p_in_chr_irt_id ) ;
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg ( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff ) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_chr_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id ) ;
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg ( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff ) ;
      END IF;
    END IF;
    RETURN;
  END IF; -- IF l_return_status = fnd_api.g_ret_sts_success
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'ERROR ' || l_chr_proc_name || '-' || l_chr_exe_location || '-' || l_stmt_processing || '-' || SUBSTR ( sqlerrm,1,255 ) ;
  write_msg ( g_write_logfile ,p_out_chr_errbuff ) ;
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode , p_in_irt_id => p_in_chr_irt_id ) ;
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg ( g_write_logfile ,' Error also while Backup of error data of Procedure - ' || l_chr_errbuff ) ;
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode , p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_chr_irt_id , p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL ,p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id ) ;
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg ( g_write_logfile ,' Error also while writing error data of Procedure - ' || l_chr_errbuff ) ;
    END IF;
  END IF;
END Create_interest_recpt;
PROCEDURE crosssched_adjust
  (
    p_out_chr_errbuff OUT NOCOPY VARCHAR2,
    p_out_chr_retcode OUT NOCOPY VARCHAR2,
    p_in_id_num IN VARCHAR2,
    p_in_irt_id  IN VARCHAR2
  )
AS
  /****************************************************************************
  ********************
  * Type : Procedure
  * Name : CROSSSCHED_ADJUST
  * Input Parameters : p_in_id_num, _in_irt_id
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : Procedure to apply invoice to receipts by relaxing CROSS SCHEDULE
  TYPE
  *
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 3-Jan-2012
  * Last Reviewed By :
  * Last Reviewed Date :
  *****************************************************************************
  **********
  * Modified Date Modified By Version Modification Type Modification Details *
  * ------------- ------------ -------- -----------------
  -------------------------- *
  * 31-Mar-2009 Infosys 1.0 O Baseline.
  *****************************************************************************
  ********************/
  --
  -- User defined exception for Commit with Warning
  --
  l_inv_amount      NUMBER;
  l_msg_count       NUMBER;
  l_status          NUMBER;
  l_refd_amount   NUMBER;
  l_apply_amount    NUMBER;
  l_roundoff_amount NUMBER;
  l_writeoff_amount NUMBER;
  --Added as part of DDT/BBS CR#690 on 07-May-18 --start-- , add declaration for CR - 661 on 18-FEB-2019
  /*l_ddt_refd_seq_num NUMBER;
  l_bbs_refd_seq_num NUMBER;
  L_SOURCE IRT_PROCESS_CONTROL_MSTR.SOURCE_NAME%type;*/
  -- Commented for CR - 690 - DDT-BBS ABC Changes
  --Added as part of DDT/BBS CR#690 on 07-May-18 --end--
  l_msg_data         VARCHAR2 ( 5000 ) ;
  l_return_status    VARCHAR2 ( 200 ) ;
  l_chr_errbuff      VARCHAR2 ( 5000 ) ;
  l_chr_retcode      VARCHAR2 ( 10 ) ;
  l_stmt_processing  VARCHAR2 ( 100 ) ;
  l_chr_proc_name    VARCHAR2 ( 50 ) :='crosssched_adjust';
  l_chr_exe_location VARCHAR2 ( 50 ) :='';
  l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
  custom_exception EXCEPTION;
  --l_exc_exit_warn_proc EXCEPTION;
  -- Added on 08-JUN-2018 as part of CR-690 --DDT-BBS ABC changes - starts , add declaration for CR - 661 on 18-FEB-2019
  l_return_status2 VARCHAR2 ( 200 ) ;
  l_application_ref_type ar_receivable_applications.application_ref_type%TYPE;
  l_application_ref_id ar_receivable_applications.application_ref_id%TYPE;
  L_APPLICATION_REF_NUM AR_RECEIVABLE_APPLICATIONS.APPLICATION_REF_NUM%TYPE;
  L_SECONDARY_APPLICATION_REF_ID AR_RECEIVABLE_APPLICATIONS.SECONDARY_APPLICATION_REF_ID%TYPE;
  L_RECEIVABLE_APPLICATION_ID AR_RECEIVABLE_APPLICATIONS.RECEIVABLE_APPLICATION_ID%TYPE;
  L_REFERENCE_ID xx_REFD_HEADERS.REFERENCE_ID%TYPE;
  L_REFD_CROSSADJUST_AMOUNT NUMBER := 0;
  v_attribute1 AR_RECEIVABLE_APPLICATIONS.attribute1%type;
  V_ATTRIBUTE2 AR_RECEIVABLE_APPLICATIONS.ATTRIBUTE2%TYPE;
  V_ATTRIBUTE3 AR_RECEIVABLE_APPLICATIONS.ATTRIBUTE3%TYPE;
  V_ATTRIBUTE4 AR_RECEIVABLE_APPLICATIONS.ATTRIBUTE4%TYPE;
  V_ATTRIBUTE5 AR_RECEIVABLE_APPLICATIONS.ATTRIBUTE5%TYPE;
  V_APPLIED_PAYMENT_SCHEDULE_ID AR_RECEIVABLE_APPLICATIONS_ALL.APPLIED_PAYMENT_SCHEDULE_ID%TYPE;
  V_STATUS AR_RECEIVABLE_APPLICATIONS_ALL.STATUS%TYPE;
  L_CROSS_REFD_SEQ_NUM NUMBER;
  -- Added on 08-JUN-18 as part of CR-690 --DDT-BBS ABC changes - ends
  --Cursor Declaration
  CURSOR cur_cmajor_inv ( p_id_num VARCHAR2 )
  IS
    SELECT customer_number,
      assmt_year
    FROM
      ( SELECT DISTINCT rat.attribute5 customer_number,
        rat.attribute4 assmt_year,
        rat.attribute1 major_head
      FROM ra_customer_trx_all rat
      WHERE rat.attribute9            = 'DMD'
      AND rat.attribute10            IS NULL
      AND TO_NUMBER (rat.attribute12) > 0
      AND rat.customer_trx_id        IN
        (SELECT rat1.customer_trx_id
        FROM xx_refd_headers head,
          ra_customer_trx_all rat1
        WHERE rat1.attribute9  = 'DMD'
        AND head.refd_status = 'PCM APPROVED'
        AND head.id_number    = rat1.attribute5
        AND head.irt_ay        = rat1.attribute4
        AND head.id_number    = p_id_num -- added restructuring
        )
    ORDER BY TO_NUMBER (rat.attribute4),
      TO_NUMBER (rat.attribute1) ASC
      );
    CURSOR cur_crossmajor_inv ( in_num_customer VARCHAR2, in_num_assmt_year VARCHAR2 )
    IS
      SELECT rat.customer_trx_id,
        rat.trx_number,
        rat.bill_to_customer_id,
        rat.attribute4 assmt_year,
        rat.attribute5 customer_number,
        rat.attribute2 bank_account,
        rat.attribute3 irt_approval_date,
        TO_NUMBER (rat.attribute12) amount_due_remaining,
        rat.attribute1 major_head,
        rat.attribute9 status,
        rat.attribute7 schedule_type,
        rat.attribute10 dmd_serv_date
      FROM ra_customer_trx_all rat
      WHERE rat.attribute9            = 'DMD'
      AND rat.attribute5              = in_num_customer
      AND rat.attribute4              = in_num_assmt_year
      AND rat.attribute10            IS NULL
      AND TO_NUMBER (rat.attribute12) > 0
      ORDER BY TO_NUMBER (RAT.ATTRIBUTE4),
        TO_NUMBER (rat.attribute1) ASC,
        rat.attribute7 DESC; --Added as part of CR - 690 --DDT-BBS ABC changes --added for CR_661 on 31-Jan-2019
    CURSOR cur_crossmajor_recpt ( in_num_customer VARCHAR2, in_num_assmt_year VARCHAR2 )
    IS
      SELECT line.cash_receipt_id,
        ( line.excess_receipt_amount + NVL (line.refd_roundoff_amount, 0) - NVL (line.refd_crossadjust_amount, 0) ) amount,
        head.id_number,
        line.receipt_date,
        head.approval_date, -- Added as part of CR - 690 on 08-JUN-2018 -- DDT-BBS ABC changes
        --line.minor_head,--added as part of DDT/BBS for CR#690 07-May-2018 --DDT-BBS ABC changes
        line.receipt_ay assmt_year,
        ( line.excess_receipt_amount + NVL (line.refd_roundoff_amount, 0) - NVL (line.refd_crossadjust_amount, 0) ) claim_amount,
        IRT_SCHEDULE_TYPE --added for CR_661 on 31-Jan-2019
      FROM xx_refd_headers head,
        xx_refd_lines line
      WHERE head.refd_status                                                                                            = 'PCM APPROVED'
      AND head.id_number                                                                                                 = in_num_customer
      AND head.irt_ay                                                                                                     = in_num_assmt_year
      AND line.reference_id                                                                                               = head.reference_id
      AND ( line.excess_receipt_amount + NVL (line.refd_roundoff_amount, 0) - NVL (line.refd_crossadjust_amount, 0) ) > 0
      ORDER BY line.reference_id,
        line.receipt_date,
        line.cash_receipt_id ASC;
    --head.IRT_SCHEDULE_TYPE ASC; --Added as part of CR#690 -- Commented for CR - 690 - DDT-BBS ABC Changes
    CURSOR cur_appr_refd_headers( p_id_num VARCHAR2)
    IS
      SELECT reference_id,
        irt_ay assmt_year,
        major_head,
        irt_id,
        NVL (total_refd_amount, 0) total_refd_amount,
        NVL (refd_interest_amount, 0),
        approval_date --Added in Ver 1.2
      FROM xx_refd_headers head
      WHERE refd_status = 'PCM APPROVED'
      AND head.id_number = p_id_num -- added restructuring
      ORDER BY reference_id;
  BEGIN -- main program
    l_chr_proc_name    := 'crosssched_adjust';
    l_chr_exe_location :='CSA001';
    l_stmt_processing  := ' Entering Routine crosssched_adjust';
	dbms_output.put_line(' Entering Routine crosssched_adjust');
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    p_out_chr_errbuff := ' ';
    p_out_chr_retcode := g_chr_success_code;
    write_debug( g_debug_flag , '---------------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Apply Refd Adjustment with Cross Schedule Type Program - STARTS ***' );
    write_debug( g_debug_flag , '---------------------------------------------------------------------');
    l_stmt_processing := ' Call the Main Cursor with Parameter ID ' || p_in_id_num ;
    write_debug( g_debug_flag , l_stmt_processing ||'-' ||l_chr_proc_name);
    -- Added for DDT/BBS 244A interest calculation for CR#690 on 07-May-2018 -- starts--

    -- Added for DDT/BBS 244A interest calculation for CR#690 on 07-May-2018 -- End--
    FOR cur_cmajor_inv_rec IN cur_cmajor_inv(p_In_id_num)
    LOOP
      l_stmt_processing  := ' Calling the Inv Cursor with ID and Assmt year Param ' ;
      l_chr_exe_location :='CSA002';
      write_debug( g_debug_flag , l_stmt_processing ||'-' || cur_cmajor_inv_rec.customer_number ||'-' ||cur_cmajor_inv_rec.assmt_year) ;
      FOR cur_crossmajor_inv_rec IN cur_crossmajor_inv ( cur_cmajor_inv_rec.customer_number, cur_cmajor_inv_rec.assmt_year )
      LOOP
        l_stmt_processing  := ' One / More Invoice Adjustment Rec identified ' ;
		dbms_output.put_line (' One / More Invoice Adjustment Rec identified ' );
        l_chr_exe_location :='CSA003';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_inv_amount := NULL;
        l_inv_amount := cur_crossmajor_inv_rec.amount_due_remaining;
        write_debug( g_debug_flag , '************');
        write_debug( g_debug_flag ,'Invoice number :'|| cur_crossmajor_inv_rec.trx_number);
        write_debug( g_debug_flag ,'Invoice Amount :' || cur_crossmajor_inv_rec.amount_due_remaining);
        write_debug( g_debug_flag ,'Id Number :' || cur_crossmajor_inv_rec.customer_number);
        write_debug( g_debug_flag ,'Assessment Year:'|| cur_crossmajor_inv_rec.assmt_year);
        write_debug( g_debug_flag ,'Major Head :'|| cur_crossmajor_inv_rec.major_head);
        write_debug( g_debug_flag ,'Schedule type :'|| cur_crossmajor_inv_rec.schedule_type);
        --
        -- Apply Invoice to receipt for current Assesment year
        --
        FOR cur_crossmajor_recpt_rec IN cur_crossmajor_recpt ( cur_crossmajor_inv_rec.customer_number, cur_crossmajor_inv_rec.assmt_year )
        LOOP
          l_stmt_processing  := ' One / More Receipt to be Adjusted found ';
          l_chr_exe_location :='CSA004';
          write_debug( g_debug_flag , l_stmt_processing );
          l_msg_count      := NULL;
          l_msg_data       := NULL;
          l_return_status  := NULL;
          l_apply_amount   := NULL;
          l_return_status2 := NULL; -- Added as part of CR - 690 - 08-JUN-2018 -- DDT-BBS ABC changes, add for CR - 661 on 18-FEB-2019
          IF l_inv_amount  <= cur_crossmajor_recpt_rec.claim_amount THEN
            l_apply_amount := l_inv_amount;
          ELSE -- IF l_inv_amount <= cur_crossmajor_recpt_rec.claim_amount
            l_apply_amount := cur_crossmajor_recpt_rec.claim_amount;
          END IF; -- IF l_inv_amount <= cur_crossmajor_recpt_rec.claim_amount
          IF l_inv_amount              <> 0 THEN
            l_stmt_processing          := ' Calling Receipt Application API';
            l_chr_exe_location         :='CSA005';
            l_attribute_rec.attribute4 := 'CROSS HEAD ADJUSTED';

            --End --Added as part of CR#690 on 07-May-2018--
            IF cur_crossmajor_inv_rec.SCHEDULE_TYPE IN ('DDT', 'BBS') THEN -- start of 690
              SELECT NUM_REFD_SEQ.NEXTVAL INTO l_CROSS_refd_seq_num FROM DUAL;
              L_ATTRIBUTE_REC.ATTRIBUTE5 := L_CROSS_REFD_SEQ_NUM;
              WRITE_DEBUG( G_DEBUG_FLAG , ' l_CROSS_refd_seq_num: '||L_CROSS_REFD_SEQ_NUM);
              write_debug( g_debug_flag , ' About to Apply receipt ' || cur_crossmajor_recpt_rec.cash_receipt_id || ' to Inv - ' ||cur_crossmajor_inv_rec.customer_trx_id || ' Cross Head Adjustment ' );
              write_debug( g_debug_flag , ' customer_trx_id: '||cur_crossmajor_inv_rec.customer_trx_id);
              write_debug( g_debug_flag , ' cash_receipt_id: '||cur_crossmajor_recpt_rec.cash_receipt_id);
              write_debug( g_debug_flag , ' l_apply_amount: '||l_apply_amount);
              l_attribute_rec.attribute1 := cur_crossmajor_inv_rec.major_head;
              l_attribute_rec.attribute2 := cur_crossmajor_inv_rec.customer_trx_id;
              L_ATTRIBUTE_REC.ATTRIBUTE3 := CUR_CROSSMAJOR_INV_REC.ASSMT_YEAR;
              write_debug( g_debug_flag ,'g_payment_schedule_id: '||g_payment_schedule_id);
              --ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => cur_crossmajor_recpt_rec.approval_date, p_apply_gl_date => g_dte_sys_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id );  --Commented for Hotfix_199485 on 13-MAR-2019
              ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => cur_crossmajor_recpt_rec.approval_date, p_apply_gl_date => cur_crossmajor_recpt_rec.approval_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Added for Hotfix_199485 on 13-MAR-2019
              l_stmt_processing := ' Receipt Application API Completed with - '|| l_return_status2;
              WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
              SELECT ATTRIBUTE1,
                ATTRIBUTE2,
                ATTRIBUTE3,
                ATTRIBUTE4,
                ATTRIBUTE5,
                STATUS,
                APPLIED_PAYMENT_SCHEDULE_ID
              INTO v_attribute1,
                v_attribute2,
                v_attribute3,
                v_attribute4,
                V_ATTRIBUTE5,
                V_STATUS,
                v_applied_payment_schedule_id
              FROM AR_RECEIVABLE_APPLICATIONS_ALL
              WHERE RECEIVABLE_APPLICATION_ID = L_RECEIVABLE_APPLICATION_ID;
              WRITE_DEBUG( G_DEBUG_FLAG , 'L_RECEIVABLE_APPLICATION_ID: '||L_RECEIVABLE_APPLICATION_ID);
              WRITE_DEBUG( G_DEBUG_FLAG , 'V_STATUS: '||V_STATUS);
              WRITE_DEBUG( G_DEBUG_FLAG , 'v_applied_payment_schedule_id: '||v_applied_payment_schedule_id);
              write_debug( g_debug_flag , 'ATTRIBUTE1 '|| v_ATTRIBUTE1|| ' ATTRIBUTE2 '|| v_ATTRIBUTE2||'ATTRIBUTE3 '||v_ATTRIBUTE3||' ATTRIBUTE4 '||v_ATTRIBUTE4||' ATTRIBUTE5 '||v_ATTRIBUTE5);
              IF l_return_status2   = 'S' THEN
                L_CHR_EXE_LOCATION :='CSA006';
                write_debug( g_debug_flag , 'Apply receipt writeoff for receipt ID '|| cur_crossmajor_recpt_rec.cash_receipt_id || ' for refd adjustment amount '|| l_writeoff_amount|| ' - ' || l_return_status2);
                -- TO update the receipt claim amount
                l_stmt_processing  := ' Updating the adjsuted amt to Refd lines';
                l_chr_exe_location :='CSA006.1';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
                UPDATE xx_refd_lines
                SET refd_crossadjust_amount = NVL (refd_crossadjust_amount, 0) + l_apply_amount
                WHERE cash_receipt_id         = cur_crossmajor_recpt_rec.cash_receipt_id;
                l_inv_amount                 := l_inv_amount - l_apply_amount;
                EXIT
              WHEN l_inv_amount = 0;
              ELSE -- IF l_return_status2 = 'S'
                l_stmt_processing  := ' Receipt Application Failed (Else part)';
                l_chr_exe_location :='CSA006.2';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
                write_debug( g_debug_flag , 'Status for apply invoice number ' || cur_crossmajor_inv_rec.trx_number || ' for amount Rs '|| l_apply_amount || ' to Receipt Number : '|| cur_crossmajor_recpt_rec.cash_receipt_id || ' is '|| l_return_status);
                IF l_msg_count >= 1 THEN
                  FOR i IN 1 .. l_msg_count
                  LOOP
                    p_out_chr_errbuff := p_out_chr_errbuff || i|| '. ' || SUBSTR(fnd_msg_pub.get(p_encoded => fnd_api.g_false), 1,355);
                  END LOOP; -- FOR i IN 1 .. l_msg_count
                  write_msg( g_write_logfile,p_out_chr_errbuff );
                END IF; --IF l_msg_count >= 1
                l_stmt_processing  := ' Printed the Error details above of Receipt APi and returning back parent call';
                l_chr_exe_location :='CSA010';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
                p_out_chr_retcode := g_chr_failure_code;
                RAISE custom_exception;
                RETURN;
              END IF; -- IF l_return_status2 = 'S'
              --added for CR_661 on 31-Jan-2019--start--
            ELSIF cur_crossmajor_inv_rec.SCHEDULE_TYPE IN ('115TD') THEN
              l_attribute_rec.attribute4 := '115TD CROSSHEAD ADJUSTED';
              SELECT NUM_REFD_SEQ.NEXTVAL INTO l_CROSS_refd_seq_num FROM DUAL;
              L_ATTRIBUTE_REC.ATTRIBUTE5 := L_CROSS_REFD_SEQ_NUM;
              WRITE_DEBUG( G_DEBUG_FLAG , ' l_CROSS_refd_seq_num: '||L_CROSS_REFD_SEQ_NUM);
              write_debug( g_debug_flag , ' About to Apply receipt ' || cur_crossmajor_recpt_rec.cash_receipt_id || ' to Inv - ' ||cur_crossmajor_inv_rec.customer_trx_id || ' Cross Head Adjustment ' );
              write_debug( g_debug_flag , ' customer_trx_id: '||cur_crossmajor_inv_rec.customer_trx_id);
              write_debug( g_debug_flag , ' cash_receipt_id: '||cur_crossmajor_recpt_rec.cash_receipt_id);
              write_debug( g_debug_flag , ' l_apply_amount: '||l_apply_amount);
              l_attribute_rec.attribute1 := cur_crossmajor_inv_rec.major_head;
              l_attribute_rec.attribute2 := cur_crossmajor_inv_rec.customer_trx_id;
              L_ATTRIBUTE_REC.ATTRIBUTE3 := CUR_CROSSMAJOR_INV_REC.ASSMT_YEAR;
              write_debug( g_debug_flag ,'g_payment_schedule_id: '||g_payment_schedule_id);
              --ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => cur_crossmajor_recpt_rec.approval_date, p_apply_gl_date => g_dte_sys_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id );  --Commented for Hotfix_199485 on 13-MAR-2019
              ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_apply_date => cur_crossmajor_recpt_rec.approval_date, p_apply_gl_date => cur_crossmajor_recpt_rec.approval_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Added for Hotfix_199485 on 13-MAR-2019
              l_stmt_processing := ' Receipt Application API Completed with - '|| l_return_status2;
              WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
              SELECT ATTRIBUTE1,
                ATTRIBUTE2,
                ATTRIBUTE3,
                ATTRIBUTE4,
                ATTRIBUTE5,
                STATUS,
                APPLIED_PAYMENT_SCHEDULE_ID
              INTO v_attribute1,
                v_attribute2,
                v_attribute3,
                v_attribute4,
                V_ATTRIBUTE5,
                V_STATUS,
                v_applied_payment_schedule_id
              FROM AR_RECEIVABLE_APPLICATIONS_ALL
              WHERE RECEIVABLE_APPLICATION_ID = L_RECEIVABLE_APPLICATION_ID;
              WRITE_DEBUG( G_DEBUG_FLAG , 'L_RECEIVABLE_APPLICATION_ID: '||L_RECEIVABLE_APPLICATION_ID);
              WRITE_DEBUG( G_DEBUG_FLAG , 'V_STATUS: '||V_STATUS);
              WRITE_DEBUG( G_DEBUG_FLAG , 'v_applied_payment_schedule_id: '||v_applied_payment_schedule_id);
              write_debug( g_debug_flag , 'ATTRIBUTE1 '|| v_ATTRIBUTE1|| ' ATTRIBUTE2 '|| v_ATTRIBUTE2||'ATTRIBUTE3 '||v_ATTRIBUTE3||' ATTRIBUTE4 '||v_ATTRIBUTE4||' ATTRIBUTE5 '||v_ATTRIBUTE5);
              IF l_return_status2   = 'S' THEN
                L_CHR_EXE_LOCATION :='CSA006';
                write_debug( g_debug_flag , 'Apply receipt writeoff for receipt ID '|| cur_crossmajor_recpt_rec.cash_receipt_id || ' for refd adjustment amount '|| l_writeoff_amount|| ' - ' || l_return_status2);
                -- TO update the receipt claim amount
                l_stmt_processing  := ' Updating the adjsuted amt to Refd lines';
                l_chr_exe_location :='CSA006.1';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
                UPDATE xx_refd_lines
                SET refd_crossadjust_amount = NVL (refd_crossadjust_amount, 0) + l_apply_amount
                WHERE cash_receipt_id         = cur_crossmajor_recpt_rec.cash_receipt_id;
                l_inv_amount                 := l_inv_amount - l_apply_amount;
                EXIT
              WHEN l_inv_amount = 0;
              ELSE -- IF l_return_status2 = 'S'
                l_stmt_processing  := ' Receipt Application Failed (Else part)';
                l_chr_exe_location :='CSA006.2';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
                write_debug( g_debug_flag , 'Status for apply invoice number ' || cur_crossmajor_inv_rec.trx_number || ' for amount Rs '|| l_apply_amount || ' to Receipt Number : '|| cur_crossmajor_recpt_rec.cash_receipt_id || ' is '|| l_return_status);
                IF l_msg_count >= 1 THEN
                  FOR i IN 1 .. l_msg_count
                  LOOP
                    p_out_chr_errbuff := p_out_chr_errbuff || i|| '. ' || SUBSTR(fnd_msg_pub.get(p_encoded => fnd_api.g_false), 1,355);
                  END LOOP; -- FOR i IN 1 .. l_msg_count
                  write_msg( g_write_logfile,p_out_chr_errbuff );
                END IF; --IF l_msg_count >= 1
                l_stmt_processing  := ' Printed the Error details above of Receipt APi and returning back parent call';
                l_chr_exe_location :='CSA010';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
                p_out_chr_retcode := g_chr_failure_code;
                RAISE custom_exception;
                RETURN;
              END IF; -- IF l_return_status2 = 'S'
              --added for CR_661 on 31-Jan-2019--end--
            ELSE -- end of 690 changes --other than DDT, BBS , 115TD add else for CR - 661 on 15-FEB-2019
              write_debug( g_debug_flag , ' About to Apply receipt ' || cur_crossmajor_recpt_rec.cash_receipt_id || ' to Inv - ' || cur_crossmajor_inv_rec.customer_trx_id || ' Cross Head Adjustment ' );
			  dbms_output.put_line(' About to Apply receipt ' || cur_crossmajor_recpt_rec.cash_receipt_id || ' to Inv - ' || cur_crossmajor_inv_rec.customer_trx_id || ' Cross Head Adjustment ' );
              --ar_receipt_api_pub.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_crossmajor_inv_rec.customer_trx_id, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_attribute_rec => l_attribute_rec, p_apply_date => TO_DATE (cur_crossmajor_inv_rec.irt_approval_date,'DD-MON-RRRR'), p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data ); --Commented for Hotfix_199485 on 13-MAR-2019
              ar_receipt_api_pub.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_crossmajor_inv_rec.customer_trx_id, p_cash_receipt_id => cur_crossmajor_recpt_rec.cash_receipt_id, p_amount_applied => l_apply_amount, p_attribute_rec => l_attribute_rec, p_apply_date => TO_DATE (cur_crossmajor_inv_rec.irt_approval_date,'DD-MON-RRRR'), p_apply_gl_date => TO_DATE (cur_crossmajor_inv_rec.irt_approval_date,'DD-MON-RRRR'), x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data ); --Added for Hotfix_199485 on 13-MAR-2019
              l_stmt_processing := ' Receipt Application API Completed with - '|| l_return_status;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              IF l_return_status    = 'S' THEN
                l_chr_exe_location :='CSA006';
                write_debug( g_debug_flag ,'Applied Receipt ID : '|| cur_crossmajor_recpt_rec.cash_receipt_id || ' - Assmt Year :'|| cur_crossmajor_recpt_rec.assmt_year || ' - Receipt Date : '|| cur_crossmajor_recpt_rec.receipt_date);
                write_debug( g_debug_flag ,' Status for apply invoice amount '|| l_apply_amount || ' to Receipt Number : '|| cur_crossmajor_recpt_rec.cash_receipt_id || ' - '|| l_return_status);
                --
                -- TO update the receipt claim amount
                --
                l_stmt_processing  := ' Updating the adjsuted amt to Refd lines' ;
				dbms_output.put_line(' Updating the adjsuted amt to Refd lines') ;
                l_chr_exe_location :='CSA007';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                UPDATE xx_refd_lines
                SET refd_crossadjust_amount = NVL (refd_crossadjust_amount, 0) + l_apply_amount
                WHERE cash_receipt_id         = cur_crossmajor_recpt_rec.cash_receipt_id;
                l_inv_amount                 := l_inv_amount - l_apply_amount;
                IF l_inv_amount               = 0 THEN
                  l_stmt_processing          := ' Updating the Invoice to PCM CLOSED';
                  l_chr_exe_location         :='CSA008';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  --
                  -- To Update the Status = 'CLOSED' once the invoice amount = 0
                  --
                  UPDATE ra_customer_trx_all rat
                  SET rat.attribute9        = 'PCM CLOSED'
                  WHERE rat.customer_trx_id = cur_crossmajor_inv_rec.customer_trx_id;
                END IF; -- IF l_inv_amount = 0
                EXIT
              WHEN l_inv_amount = 0;
              ELSE -- IF l_return_status = 'S'
                l_stmt_processing  := ' Receipt Application Failed (Else part)';
				dbms_output.put_line(' Receipt Application Failed (Else part)');
                l_chr_exe_location :='CSA009';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                --
                write_debug( g_debug_flag , 'Status for apply invoice number ' || cur_crossmajor_inv_rec.trx_number || ' for amount Rs '|| l_apply_amount || ' to Receipt Number : '|| cur_crossmajor_recpt_rec.cash_receipt_id || ' is '|| l_return_status);
                IF l_msg_count >= 1 THEN
                  FOR i IN 1 .. l_msg_count
                  LOOP
                    p_out_chr_errbuff := p_out_chr_errbuff || i|| '. ' || SUBSTR( fnd_msg_pub.get(p_encoded => fnd_api.g_false), 1,355);
                  END LOOP; -- FOR i IN 1 .. l_msg_count
                  write_msg( g_write_logfile,p_out_chr_errbuff );
                END IF; --IF l_msg_count >= 1
                l_stmt_processing  := ' Printed the Error details above of Receipt APi and returning back parent call' ;
                l_chr_exe_location :='CSA010';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                p_out_chr_retcode := g_chr_failure_code;
                RAISE custom_exception;
                RETURN;
              END IF; -- -- IF l_return_status = 'S'
            END IF;   -- CRoss major head check - 690 -- 08-JUN-2018
          END IF;     -- IF l_inv_amount <> 0
          l_stmt_processing  := ' Moving to next receipt for Invoice ';
          l_chr_exe_location :='CSA011';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
        END LOOP; -- FOR cur_crossmajor_recpt_rec IN
        l_stmt_processing  := ' Moving to next Invoice for Id, Assmt Year Combination';
        l_chr_exe_location :='CSA012';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      END LOOP; -- FOR cur_crossmajor_inv_rec IN
      l_stmt_processing  := ' Moving to next Assmt Year for the ID ';
      l_chr_exe_location :='CSA013';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    END LOOP; -- FOR cur_cmajor_inv_rec IN cur_cmajor_inv(p_id_num)
    l_stmt_processing  :='Refd cross head adjustment Amount update for ID';
    l_chr_exe_location :='CSA014';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_refd_headers head
    SET head.refd_crossadjust_amount =
      (SELECT NVL (SUM (refd_crossadjust_amount), 0)
      FROM xx_refd_lines
      WHERE reference_id = head.reference_id
      )
    WHERE head.refd_status = 'PCM APPROVED'
    AND head.id_number      = p_in_id_num;
    l_stmt_processing       :='Total refd amount update for ID';
    l_chr_exe_location      :='CSA015';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_refd_headers head
    SET head.total_refd_amount = head.total_refd_amount - head.refd_crossadjust_amount
    WHERE head.refd_status     = 'PCM APPROVED'
    AND head.id_number          = p_in_id_num;
    l_stmt_processing           :='update from PCM Approved to APPROVED for ID';
    l_chr_exe_location          :='CSA016';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_refd_headers head
    SET head.refd_status             = 'APPROVED'
    WHERE head.refd_status           = 'PCM APPROVED'
    AND head.total_refd_amount       = 0
    AND HEAD.REFD_CROSSADJUST_AMOUNT = 0 -- Added for CR - 690 on 08-JUN-2018, add for 115TD changes CR - 661 on 18-FEB-2019
    AND head.id_number                = p_in_id_num;
    l_stmt_processing                 := 'Recompute the Total amount and round of amout for PCM Approved records for ID, if any' ;
    l_chr_exe_location                :='CSA017';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    FOR cur_appr_refd_headers_rec IN cur_appr_refd_headers(p_in_id_num )
    LOOP
      write_debug( g_debug_flag ,'Reference Id : '|| cur_appr_refd_headers_rec.reference_id);
      l_refd_amount    := NULL;
      l_roundoff_amount  := NULL;
      l_status           := NULL;
      l_stmt_processing  :='Calling Round off Calc API for reference Id';
      l_chr_exe_location :='CSA018';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      l_status := roundoff_calc(cur_appr_refd_headers_rec.total_refd_amount , l_refd_amount, l_roundoff_amount );
      write_debug( g_debug_flag ,'Refd Amount:' || l_refd_amount);
      write_debug( g_debug_flag ,'Roundoff Amount : ' || l_roundoff_amount);
      write_debug( g_debug_flag ,'status : ' || l_status);
	  dbms_output.put_line('Refd Amount:' || l_refd_amount);
      dbms_output.put_line('Roundoff Amount : ' || l_roundoff_amount);
      dbms_output.put_line('status : ' || l_status);
      IF l_status           = 0 THEN
        l_stmt_processing  := ' About to Call the Write off API for the Reference id';
        l_chr_exe_location :='CSA019';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_writeoff_amount    := NULL;
        l_apply_amount       := NULL;
        IF l_roundoff_amount  < 0 THEN
          l_writeoff_amount  := -l_roundoff_amount;
          l_stmt_processing  :=' Round off Amt < 0 for the Reference id';
          l_chr_exe_location :='CSA020';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          FOR k IN
          (SELECT cash_receipt_id,
            ( excess_receipt_amount - refd_crossadjust_amount - refd_roundoff_amount ) amount
          FROM xx_refd_lines
          WHERE reference_id = cur_appr_refd_headers_rec.reference_id
          ORDER BY ( excess_receipt_amount - refd_crossadjust_amount - refd_roundoff_amount ) DESC
          )
          LOOP
            l_stmt_processing  :=' Identified receipt which needs ';
            l_chr_exe_location :='CSA021';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            IF l_writeoff_amount <= k.amount THEN
              l_apply_amount     := l_writeoff_amount;
            ELSE -- IF l_writeoff_amount <= k.amount
              l_apply_amount := k.amount;
            END IF; -- IF l_writeoff_amount <= k.amount
            IF l_writeoff_amount <> 0 THEN
              l_stmt_processing  := ' Calling the Write off procedure for the Reference id';
			  dbms_output.put_line(' Calling the Write off procedure for the Reference id');
              l_chr_exe_location :='CSA022';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              writeoff_proc(p_out_chr_errbuff => l_chr_errbuff, p_out_chr_retcode => l_chr_retcode, in_num_cash_receipt_id => k.cash_receipt_id, in_num_writeoff_amount => l_apply_amount, in_chr_appl_flag => 'ROUNDING DIFF', in_chr_major_head => cur_appr_refd_headers_rec.major_head, in_chr_assmt_year => cur_appr_refd_headers_rec.assmt_year, in_dte_apply_date => cur_appr_refd_headers_rec.approval_date, p_in_irt_id => p_in_irt_id );
              l_stmt_processing  :=' Status of the Write off procedure call is ' ||l_chr_retcode ;
              l_chr_exe_location :='CSA023';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              IF l_chr_retcode    <> '0' THEN
                p_out_chr_errbuff :='Error in Writeoff for ROUNDING DIFF ' || '-' || l_chr_errbuff ;
				dbms_output.put_line('Error in Writeoff for ROUNDING DIFF ' || '-' || l_chr_errbuff);
                write_msg( g_write_logfile,p_out_chr_errbuff);
                p_out_chr_retcode := g_chr_failure_code;
                RAISE custom_exception;
                RETURN;
              END IF; -- IF l_chr_retcode <> '0'
              -- 'Error in Refd Round off Amount update '
              l_stmt_processing  :='Updating Round off Amt for cash receipt ';
              l_chr_exe_location :='CSA024';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_lines
              SET refd_roundoff_amount = -l_apply_amount
              WHERE reference_id         =cur_appr_refd_headers_rec.reference_id
              AND cash_receipt_id        = k.cash_receipt_id;
            END IF; -- IF l_writeoff_amount <> 0
            l_writeoff_amount := l_writeoff_amount - l_apply_amount;
            EXIT
          WHEN l_writeoff_amount = 0;
          END LOOP; -- FOR k IN (SELECT cash_receipt_id,
        ELSIF l_roundoff_amount > 0 THEN
          l_stmt_processing    := ' Calling Interest recpt API as Round off amt > 0 ';
          l_chr_exe_location   :='CSA025';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          write_debug( g_debug_flag ,cur_appr_refd_headers_rec.irt_id);
          write_debug( g_debug_flag ,cur_appr_refd_headers_rec.reference_id);
          write_debug( g_debug_flag ,l_roundoff_amount);
          Create_interest_recpt (l_chr_errbuff, l_chr_retcode, cur_appr_refd_headers_rec.reference_id, l_roundoff_amount, 'RRD', cur_appr_refd_headers_rec.irt_id );
          l_stmt_processing  :=' Return status of Interest Recpt API is ' || l_chr_retcode ||'-'||l_chr_errbuff ;
          l_chr_exe_location :='CSA026';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          IF l_chr_retcode    <> '0' THEN
            p_out_chr_errbuff :='Error in receipt creation for ROUNDING DIFF ' || '-' || l_chr_errbuff ;
            write_msg( g_write_logfile,p_out_chr_errbuff);
            p_out_chr_retcode := g_chr_failure_code;
            RETURN;
          END IF; -- IF l_chr_retcode <> '0'
        END IF;   -- ELSIF l_roundoff_amount > 0
        l_stmt_processing  := ' Recomputing Total Refd amount in Refd Headers ';
        l_chr_exe_location :='CSA027';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        UPDATE xx_refd_headers
        SET total_refd_amount  = total_refd_amount + l_roundoff_amount ,
          refd_roundoff_amount = l_roundoff_amount
        WHERE reference_id       = cur_appr_refd_headers_rec.reference_id;
      END IF; -- IF l_status = 0
    END LOOP; -- FOR cur_appr_refd_headers_rec IN cur_appr_refd_headers(
    -- p_id_num )
    write_debug( g_debug_flag , '-----------------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Apply Refd Adjustment with Cross Schedule Type Program - ENDS ***');
    write_debug( g_debug_flag , '------------------------------------------------------------------------') ;
    l_stmt_processing := ' Moving out of Routine crosssched_adjust';
    write_debug( g_debug_flag , l_stmt_processing);
  EXCEPTION
  WHEN custom_exception THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||p_out_chr_errbuff;
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff) ;
      END IF;
    END IF;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255) ;
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff) ;
      END IF;
    END IF;
  END crosssched_adjust;
  -- ***********************End of procedure / Function ******************
  PROCEDURE excess_collect(
      p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
      p_out_chr_retcode OUT NOCOPY VARCHAR2,
      p_in_irt_id IN VARCHAR2 )
  AS
    /****************************************************************************
    *****
    * Type : Procedure
    * Name : EXCESS_COLLECT
    * Input Parameters : None
    * Output Parameters : out_chr_errbuff
    * out_chr_retcode
    * Purpose : Procedure to mark the records for refd for which we have excess
    receipt
    *
    *****************************************************************************
    *********
    * Modified Date Modified By Version Modification Type Modification Details *
    * ------------- ------------ -------- -----------------
    -------------------------- *
    *****************************************************************************
    **********/
    -- User defined exception for Commit with Warning
    --
    custom_exception          EXCEPTION;
    l_batch_id                NUMBER;
    l_uniq_ref_id             NUMBER;
    l_rfnd_ins_chk            NUMBER;
    l_inv_amount              NUMBER;
    l_recpt_amount            NUMBER;
    l_num_amount_due_original NUMBER;
    l_num_day_dly_attras      NUMBER;
    l_customer_trx_date       DATE;
    l_chr_irt_due_date        DATE;
    l_chr_vld_orgirt_date     DATE;
    l_chr_approval_date       DATE;
    l_chr_errbuff             VARCHAR2 (5000);
    l_chr_retcode             VARCHAR2 (10);
    l_chr_irt_id              VARCHAR2 (150);
    l_chr_schedule_type       VARCHAR2 (150);
    l_err_msg                 VARCHAR2 (5000);
    l_chr_proc_name           VARCHAR2(50) :='';
    l_chr_exe_location        VARCHAR2(50) :='';
    l_stmt_processing         VARCHAR2(200);
    ref_amt                   NUMBER:= 0;
    cash_r_id ar_cash_receipts_all.cash_receipt_id%type;
    rec_amt NUMBER:=0;
    v_gl_1  VARCHAR2(4000);
    v_trx_header_id ar_trx_header_gt.trx_header_id%type;
    V_AMOUNT  NUMBER := 0; -- Added for CR - 661 on 12-MAR-2019
    v_gl_att1 NUMBER :=0;
    --  L_SOURCE IRT_PROCESS_CONTROL_MSTR.SOURCE_NAME%TYPE; --added for CR#690 on 08-May-18 -- Commented for CR - 690 - DDT-BBS ABC Changes
    -- Main Cursor for select the Invoice, Id etc
    CURSOR cur_excess_collect_inv (p_in_irt_id IN VARCHAR2)
    IS
    WITH main2 AS
      (SELECT
        /*+ materialize */
        rownum ,
        RAT1.customer_trx_id trx_id
      FROM ra_customer_trx_all RAT1
      WHERE RAT1.attribute9                = 'PCM CLOSED'
      AND RAT1.interface_header_attribute1 = p_in_irt_id
      AND EXISTS
        (SELECT
          /*+ index(arc xx_ar_cash_receipts_att12) */
          'x'
        FROM ar_cash_receipts_all ARC
        WHERE ARC.attribute5            = RAT1.attribute5
        AND ( ( ARC.attribute4          = RAT1.attribute4
        AND ARC.attribute15            IN ('REFD CROSSMAJOR IN PROCESS', 'PARTIALLY MATCHED', 'MATCHED','SPI PARTIALLY MATCHED') ) --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
        OR ( TO_NUMBER (ARC.attribute4) < TO_NUMBER (RAT1.attribute4)
        AND ARC.global_attribute4       = 'TS'
        AND ARC.attribute2              = '200'
        AND ARC.attribute15 NOT        IN ('CLAIMED', 'REFD IN PROCESS') ) )
        AND ARC.attribute1              = RAT1.ATTRIBUTE1
        AND ARC.attribute12             = RAT1.ATTRIBUTE11
          --AND ARC.attribute2                    <> '106'
        AND ARC.attribute2 NOT                IN ('106','107')                                       --Modified for BBS
        AND ARC.attribute2                    IN ('100', '200', '300', 'XCL','PMR','SPI','5A','OTH') -- Added PMR as part of CR#0653  --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
        AND TO_NUMBER (ARC.global_attribute10) > 0
        )
      ) ,
      RAT AS
      (SELECT ROWNUM,
        RAT.customer_trx_id ,
        RAT.trx_number ,
        RAT.bill_to_customer_id ,
        RAT.attribute4 assmt_year ,
        RAT.attribute5 customer_number ,
        RAT.attribute2 bank_account ,
        RAT.attribute1 major_head ,
        RAT.attribute9 status ,
        RAT.attribute7 schedule_type ,
        RAT.attribute10 dmd_serv_date ,
        RAT.attribute11 irt_id ,
        TO_NUMBER (RAT.global_attribute1) global_attribute1
      FROM ra_customer_trx_all RAT
      WHERE RAT.attribute9                = 'PCM CLOSED'
      AND RAT.interface_header_attribute1 = p_in_irt_id
      )
    SELECT RAT.customer_trx_id ,
      RAT.trx_number ,
      RAT.bill_to_customer_id ,
      assmt_year ,
      customer_number ,
      bank_account ,
      major_head ,
      status ,
      schedule_type ,
      dmd_serv_date ,
      irt_id ,
      global_attribute1
    FROM RAT
    WHERE EXISTS
      ( SELECT 'x' FROM main2 WHERE main2.trx_id = RAT.customer_trx_id
      );
    -- Main Cursor for select the Invoice, Id etc
    CURSOR cur_excess_collect_recpt ( in_customer_number IN VARCHAR2, in_assmt_year IN VARCHAR2, in_major_head IN VARCHAR2, in_customer_trx_id IN NUMBER, in_irt_id IN VARCHAR2, in_irt_schedule_type IN VARCHAR2) -- added for 661
    IS
      SELECT arc.cash_receipt_id ,
        TO_NUMBER (arc.global_attribute10) amount ,
        arc.pay_from_customer ,
        arc.receipt_number ,
        arc.receipt_date ,
        arc.attribute4 assmt_year ,
        TO_NUMBER (arc.global_attribute10) claim_amount ,
        arc.attribute5 customer_number ,
        arc.attribute1 major_head ,
        arc.attribute2 minor_head ,
        arc.attribute15 ,
        in_customer_trx_id customer_trx_id
      FROM ar_cash_receipts_all arc
      WHERE arc.attribute5                   = in_customer_number
      AND ( ( arc.attribute4                 = in_assmt_year
      AND arc.attribute15                   IN('REFD CROSSMAJOR IN PROCESS', 'PARTIALLY MATCHED', 'MATCHED','SPI PARTIALLY MATCHED') ) --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
      OR ( arc.global_attribute4             = 'TS'
      AND TO_NUMBER (arc.attribute4)         < TO_NUMBER (in_assmt_year)
      AND arc.attribute15 NOT               IN ('CLAIMED', 'REFD IN PROCESS')
      AND arc.attribute2                     = '200' ) )
      AND arc.attribute1                     = in_major_head
      AND arc.attribute12                    = in_irt_id
      AND TO_NUMBER (arc.global_attribute10) > 0
        --AND arc.attribute2
        -- <> '106'
      AND arc.attribute2 NOT IN ('106','107')                                       --Modified for BBS
      AND arc.attribute2 IN ('100', '200', '300', 'XCL','PMR','SPI','5A','OTH') -- Added PMR as part of CR#0653 --Added  Minor Head 'OTH' for CR#0613(5A-SPI)-Phase2
      AND ARC.STATUS = 'UNAPP'
      AND get_irt_trx_id(arc.cash_receipt_id, arc.attribute5, arc.attribute4, arc.attribute1, arc.attribute2, NVL (arc.global_attribute4, 'ABC') , in_irt_schedule_type) = in_customer_trx_id
      ORDER BY arc.receipt_date,
        arc.cash_receipt_id ASC;
    -- Cursor to fetch different Invoice Id created for a batch
    CURSOR cur_batch ( p_batch_id IN NUMBER)
    IS
      SELECT customer_trx_id FROM ra_customer_trx_all WHERE batch_id = p_batch_id;
    -- Cursor to fetch Errors encountered for Invoice Id created for a batch
    CURSOR Cur_list_errors
    IS
      SELECT trx_header_id ,
        trx_line_id ,
        trx_salescredit_id ,
        trx_dist_id ,
        trx_contingency_id ,
        error_message ,
        invalid_value
      FROM ar_trx_errors_gt;
  BEGIN

    l_chr_proc_name    := 'Excess_collect';
    p_out_chr_retcode  := g_chr_success_code;
    p_out_chr_errbuff  := '';
    l_chr_exe_location := 'ECR_0001';
    l_stmt_processing  := ' Entering Routine crosssched_adjust';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    --Update excess DDT collection status
    l_chr_exe_location := 'ECR_0003';
    l_stmt_processing  :='Update excess DDT/BBS collection status';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line('Start of Excess_collect');

    FOR k IN
    (SELECT --/*+ NOPARALLEL(arc) */ --Commented on 9th April, 2015 after
      -- upgrade
      --/*+ PARALLEL(arc) */ -- Added on 10th April for checking performance
      arc.cash_receipt_id,
      TO_NUMBER (arc.global_attribute10) amount,
      TO_NUMBER (rat1.global_attribute1) global_attribute1,
      rat1.attribute11 attribute11,
      rat1.attribute5 attribute5,
      rat1.attribute4 attribute4,
      arc.attribute4 assmt_year,
      arc.attribute1 major_head,
      arc.attribute2,--added as a part of BBS
      rat1.attribute3 approval_date
    FROM ar_cash_receipts_all arc,
      ra_customer_trx_all rat1
    WHERE rat1.attribute9 = 'PCM CLOSED'
      --AND rat1.attribute7                    = 'DDT'
    AND rat1.attribute7 IN ('DDT','BBS')
    AND arc.attribute5   = rat1.attribute5
    AND arc.attribute4   = rat1.attribute4
    AND ARC.ATTRIBUTE12  = p_in_irt_id --Modified for Performance Tuning#12-May
      -- -2015
    AND arc.attribute15 IN ('REFD CROSSMAJOR IN PROCESS','PARTIALLY MATCHED', 'MATCHED')
    AND arc.attribute1   = rat1.attribute1
    AND arc.attribute12  = rat1.attribute11
      --AND arc.attribute2                     = '106'
    AND arc.attribute2                    IN ('106','107')
    AND TO_NUMBER (arc.global_attribute10) > 0
    )
    LOOP
      l_chr_exe_location := 'ECR_0004';
      l_stmt_processing  :='Update excess DDT collection status';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      UPDATE ar_cash_receipts_all arc
        --SET arc.attribute15       = 'EXCESS DDT'
      SET ARC.ATTRIBUTE15        = DECODE(K.ATTRIBUTE2,'106','EXCESS DDT','107', 'EXCESS BBS'),
        arc.global_attribute10   = 0
      WHERE arc.cash_receipt_id  = k.cash_receipt_id
      AND arc.attribute12        = p_in_irt_id
      AND arc.global_attribute10 > 0; --Added as a Part of Hotfix#116067 - 24-May
      -- -2016
      l_chr_errbuff      := NULL;
      l_chr_retcode      := NULL;
      l_chr_exe_location := 'ECR_0005';
      l_stmt_processing  :='Calling xx_writeoff_proc for MISC DDT REV ';
      --Added as a Part of Hotfix#116067 - Starts Here
      IF SQL%ROWCOUNT > 0 THEN
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		 dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        writeoff_proc (p_out_chr_errbuff => l_chr_errbuff, p_out_chr_retcode => l_chr_retcode, in_num_cash_receipt_id => k.cash_receipt_id, in_num_writeoff_amount => k.amount, in_chr_appl_flag => 'MISC DDT REV', in_chr_major_head => k.major_head, in_chr_assmt_year => k.assmt_year, in_dte_apply_date => k.approval_date, p_in_irt_id => p_in_irt_id );
      END IF;
      --Added as a Part of Hotfix#116067 - Ends Here
      IF l_chr_retcode <> '0' THEN
        write_debug( g_debug_flag , 'Error in Writeoff for MISC DDT REV '|| '-'|| l_chr_errbuff|| ' _ '|| SQLERRM );
        RAISE custom_exception;
      END IF;
      l_chr_exe_location := 'ECR_0006';
      l_stmt_processing  :='Checking amount for DDT Schedule Type ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      IF NVL (k.amount, 0) <> k.global_attribute1 THEN
        write_debug( g_debug_flag , 'K.amount for DDT Schedule Type is :'|| k.amount);
        write_debug( g_debug_flag , 'k.global_attribute1: '|| k.global_attribute1 );
        l_chr_exe_location := 'ECR_0007';
        l_stmt_processing  := 'Checking for existing record in xx_irt_fas_prcsng_hold ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		 dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        l_rfnd_ins_chk := 0;
        SELECT COUNT('x')
        INTO l_rfnd_ins_chk
        FROM xx_irt_fas_prcsng_hold
        WHERE irt_id          = k.attribute11
        AND hold_flag         = 'IRT REFD HOLD'
        AND release_flag     IS NULL;
        IF l_rfnd_ins_chk     = 0 THEN
          l_chr_exe_location := 'ECR_0008';
          l_stmt_processing  := 'Insert into xx_irt_fas_prcsng_hold table ID ASSMT_YEAR ' || k.attribute5 || '_' || k.attribute4;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		   dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
          INSERT
          INTO xx_irt_fas_prcsng_hold
            (
              irt_id,
              id,
              ay ,
              hold_flag ,
              creation_date ,
              last_update_date ,
              matched_amount ,          --Added for Hotfix 146632
              refd_amount_by_upstream --Added for Hotfix 146632
            )
            VALUES
            (
              k.attribute11 ,
              k.attribute5 ,
              k.attribute4 ,
              'IRT REFD HOLD' ,
              SYSDATE ,
              SYSDATE ,
              k.amount ,          --Added for Hotfix 146632
              k.global_attribute1 --Added for Hotfix 146632
            );
          write_debug ( g_debug_flag ,'No. of rows inserted in HOLD table1 '||sql%rowcount ) ;
        END IF; -- IF l_rfnd_ins_chk = 0
      END IF;   --IF l_chr_retcode <> '0'
    END LOOP;   -- FOR k IN
    -- END IF;       --Added as part of CR#690 on 08-May-18 -- Commented for CR - 690 - DDT-BBS ABC Changes
    /*Added changes for CR - 661 for 115TD implementation on 15-FEB-2019*/
    -- START
    l_chr_exe_location := 'ECR_00031';
    l_stmt_processing  :='Before opening 115TD loop';
    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
    FOR J IN
    (SELECT --/*+ NOPARALLEL(arc) */ --Commented on 9th April, 2015 after
        -- upgrade
        --/*+ PARALLEL(arc) */ -- Added on 10th April for checking performance
        arc.cash_receipt_id,
        rat1.customer_Trx_id,
        TO_NUMBER (arc.global_attribute10) amount,
        TO_NUMBER (rat1.global_attribute1) global_attribute1,
        rat1.attribute11 attribute11,
        rat1.attribute5 attribute5,
        rat1.attribute4 attribute4,
        arc.attribute4 assmt_year,
        arc.attribute1 major_head,
        arc.attribute2,
        rat1.attribute3 approval_date
      FROM ar_cash_receipts_all arc,
        ra_customer_trx_all rat1,
        ar_receivable_applications_all ara
      WHERE rat1.attribute9 = 'PCM CLOSED'
      AND rat1.attribute7  IN ('115TD')
      AND arc.attribute5    = rat1.attribute5
      AND arc.attribute4    = rat1.attribute4
      AND ARC.ATTRIBUTE12   = p_in_irt_id --Modified for Performance Tuning#12-May
        -- -2015
      AND arc.attribute15                    = 'REFD CROSSMAJOR IN PROCESS' -- Considering only Refd cases for CR - 661 on 15-FEB-2019
      AND arc.attribute1                     = rat1.attribute1
      AND arc.attribute12                    = rat1.attribute11
      AND ara.cash_receipt_id                = arc.cash_receipt_id  -- added for 661 for controlling updates on receipts used for closing 115TD invoices on 15-FEB-2019
      AND ara.applied_customer_trx_id        = rat1.customer_Trx_id -- added for 661 for controlling updates on receipts used for closing 115TD invoices on 15-FEB-2019
      AND arc.attribute2                    IN ('100','300')        -- considering only 100 and 300 receipts for 115TD schedule claims for CR - 661 on 15-FEB-2019
      AND TO_NUMBER (arc.global_attribute10) > 0
    )
    LOOP
      l_chr_exe_location := 'ECR_00041';
      l_stmt_processing  :='Update excess 115TD collection status';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
	   dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      UPDATE ar_cash_receipts_all arc
      SET ARC.ATTRIBUTE15        = 'EXCESS 115TD',
        arc.global_attribute10   = 0
      WHERE arc.cash_receipt_id  = J.cash_receipt_id
      AND arc.attribute12        = p_in_irt_id
      AND arc.global_attribute10 > 0; --Added as a Part of Hotfix#116067 - 24-May
      write_debug( g_debug_flag ,'No. of rows updated 115TD excess: '||sql%rowcount );
      -- -2016
      l_chr_errbuff      := NULL;
      l_chr_retcode      := NULL;
      l_chr_exe_location := 'ECR_00051';
      l_stmt_processing  :='Calling xx_writeoff_proc for MISC 115TD REV ';
      --Added as a Part of Hotfix#116067 - Starts Here
      IF SQL%ROWCOUNT > 0 THEN
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		 dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        writeoff_proc (p_out_chr_errbuff => l_chr_errbuff, p_out_chr_retcode => l_chr_retcode, in_num_cash_receipt_id => j.cash_receipt_id, in_num_writeoff_amount => j.amount, in_chr_appl_flag => 'MISC 115TD REV', in_chr_major_head => j.major_head, in_chr_assmt_year => j.assmt_year, in_dte_apply_date => j.approval_date, p_in_irt_id => p_in_irt_id );
      END IF;
      --Added as a Part of Hotfix#116067 - Ends Here
      IF l_chr_retcode <> '0' THEN
        write_debug( g_debug_flag , 'Error in Writeoff for MISC 115TD REV '|| '-'|| l_chr_errbuff|| ' _ '|| SQLERRM );
		dbms_output.put_line('Error in Writeoff for MISC 115TD REV '|| '-'|| l_chr_errbuff|| ' _ '|| SQLERRM );
        RAISE custom_exception;
      END IF;
      V_AMOUNT  := V_AMOUNT+J.AMOUNT;
      v_gl_att1 := j.global_attribute1;
    END LOOP;
    l_chr_exe_location := 'ECR_00061';
    l_stmt_processing  :='Checking amount for 115TD Schedule Type ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    IF NVL (v_amount, 0) <> v_gl_att1 THEN
      write_debug( g_debug_flag , 'j.amount for 115TD Schedule Type is :'|| V_AMOUNT);
      write_debug( g_debug_flag , 'j.global_attribute1: '|| v_gl_att1 );
      l_chr_exe_location := 'ECR_00071';
      l_stmt_processing  := 'Checking for existing record in xx_irt_fas_prcsng_hold ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      l_rfnd_ins_chk := 0;
      SELECT COUNT('x')
      INTO l_rfnd_ins_chk
      FROM xx_irt_fas_prcsng_hold
      WHERE irt_id          = p_in_irt_id
      AND hold_flag         = 'IRT REFD HOLD'
      AND release_flag     IS NULL;
      IF l_rfnd_ins_chk     = 0 THEN
        l_chr_exe_location := 'ECR_00081';
        --        l_stmt_processing  := 'Insert into xx_irt_fas_prcsng_hold table ID ASSMT_YEAR ' || j.attribute5 || '_' || j.attribute4;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        INSERT
        INTO xx_irt_fas_prcsng_hold
          (
            irt_id,
            id,
            ay ,
            hold_flag ,
            creation_date ,
            last_update_date ,
            matched_amount ,          --Added for Hotfix 146632
            refd_amount_by_upstream --Added for Hotfix 146632
          )
          VALUES
          (
            P_IN_IRT_ID ,
            NULL,
            NULL,
            --            j.attribute5 ,
            --            j.attribute4 ,
            'IRT REFD HOLD' ,
            SYSDATE ,
            SYSDATE ,
            v_amount , --Added for Hotfix 146632
            v_gl_att1  --Added for Hotfix 146632
          );
        write_debug ( g_debug_flag ,'No. of rows inserted in HOLD table3 '||sql%rowcount ) ;
      END IF; -- IF l_rfnd_ins_chk = 0
    END IF;   --IF l_chr_retcode <> '0'
    --  END LOOP;   -- FOR J IN
    /*Added changes for CR - 661 for 115TD implementation on 15-FEB-2019*/
    -- END
    l_chr_exe_location := 'ECR_0009';
    l_stmt_processing  := 'Fetching records from cur_excess_collect_inv for IRT_ID ';
	dbms_output.put_line('Fetching records from cur_excess_collect_inv for IRT_ID ');
    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
    FOR cur_excess_collect_inv_rec IN cur_excess_collect_inv
    (
      p_in_irt_id
    )
    LOOP
      l_recpt_amount     := 0;
      l_inv_amount       := 0;
      l_chr_exe_location := 'ECR_0010';
	  dbms_output.put_line('ECR_0010');
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing||cur_excess_collect_inv_rec.customer_trx_id||cur_excess_collect_inv_rec.schedule_type ) ;
      FOR cur_excess_collect_recpt_rec IN cur_excess_collect_recpt
      (
        cur_excess_collect_inv_rec.customer_number, cur_excess_collect_inv_rec.assmt_year, cur_excess_collect_inv_rec.major_head, cur_excess_collect_inv_rec.customer_trx_id, cur_excess_collect_inv_rec.irt_id, cur_excess_collect_inv_rec.schedule_type -- Added for 661
      )
      LOOP

        write_debug
        (
          g_debug_flag ,'l_recpt_amount43' ||'-'||l_recpt_amount
        )
        ;
        l_recpt_amount := l_recpt_amount + cur_excess_collect_recpt_rec.claim_amount;
        write_debug ( g_debug_flag ,'l_recpt_amount44' ||'-'||l_recpt_amount ) ;
		dbms_output.put_line('l_recpt_amount44' ||'-'||l_recpt_amount);
      END LOOP; -- FOR cur_excess_collect_recpt_rec IN
      IF l_recpt_amount > 0 THEN
        SELECT xx_refd_headers_seq.NEXTVAL INTO l_uniq_ref_id FROM DUAL;
        l_chr_irt_id              := NULL;
        l_chr_schedule_type       := NULL;
        l_num_amount_due_original := NULL;
        l_chr_irt_due_date        := NULL;
        l_customer_trx_date       := NULL;
        l_chr_vld_orgirt_date     := NULL;
        l_num_day_dly_attras      := NULL;
        l_chr_exe_location        := 'ECR_0011';
        l_stmt_processing         := 'IRT data Fetch for Refd table population for customer_trx_id';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        SELECT rat.attribute11,
          rat.attribute7,
          TO_DATE(rat.attribute13, 'DD-MON-YYYY'),
          arp.amount_due_original,
          rat.trx_date,
          TO_DATE (rat.attribute14, 'DD-MON-YYYY'),
          TO_NUMBER (rat.attribute15),
          TO_DATE (rat.attribute3, 'DD-MON-YYYY')
        INTO l_chr_irt_id ,
          l_chr_schedule_type ,
          l_chr_irt_due_date ,
          l_num_amount_due_original ,
          l_customer_trx_date ,
          l_chr_vld_orgirt_date ,
          l_num_day_dly_attras ,
          l_chr_approval_date
        FROM ra_customer_trx_all rat,
          ar_payment_schedules_all arp
        WHERE rat.customer_trx_id           = arp.customer_trx_id
        AND rat.customer_trx_id             =cur_excess_collect_inv_rec.customer_trx_id
        AND rat.interface_header_attribute1 = p_in_irt_id ;
        l_chr_exe_location                 := 'ECR_0012';
        write_debug( g_debug_flag , ' Schedule Type is : ' || l_chr_schedule_type );
        write_debug( g_debug_flag ,l_chr_exe_location );
        IF (l_chr_schedule_type = 'IT') OR ( l_chr_schedule_type = 'FBT' ) THEN --Commented If Condition as part of CR#690, Un-- Commented for CR - 690 - DDT-BBS ABC Changes
          IF l_recpt_amount    <> cur_excess_collect_inv_rec.global_attribute1 THEN
            write_debug( g_debug_flag ,'l_recpt_amount for : '|| l_chr_schedule_type || ' Schedule Type is :'|| l_recpt_amount);
            write_debug( g_debug_flag , 'cur_excess_collect_inv_rec.global_attribute1: ' || cur_excess_collect_inv_rec.global_attribute1);
			dbms_output.put_line('cur_excess_collect_inv_rec.global_attribute1: ' || cur_excess_collect_inv_rec.global_attribute1);
            l_rfnd_ins_chk     := 0;
            l_chr_exe_location := 'ECR_0011';
            l_stmt_processing  :='checking in xx_irt_fas_prcsng_hold ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
			dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
            SELECT COUNT('x')
            INTO l_rfnd_ins_chk
            FROM xx_irt_fas_prcsng_hold
            WHERE irt_id          = cur_excess_collect_inv_rec.irt_id
            AND hold_flag         = 'IRT REFD HOLD'
            AND release_flag     IS NULL;
            IF l_rfnd_ins_chk     = 0 THEN
              l_chr_exe_location := 'ECR_0012';
              l_stmt_processing  :='insert into xx_irt_fas_prcsng_hold ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
			  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
              INSERT
              INTO xx_irt_fas_prcsng_hold
                (
                  irt_id ,
                  id,
                  ay ,
                  hold_flag ,
                  creation_date ,
                  last_update_date ,
                  matched_amount ,          --Added for Hotfix 146632
                  refd_amount_by_upstream --Added for Hotfix 146632
                )
                VALUES
                (
                  cur_excess_collect_inv_rec.irt_id ,
                  cur_excess_collect_inv_rec.customer_number ,
                  cur_excess_collect_inv_rec.assmt_year ,
                  'IRT REFD HOLD' ,
                  SYSDATE ,
                  SYSDATE ,
                  l_recpt_amount,                              --Added for Hotfix 146632
                  cur_excess_collect_inv_rec.global_attribute1 --Added for Hotfix
                  -- 146632
                );
              write_debug ( g_debug_flag ,'No. of rows inserted in HOLD table2 '||sql%rowcount ) ;
			  dbms_output.put_line('No. of rows inserted in HOLD table2 '||sql%rowcount ) ;
            END IF; -- IF l_rfnd_ins_chk = 0
          END IF;   -- IF l_recpt_amount <>
          -- cur_excess_collect_inv_rec.global_attribute1
        END IF; -- IF (l_chr_schedule_type = 'IT') --Commented end If Condition as part of CR#690, un-- Commented for CR - 690 - DDT-BBS ABC Changes
        l_chr_exe_location := 'ECR_0013';
        l_stmt_processing  :='insert into xx_refd_headers ';
        write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
		dbms_output.put_line('insert into xx_refd_headers ');
        INSERT
        INTO xx_refd_headers
          (
            reference_id ,
            irt_id ,
            customer_trx_id ,
            id_number ,
            irt_ay ,
            major_head,
            irt_schedule_type,
            total_refd_amount,
            refd_identify_amount,
            refd_adjustment_amount,
            net_refd_amount,
            refd_interest_amount,
            refd_roundoff_amount,
            refd_crossadjust_amount,
            refd_identified_date,
            refd_status,
            approval_date,
            approval_user,
            refd_banker_status,
            Customer_name,
            Customer_address,
            payment_mode,
            total_xx_computed,
            irt_returns_due_date,
            customer_trx_date,
            irt_filing_delay_mnths,
            last_updated_by,
            last_update_date,
            last_update_login,
            created_by,
            creation_date,
            process_flag,
            vld_orgirt_date,
            day_dly_attras,
            ref_to_date
          )
          VALUES
          (
            l_uniq_ref_id,
            l_chr_irt_id,
            cur_excess_collect_inv_rec.customer_trx_id,
            cur_excess_collect_inv_rec.customer_number,
            cur_excess_collect_inv_rec.assmt_year,
            cur_excess_collect_inv_rec.major_head,
            l_chr_schedule_type,
            NVL (l_recpt_amount, 0),
            NVL (l_recpt_amount, 0),
            0,
            0,
            0,
            0,
            0,
            --SYSDATE, --l_chr_approval_date ,  <-- commented for cr 230 (244A) on --Commented sysdate for Hotfix_199485 on 13-MAR-2019
            l_chr_approval_date, --Added for Hotfix_199485 on 13-MAR-2019
            -- 16-apr-2014
            'NEW',
            --SYSDATE, -- l_chr_approval_date, <-- commented for cr 230 (244A)  on  --Commented sysdate for Hotfix_199485 on 13-MAR-2019
            l_chr_approval_date, --Added for Hotfix_199485 on 13-MAR-2019
            -- 16-apr-2014
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            l_num_amount_due_original,
            l_chr_irt_due_date,
            l_customer_trx_date,
            delaymonth_calc ( l_chr_irt_due_date ,l_chr_vld_orgirt_date ) ,
            g_num_user_id ,
            SYSDATE ,
            g_num_login_id ,
            g_num_user_id ,
            SYSDATE ,
            'N' ,
            l_chr_vld_orgirt_date ,
            l_num_day_dly_attras ,
            (l_chr_approval_date- l_num_day_dly_attras)
          );
        FOR cur_excess_collect_recpt_rec IN cur_excess_collect_recpt
        (
          cur_excess_collect_inv_rec.customer_number, cur_excess_collect_inv_rec.assmt_year, cur_excess_collect_inv_rec.major_head, cur_excess_collect_inv_rec.customer_trx_id, cur_excess_collect_inv_rec.irt_id, cur_excess_collect_inv_rec.schedule_type -- Added for 661
        )
        LOOP
          l_chr_exe_location := 'ECR_0014';
          l_stmt_processing  :='insert into xx_refd_lines';
		  dbms_output.put_line('insert into xx_refd_lines');
          write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
          INSERT
          INTO xx_refd_lines
            (
              reference_id ,
              cash_receipt_id ,
              receipt_ay ,
              minor_head ,
              excess_receipt_amount ,
              refd_roundoff_amount ,
              refd_adjustment_amount ,
              net_refd_amount ,
              refd_crossadjust_amount ,
              rr_refdemadj_amount ,
              receipt_date ,
              last_updated_by ,
              last_update_date ,
              last_update_login ,
              created_by ,
              creation_date
            )
            VALUES
            (
              l_uniq_ref_id,
              cur_excess_collect_recpt_rec.cash_receipt_id,
              cur_excess_collect_recpt_rec.assmt_year,
              cur_excess_collect_recpt_rec.minor_head,
              cur_excess_collect_recpt_rec.claim_amount,
              0,
              0,
              0,
              0,
              0,
              cur_excess_collect_recpt_rec.receipt_date,
              g_num_user_id,
              SYSDATE,
              g_num_login_id,
              g_num_user_id,
              SYSDATE
            );
          write_debug ( g_debug_flag ,'Number of rows inserted in RLines' ||'-'||sql%rowcount ) ;
          l_chr_exe_location := 'ECR_0015';
          l_stmt_processing  :='update the claim amount';
          write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
		  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing ) ;
          -- To update the claim amount
          SELECT TO_NUMBER (arc.global_attribute10) - cur_excess_collect_recpt_rec.claim_amount,
            arc.global_attribute10,
            cur_excess_collect_recpt_rec.claim_amount
          INTO ref_amt,
            rec_amt,
            cash_r_id
          FROM ar_cash_receipts_all arc
          WHERE arc.cash_receipt_id = cur_excess_collect_recpt_rec.cash_receipt_id
          AND arc.attribute12       = p_in_irt_id;
          write_debug ( g_debug_flag ,'ref_amt-this is coming here' ||'-'|| ref_amt ) ;
          write_debug ( g_debug_flag ,'rec_amt-this is coming here' ||'-'|| rec_amt ) ;
          write_debug ( g_debug_flag ,'Cash_r_id amt-this is coming here' ||'-'|| cash_r_id ) ;
		  dbms_output.put_line( 'ref_amt-this is coming here' ||'-'|| ref_amt ) ;
          dbms_output.put_line('rec_amt-this is coming here' ||'-'|| rec_amt ) ;
          dbms_output.put_line('Cash_r_id amt-this is coming here' ||'-'|| cash_r_id ) ;
          UPDATE ar_cash_receipts_all arc
          SET arc.global_attribute10 = TO_NUMBER (arc.global_attribute10) - cur_excess_collect_recpt_rec.claim_amount
          WHERE arc.cash_receipt_id  = cur_excess_collect_recpt_rec.cash_receipt_id
          AND arc.attribute12        = p_in_irt_id;
          l_chr_exe_location        := 'ECR_0016';
          l_stmt_processing         :='update status for Matched receipts';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          -- To update status for Matched receipts
          UPDATE ar_cash_receipts_all arc
          SET arc.attribute15       = 'REFD IN PROCESS'
          WHERE arc.cash_receipt_id = cur_excess_collect_recpt_rec.cash_receipt_id
            --AND arc.attribute15                   <> 'PARTIALLY MATCHED' --Commented for CR#0613(5A-SPI)-Phase2
          AND arc.attribute15 NOT               IN ('PARTIALLY MATCHED','SPI PARTIALLY MATCHED') --Added status 'SPI PARTIALLY MATCHED' for CR#0613(5A-SPI)-Phase2
          AND TO_NUMBER (arc.global_attribute10) = 0
          AND arc.attribute12                    = p_in_irt_id;
          write_debug ( g_debug_flag ,'Number of rows updated as Refd in ARC' ||'-'||sql%rowcount ) ;
        END LOOP;
      END IF;
    END LOOP;
    write_debug( g_debug_flag , '*** Identify Excess Collection for Refd/Adjustment Approval Program - ENDS ***' );
  EXCEPTION
  WHEN custom_exception THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
	dbms_output.put_line('Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255));
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_debug( g_debug_flag , 'Exiting Program ( Rolled bac k ) : '|| p_out_chr_errbuff || ' '|| SQLERRM );
		dbms_output.put_line('Exiting Program ( Rolled bac k ) : '|| p_out_chr_errbuff || ' '|| SQLERRM );
      END IF;
    END IF;
    write_debug( g_debug_flag , 'Program Completion time : '|| TO_CHAR ( CURRENT_DATE,'DD-MON-YYYY hh24:mi:ss') );
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  END excess_collect ;
--*********************** End of Procedure / Funtion ******************
  PROCEDURE ts_xx_calc_proc(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      p_in_asmnt_yr      IN NUMBER,
      p_in_ref_id        IN NUMBER,
      p_in_ref_int_amt   IN NUMBER,
      p_in_cash_rec_id   IN NUMBER,
      p_in_Customer_typ  IN VARCHAR2,
      p_in_irt_id        IN VARCHAR2,
      p_in_Customer_desc IN VARCHAR2 DEFAULT NULL)--added for SR #179493 on 27-APR-2018    )
  AS
    /****************************************************************************
    ****************************************
    * Type : Procedure
    * Name : ts_xx_calc_proc
    * Input Parameters : p_in_asmnt_yr, p_in_ref_id,p_in_ref_int_amt,
    p_in_cash_rec_id
    p_in_Customer_typ,p_in_irt_id
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * Purpose : Procedure to calculate NRI TS.
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 13-JAN-2012
    * Last Reviewed By :
    * Last Reviewed Date : ******************************************************
    ***************************************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    ----------------- -----------------------
    * 13-Jan-2012 Infosys 1.0 Baseline. *****************************************
    ****************************************************************************/
    --
    l_amount_inst      NUMBER;
    l_chr_errbuff      VARCHAR2 (5000);
    l_chr_retcode      VARCHAR2 (10);
    l_tx_ded_id        NUMBER;
    l_ref_id           NUMBER;
    l_cash_id          NUMBER;
    l_num_cnt          NUMBER;
    l_irt_id           VARCHAR2(15);
    l_chr_proc_name    VARCHAR2(50)  := 'ts_xx_calc_proc';
    l_chr_exe_location VARCHAR2(250) := '';
    l_stmt_processing  VARCHAR2(250) := '';
    custom_exception   EXCEPTION;
  TYPE tbl_xx_deduction_id
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
TYPE tbl_reference_id
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
TYPE tbl_cash_receipt_id
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
TYPE tbl_xx_rate_id
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
TYPE tbl_xx_rate
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
TYPE tbl_xx_code
IS
  TABLE OF VARCHAR2 (150 BYTE) INDEX BY BINARY_INTEGER;
TYPE tbl_xx_calculation_sequence
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
TYPE tbl_amount
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
TYPE tbl_creation_date
IS
  TABLE OF DATE INDEX BY BINARY_INTEGER;
TYPE l_calc_rec
IS
  RECORD
  (
    xx_deduction_id tbl_xx_deduction_id,
    reference_id tbl_reference_id,
    cash_receipt_id tbl_cash_receipt_id,
    xx_rate_id tbl_xx_rate_id,
    xx_rate tbl_xx_rate,
    xx_code tbl_xx_code,
    xx_calculation_sequence tbl_xx_calculation_sequence,
    amount tbl_amount,
    creation_date tbl_creation_date );
  l_calc_tbl l_calc_rec;
BEGIN
  l_num_cnt          := 0;
  l_chr_exe_location := ' TTC-01';
  l_stmt_processing  := ' Entering TS XX Calc Proc ' ;
  FOR l_count_rec IN
  (SELECT xx_code,
    xx_rate,
    xx_rate_id,
    amount_limit,
    xx_calculation_sequence,
    Customer_description
  FROM xx_xx_rate_master
  WHERE Customer_TYPE                = P_IN_Customer_TYP
  AND NVL(Customer_DESCRIPTION, 'X') = NVL(p_in_Customer_desc, 'X') --added for SR #179493 on 27-APR-2018
  AND active_flag                    = 'Y'
  AND assessment_year                = p_in_asmnt_yr
  ORDER BY xx_calculation_sequence
  )
  LOOP
    l_chr_exe_location := ' TTC-02';
    l_stmt_processing  := ' Processing the for Xx Code / Xx rate ' || l_count_rec.xx_code || '/'|| l_count_rec.xx_rate;
    l_amount_inst      := 0;
    --added for SR #179493 on 27-APR-2018 --Start
    -- for NC
    IF l_count_rec.xx_calculation_sequence = 1 AND p_in_Customer_typ='NC' AND l_count_rec.Customer_description=p_in_Customer_desc THEN
      l_amount_inst                        := ROUND (p_in_ref_int_amt * (l_count_rec.xx_rate / 100), 0);
    END IF;
    IF l_count_rec.xx_calculation_sequence = 2 AND p_in_Customer_typ='NC' AND l_count_rec.Customer_description=p_in_Customer_desc THEN
      IF l_count_rec.amount_limit           =10000000 AND p_in_ref_int_amt>= l_count_rec.amount_limit THEN
        l_amount_inst                      := ROUND (l_calc_tbl.amount (1) * (l_count_rec.xx_rate / 100), 0 );
      END IF;
      IF l_count_rec.amount_limit=5000000 AND p_in_ref_int_amt>= l_count_rec.amount_limit AND p_in_ref_int_amt<10000000 THEN
        l_amount_inst           := ROUND (l_calc_tbl.amount (1) * (l_count_rec.xx_rate / 100), 0 );
      END IF;
    END IF;
    IF l_count_rec.xx_calculation_sequence = 3 AND p_in_Customer_typ='NC' AND l_count_rec.Customer_description=p_in_Customer_desc THEN
      IF p_in_Customer_desc                 ='Individual/HUF/AOP/BOI' THEN
        l_amount_inst                      := ROUND ((l_calc_tbl.amount (1)+ l_calc_tbl.amount (2) + l_calc_tbl.amount (3)) * (l_count_rec.xx_rate / 100), 0 );
      END IF;
      IF p_in_Customer_desc='Other than Individual/HUF/AOP/BOI' THEN
        l_amount_inst     := ROUND ((l_calc_tbl.amount (1)+ l_calc_tbl.amount (2)) * (l_count_rec.xx_rate / 100), 0 );
      END IF;
    END IF;
    -- for CO
    IF l_count_rec.xx_calculation_sequence = 1 AND p_in_Customer_typ='CO' THEN
      l_amount_inst                        := ROUND (p_in_ref_int_amt * (l_count_rec.xx_rate / 100), 0);
    END IF;
    IF l_count_rec.xx_calculation_sequence = 2 AND l_count_rec.amount_limit =10000000 AND p_in_Customer_typ='CO' THEN
      IF p_in_ref_int_amt                  >= l_count_rec.amount_limit AND p_in_ref_int_amt <=100000000 THEN
        l_amount_inst                      := ROUND (l_calc_tbl.amount (1) * (l_count_rec.xx_rate / 100), 0 );
      END IF; --IF p_in_ref_int_amt > l_count_rec.amount_limit
    END IF;
    IF l_count_rec.xx_calculation_sequence = 2 AND p_in_Customer_typ ='CO' AND l_count_rec.amount_limit =100000000 THEN
      IF p_in_ref_int_amt                  >= l_count_rec.amount_limit THEN
        l_amount_inst                      := ROUND (l_calc_tbl.amount (1)* (l_count_rec.xx_rate / 100), 0);
      END IF;
    END IF;
    IF l_count_rec.xx_calculation_sequence = 3 AND p_in_Customer_typ ='CO' THEN
      l_amount_inst                        := ROUND ((l_calc_tbl.amount (1)+l_calc_tbl.amount (2)+l_calc_tbl.amount (3))* (l_count_rec.xx_rate / 100), 0);
    END IF;
    --added for SR #179493 on 27-APR-2018 --End
    --Hotfix#44373 Ends Here Added on 04-Apr-2014
    l_chr_exe_location := ' TTC-03';
    L_STMT_PROCESSING  := ' getting reference id , receipt id ' ;
    SELECT xx_deduction_id,
      reference_id,
      cash_receipt_id,
      irt_id
    INTO l_tx_ded_id,
      l_ref_id,
      l_cash_id ,
      l_irt_id
    FROM xx_irf_ts_header
    WHERE reference_id                               = p_in_ref_id
    AND cash_receipt_id                              = p_in_cash_rec_id
    AND IRT_ID                                       = P_IN_IRT_ID;
    l_num_cnt                                       := l_num_cnt + 1;
    l_calc_tbl.xx_deduction_id (l_num_cnt)         := l_tx_ded_id;
    l_calc_tbl.reference_id (l_num_cnt)             := l_ref_id;
    l_calc_tbl.cash_receipt_id (l_num_cnt)          := l_cash_id;
    l_calc_tbl.xx_rate_id (l_num_cnt)              := l_count_rec.xx_rate_id;
    l_calc_tbl.xx_code (l_num_cnt)                 := l_count_rec.xx_code;
    l_calc_tbl.xx_rate (l_num_cnt)                 := l_count_rec.xx_rate;
    l_calc_tbl.xx_calculation_sequence (l_num_cnt) := l_count_rec.xx_calculation_sequence;
    l_calc_tbl.creation_date (l_num_cnt)            := SYSDATE;
    l_calc_tbl.amount (l_num_cnt)                   := l_amount_inst;
  END LOOP; -- FOR l_count_rec IN
l_chr_exe_location := ' TTC-04';
l_stmt_processing  := ' Inserting ts Lines for the xxcodes ' ;
FOR i IN 1 .. l_num_cnt
LOOP
  --  select COUNT(1) from xx_IRF_TS_LINES
  --  where xx_code=l_calc_tbl.xx_code (i);
  --  if( l_calc_tbl.amount (i) <> 0) then
  INSERT
  INTO xx_irf_ts_lines
    (
      xx_deduction_id ,
      reference_id ,
      cash_receipt_id ,
      xx_rate_id ,
      xx_code ,
      xx_rate ,
      xx_calculation_sequence ,
      amount ,
      creation_date
    )
    VALUES
    (
      l_calc_tbl.xx_deduction_id (i) ,
      l_calc_tbl.reference_id (i) ,
      l_calc_tbl.cash_receipt_id (i) ,
      l_calc_tbl.xx_rate_id (i) ,
      l_calc_tbl.xx_code (i) ,
      l_calc_tbl.xx_rate (i) ,
      l_calc_tbl.xx_calculation_sequence (i) ,
      l_calc_tbl.amount (i) ,
      l_calc_tbl.creation_date (i)
    );
  --end if;
END LOOP; -- FOR i IN 1 .. l_num_cnt
EXCEPTION
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name || '-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || SUBSTR ( sqlerrm,1,255 ) ;
  write_msg ( g_write_logfile ,p_out_chr_errbuff ) ;
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode , p_in_irt_id => p_in_irt_id ) ;
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg ( g_write_logfile ,' Error also while Backup of error data of Procedure - ' || l_chr_errbuff ) ;
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode , p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL ,p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id ) ;
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg ( g_write_logfile ,' Error also while writing error data of Procedure - ' || l_chr_proc_name || '-' ||l_chr_errbuff ) ;
    END IF;
  END IF;
END ts_xx_calc_proc;
--*************************************** End of Procedure / Function
PROCEDURE ts_xx_rate
  (
    p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
    p_out_chr_retcode OUT NOCOPY VARCHAR2,
    p_in_par    IN VARCHAR2 DEFAULT NULL,
    p_in_irt_id IN VARCHAR2
  )
AS
  /****************************************************************************
  ****************************************
  * Type : Procedure
  * Name : ts_xx_rate
  * Input Parameters : p_in_par, p_in_irt_id
  * Output Parameters : p_out_chr_errbuff
  * p_out_chr_retcode
  * Input Parameters :
  * Purpose : Procedure to calculate NRI TS.
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 13-JAN-2012
  * Last Reviewed By :
  * Last Reviewed Date : ******************************************************
  ***************************************************************
  * Modified Date Modified By Version Reviewed By Reviewed Date Modification
  Type Modification Details
  * ------------- ------------ -------- --------------- --------------
  ----------------- ----------------------
  * 13-Jan-2012 Infosys 1.0 Baseline.
  * 21-May-2012 Infosys 1.1 Enhancement NRI TS Changes
  *commenting the Customer type check -bhagya to remove dependency on irt_personal_info for POC.
  *****************************************************************************
  ****************************************/
  --
  -- Cursor to get the Refd Details of IRT_ID.
  CURSOR cur_get_rfnd_details
    (
      p_in_irt_id IN VARCHAR2
    )
  IS
    SELECT *
    FROM
      (SELECT xrh.reference_id reference_id,
        irt_id,
        major_head,
        xrh.refd_identify_amount refd_identify_amount,
        xrh.id_number id_number,
        rctta.attribute2 status,
        irt_ay,
        xrl.cash_receipt_id cash_receipt_id,
        irt_schedule_type,
        approval_date,
        refd_interest_amount,
        excess_receipt_amount
      FROM xx_refd_headers xrh,
        xx_refd_lines xrl,
        ra_customer_trx_all rct,
        ra_cust_trx_types_all rctta
      WHERE xrh.reference_id      = xrl.reference_id
      AND xrl.minor_head          = 'IRF'
      AND xrh.refd_status       = 'PCM APPROVED'
      AND rct.customer_trx_id     = xrh.customer_trx_id
      AND rctta.cust_trx_type_id  = rct.cust_trx_type_id
      AND rctta.attribute2        = 'ORIGINAL'
      AND TO_NUMBER (xrh.irt_ay) >= 2010 --As the TS was introduced from
        -- 2010
      AND xrh.irt_schedule_type = 'IT'
      AND xrh.irt_id            = p_in_irt_id
      AND p_in_par             IS NULL -- added for Hotfix_131260 to fetch
        -- the record once
      AND NOT EXISTS
        (SELECT 1
        FROM xx_irt_fas_prcsng_hold xifph
        WHERE xifph.irt_id      = xrh.irt_id
        AND xifph.hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
        AND xifph.release_flag IS NULL
        )
    UNION ALL
    SELECT xrh.reference_id reference_id,
      xrh.irt_id irt_id,
      major_head,
      xrh.refd_identify_amount refd_identify_amount,
      xrh.id_number id_number,
      rctta.attribute2 status,
      irt_ay,
      xrl.cash_receipt_id cash_receipt_id,
      irt_schedule_type,
      approval_date,
      int_244_calc_amt refd_interest_amount,
      excess_receipt_amount
    FROM xx_refd_headers xrh,
      xx_refd_lines xrl,
      ra_customer_trx_all rct,
      ra_cust_trx_types_all rctta,
      xx_ref_int_lines xril
    WHERE xrh.reference_id     = xrl.reference_id
    AND xrl.minor_head         = 'IRF'
    AND xrh.refd_status      = 'PCM APPROVED'
    AND rct.customer_trx_id    = xrh.customer_trx_id
    AND rctta.cust_trx_type_id = rct.cust_trx_type_id
    AND rctta.attribute2      IN ('REVISED', 'RECTIFICATION')
    AND xril.rct_ref_id        = xrh.reference_id
    AND xrh.irt_id             = TO_CHAR (xril.irt_id)
    AND xrh.irt_id             = p_in_irt_id
    AND p_in_par              IS NULL -- added for Hotfix_131260 to fetch the
      -- record once
    AND xril.reversal_status IS NULL
    AND xril.seq             IN
      (SELECT MAX (seq)
      FROM xx_ref_int_lines xril1
      WHERE xril1.irt_id         = xril.irt_id
      AND xril1.int_244_calc_amt > 0
      )
    AND xril.int_244_calc_amt   > 0
    AND TO_NUMBER (xrh.irt_ay) >= 2010 --As the TS was introduced from 2010
    AND xrh.irt_schedule_type   = 'IT'
    AND NOT EXISTS
      (SELECT 1
      FROM xx_irt_fas_prcsng_hold xifph
      WHERE xifph.irt_id      = xrh.irt_id
      AND xifph.hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
      AND xifph.release_flag IS NULL
      )
    UNION ALL
    --------- below code added for NRI cases Hotfix_131260
    SELECT xrh.reference_id reference_id,
      xrh.irt_id irt_id,
      major_head,
      xrh.refd_identify_amount refd_identify_amount,
      xrh.id_number id_number,
      rctta.attribute2 status,
      irt_ay,
      xrl.cash_receipt_id cash_receipt_id,
      irt_schedule_type,
      approval_date,
      to_number(xrh.attribute5) refd_interest_amount,
      excess_receipt_amount
    FROM xx_refd_headers xrh,
      xx_refd_lines xrl,
      ra_customer_trx_all rct,
      ra_cust_trx_types_all rctta
    WHERE xrh.reference_id     = xrl.reference_id
    AND xrl.minor_head         = 'IRF'
    AND xrh.refd_status      = 'PCM APPROVED'
    AND rct.customer_trx_id    = xrh.customer_trx_id
    AND rctta.cust_trx_type_id = rct.cust_trx_type_id
    AND rctta.attribute2      IN ('REVISED', 'RECTIFICATION')
    AND xrh.irt_id             = p_in_irt_id
    AND NVL(xrh.attribute5,0)  >0
    AND p_in_par              IS NULL -- added for Hotfix_131260 to fetch the
      -- record once
    AND TO_NUMBER (xrh.irt_ay) >= 2010 --As the TS was introduced from 2010
    AND xrh.irt_schedule_type   = 'IT'
    AND EXISTS
      (SELECT 1
      FROM xx_refd_lines
      WHERE reference_id =xrl.reference_id
      AND minor_head     ='300'
      )
      /* --commented for HF_193932
      AND NOT EXISTS
      (SELECT 1
      FROM xx_refd_lines
      WHERE reference_id=xrl.reference_id
      AND minor_head   IN ('100','200','XCL')
      )*/
      --ADDED FOR HF_193932--START---
    AND (NOT EXISTS
      (SELECT 1
      FROM xx_refd_lines
      WHERE reference_id=xrl.reference_id
      AND minor_head   IN ('100','200','XCL')
      )
    OR NOT EXISTS
      (SELECT 1
      FROM xx_ref_int_lines xril1
      WHERE xril1.irt_id         = xrh.irt_id
      AND XRIL1.INT_244_CALC_AMT > 0
      ) )
      --ADDED FOR HF_193932--END---
    AND NOT EXISTS
      (SELECT 1
      FROM xx_irt_fas_prcsng_hold xifph
      WHERE xifph.irt_id      = xrh.irt_id
      AND xifph.hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
      AND xifph.release_flag IS NULL
      )
    UNION ALL
    ----------- above code added for NRI cases
    SELECT xrh.reference_id reference_id,
      irt_id,
      major_head,
      xrh.refd_identify_amount refd_identify_amount,
      xrh.id_number id_number,
      xrh.refd_status status,
      irt_ay,
      xrl.cash_receipt_id cash_receipt_id,
      irt_schedule_type,
      approval_date,
      xrh.ref_400_int_amt refd_interest_amount,
      excess_receipt_amount
    FROM xx_refd_headers xrh,
      xx_refd_lines xrl
    WHERE xrh.reference_id                 = xrl.reference_id
    AND xrl.minor_head                     = 'IRF4'
    AND xrh.refd_status                 IN ( 'TO PAY IDENTIFIED' ,'PCM APPROVED','APPROVED' ) -- added for Hotfix_131260 to calculate xx for IRF4
    AND NVL (xrh.ref_400_int_amt, 0)      <> 0
    AND NVL (xrh.ref_400_identify_amt, 0) <> 0
    AND TO_NUMBER (xrh.irt_ay)            >= 2010 --As the TS was introduced
      -- from 2010
    AND xrh.irt_schedule_type = 'IT'
    AND xrh.irt_id            = p_in_irt_id
    AND p_in_par              ='P' -- added for Hotfix_131260 to fetch the
      -- record once
    AND NOT EXISTS
      (SELECT 1
      FROM xx_irt_fas_prcsng_hold xifph
      WHERE xifph.irt_id      = xrh.irt_id
      AND xifph.hold_flag    IN('IRT REFD HOLD', 'IRT CLAIM HOLD')
      AND xifph.release_flag IS NULL
      )
      )
    ORDER BY 1;
    l_Customer_typ_cd     NUMBER;
    l_ay_ts_rates        NUMBER;
    l_cnt_chk             NUMBER;
    l_mon_ts_rates       NUMBER;
    l_xx_ded_amt         NUMBER;
    l_batch_seq           NUMBER;
    l_btch_ctrl_id        NUMBER;
    l_ast_ts_rates       NUMBER;
    l_base_tx_rt          NUMBER;
    l_tx_rt_id            NUMBER;
    l_int_amt_tot         NUMBER;
    l_prev_chk            NUMBER;
    l_pr_chk              NUMBER;
    l_amt_for_ded         NUMBER;
    l_num_refd_seq_num  NUMBER:=NULL;
    l_chr_errbuff         VARCHAR2 (5000);
    l_chr_retcode         VARCHAR2 (10);
    l_stmt_processing     VARCHAR2(200);
    l_ts_chk             VARCHAR2 (5);
    l_chr_proc_name       VARCHAR2(50);
    l_chr_exe_location    VARCHAR2 (10);
    l_writeoff_amount     NUMBER;
    l_msg_count           NUMBER;
    l_msg_data            VARCHAR2 (5000):=NULL;
    l_return_status       VARCHAR2 (1);
    p_count               NUMBER;
    l_count               NUMBER;
    l_300_cnt             NUMBER;   --added for Hotfix_131260
    l_amt_for_ded_300     NUMBER;   --added for Hotfix_131260
    l_max_amt_for_ded_300 NUMBER;   --added for Hotfix_131260
    l_ts_chk_300         NUMBER;   --added for Hotfix_131260
    l_ts_max_amt         NUMBER:=0;--added for Hotfix_131260
    l_ts_exits_amt       NUMBER:=0;--added for Hotfix_131260
    l_amt_ts_ded         NUMBER:=0;--added for Hotfix_131260
    l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
    l_application_ref_id ar_receivable_applications.application_ref_id%TYPE;
    l_application_ref_type ar_receivable_applications.application_ref_type%TYPE ;
    l_application_ref_num ar_receivable_applications.application_ref_num%TYPE;
    l_secondary_application_ref_id ar_receivable_applications.secondary_application_ref_id%TYPE;
    l_receivable_application_id ar_receivable_applications.receivable_application_id%TYPE;
    custom_exception EXCEPTION;
    e_skip_calc      EXCEPTION;
  BEGIN
    Write_msg( g_debug_flag , '*** TS DEDUCTION ON REFD INTEREST CALCULATION - STARTS ***');
    l_chr_proc_name    := 'ts_xx_rate';
    p_out_chr_retcode  := g_chr_success_code;
    p_out_chr_errbuff  := '';
    l_chr_exe_location := 'TTR_01';
    l_stmt_processing  := ' Entering TS XX Rate Proc ' ;
    write_debug( g_debug_flag ,l_stmt_processing );
    FOR cur_get_rfnd_details_rec IN cur_get_rfnd_details(p_in_irt_id)
    LOOP
      l_Customer_typ_cd  := 0;
      l_base_tx_rt       := 0;
      l_ay_ts_rates     := 0;
      l_tx_rt_id         := 0;
      l_chr_exe_location := 'TTR_02';
    --  l_stmt_processing  := 'Calling Customer_type_chk function to check if Customer is NON CORP OR CORP ' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      -- Calling xx_Customer_type_chk function to determine whether the
      -- Customer is NON CORP OR CORP
     -- l_Customer_typ_cd := Customer_type_chk (cur_get_rfnd_details_rec.irt_id);        --Commented for ABC-2.0 POc bhagya
      write_debug( g_debug_flag ,l_chr_exe_location ||'- Customer type is '|| l_Customer_typ_cd);
      --- below code added for Hotfix_131260 where minor head is only 300
      l_300_cnt:=0;
      SELECT COUNT(1)
      INTO l_300_cnt
      FROM xx_refd_headers xrh,
        xx_refd_lines xrl,
        ra_customer_trx_all rct,
        ra_cust_trx_types_all rctta
      WHERE xrh.reference_id               = xrl.reference_id
      AND xrl.minor_head                   = 'IRF'
      AND xrh.refd_status                = 'PCM APPROVED'
      AND rct.customer_trx_id              = xrh.customer_trx_id
      AND rctta.cust_trx_type_id           = rct.cust_trx_type_id
      AND rctta.attribute2                IN ('REVISED', 'RECTIFICATION')
      AND xrh.irt_id                       = p_in_irt_id
      AND NVL(to_number(xrh.attribute5),0) >0
      AND p_in_par                        IS NULL -- added for Hotfix_131260 to
        -- fetch the record once
      AND TO_NUMBER (xrh.irt_ay) >= 2010 --As the TS was introduced from 2010
      AND xrh.irt_schedule_type   = 'IT'
      AND EXISTS
        (SELECT 1
        FROM xx_refd_lines
        WHERE reference_id =xrl.reference_id
        AND minor_head     ='300'
        )
        --COMMENTED BELOW FOR HF_193932
        /*AND NOT EXISTS
        (SELECT 1
        FROM xx_refd_lines
        WHERE reference_id=xrl.reference_id
        AND minor_head   IN ('100','200','XCL')
        )*/
        --ADDED FOR HF_193932--START---
      AND (NOT EXISTS
        (SELECT 1
        FROM xx_refd_lines
        WHERE reference_id=xrl.reference_id
        AND minor_head   IN ('100','200','XCL')
        )
      OR NOT EXISTS
        (SELECT 1
        FROM xx_ref_int_lines xril1
        WHERE xril1.irt_id         = xrh.irt_id
        AND XRIL1.INT_244_CALC_AMT > 0
        ) )
        --ADDED FOR HF_193932--END---
      AND NOT EXISTS
        (SELECT 1
        FROM xx_irt_fas_prcsng_hold xifph
        WHERE xifph.irt_id      = xrh.irt_id
        AND xifph.hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
        AND xifph.release_flag IS NULL
        );
      --- above code added for Hotfix_131260 where minor head is only 300
      BEGIN
        -- If Customer is CORP
        IF l_Customer_typ_cd = 2 THEN
          BEGIN
            l_ay_ts_rates     := 0;
            l_cnt_chk          := 0;
            l_ast_ts_rates    := 0;
            l_int_amt_tot      := 0;
            l_prev_chk         := 0;
            l_chr_exe_location := 'TTR_03';
            l_stmt_processing  := 'Retrieving approval_date(Month), approval_date(year) from xx_refd_headers' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );

            --Added for Hotfix_199485 on 13-MAR-2019--START
            SELECT DISTINCT TO_NUMBER (TO_CHAR (irt_approval_date, 'mm')) ,
              TO_NUMBER (TO_CHAR (irt_approval_date, 'YYYY'))
            INTO l_mon_ts_rates ,
              l_ast_ts_rates
            FROM xx_AR_TRANS_STG
            WHERE transaction_number = p_in_irt_id ;
            --Added for Hotfix_199485 on 13-MAR-2019--END
            L_STMT_PROCESSING  := 'No Xx rates available for AY: '|| L_AY_TS_RATES ;
            l_chr_exe_location := 'TTR_05';
            write_debug( g_debug_flag ,l_chr_exe_location);
            IF l_mon_ts_rates     < 4 THEN
              l_ay_ts_rates      := l_ast_ts_rates;
            ELSIF l_mon_ts_rates >= 4 THEN
              l_ay_ts_rates      := l_ast_ts_rates + 1;
            END IF; --IF l_mon_ts_rates < 4
            l_chr_exe_location := 'TTR_06';
            l_stmt_processing  := 'Checking whether prior records exist in refd headers for the (id,irt_id,irt_ay,schedule_type) combination' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            -- Checking whether prior records exist in refd headers
            -- for the (id,irt_id,irt_ay,schedule_type) combination
            l_chr_exe_location := 'TTR_07';
            l_stmt_processing  :=' Getting the refd Seq Number';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            -- Refd Seq Fetch
            --Start of code added in version 2.1
            /*SELECT NVL (refd_seq_no, 6999999999)
            INTO l_num_refd_seq_num
            FROM xx_refd_seq_num; */
            -- Commented as part of Recomendation 3 from ACS
            /*Start of code Added for NRI TS Version 1.1*/
            SELECT num_refd_seq.nextval
            INTO l_num_refd_seq_num
            FROM dual;
            /*End of code Added for NRI TS Version 1.1*/
            SELECT COUNT (1)
            INTO l_prev_chk
            FROM xx_refd_headers
            WHERE id_number      = cur_get_rfnd_details_rec.id_number
            AND irt_ay            = cur_get_rfnd_details_rec.irt_ay
            AND irt_schedule_type = cur_get_rfnd_details_rec.irt_schedule_type;
            BEGIN
              l_chr_exe_location := 'TTR_08';
              l_stmt_processing  := 'Checking whether for prior refds TS has been deducted';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_ts_chk     := NULL;
              l_amt_for_ded := cur_get_rfnd_details_rec.refd_interest_amount;
              -- Checking whether for prior refds TS has been deducted
              SELECT DISTINCT 'Y'
              INTO l_ts_chk
              FROM xx_irf_ts_header xith
              WHERE EXISTS
                (SELECT 1
                FROM xx_ref_int_lines xril
                WHERE xril.prev_ref_id = xith.reference_id
                AND xril.rct_ref_id    =cur_get_rfnd_details_rec.reference_id
                AND xril.prev_ref_id  <> cur_get_rfnd_details_rec.reference_id
                );
            EXCEPTION
            WHEN NO_DATA_FOUND THEN
              l_ts_chk := 'N';
            END;
            IF cur_get_rfnd_details_rec.status IN ('REVISED', 'RECTIFICATION') AND l_prev_chk > 1 AND l_ts_chk = 'Y' THEN
              write_debug( g_debug_flag , 'Revised/Rect which has 100/200/300 and previously xx deducted') ;
              l_chr_exe_location := 'TTR_09';
              l_stmt_processing  := 'Checking if the refd amount is increasing,decreasing or remaining the same' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_pr_chk := 0;
              -- Checking if the refd amount is increasing,decreasing or
              -- remaining the same
              FOR l_rec_chk IN
              (SELECT xril.prev_ref_id prev_ref_id ,
                xril.rct_ref_id rct_ref_id ,
                xril.irt_id ,
                xrh.refd_identify_amount
              FROM xx_ref_int_lines xril,
                xx_refd_headers xrh
              WHERE rct_ref_id     = cur_get_rfnd_details_rec.reference_id
              AND xril.prev_ref_id = xrh.reference_id
              AND prev_ref_id     <> cur_get_rfnd_details_rec.reference_id
              AND reversal_status IS NULL
              ORDER BY xril.seq
              )
              LOOP
                IF cur_get_rfnd_details_rec.refd_identify_amount <= l_rec_chk.refd_identify_amount THEN
                  l_pr_chk                                         := l_pr_chk + 1;
                ELSE
                  l_pr_chk := l_pr_chk;
                END IF;
              END LOOP; -- FOR l_rec_chk
              l_chr_exe_location := 'TTR_10';
              l_stmt_processing  := 'If the refd amount is same or decreasing then skipping TS deduction' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              IF l_pr_chk <> 0 THEN
                RAISE e_skip_calc;
                --- below code added for Hotfix_131260 -- if amount is
                -- increasing then add 300 refd interest amount aslo if
                -- exists
              ELSE
                BEGIN
                  SELECT NVL(to_number(attribute5),0)
                  INTO l_amt_for_ded_300
                  FROM xx_refd_headers
                  WHERE reference_id   =cur_get_rfnd_details_rec.reference_id
                  AND irt_schedule_type='IT' ;
                EXCEPTION
                WHEN no_data_found THEN
                  l_amt_for_ded_300:=0;
                END;
                BEGIN
                  --SELECT MAX(NVL(to_number(attribute5),0))
                  SELECT NVL(MAX(to_number(attribute5)),0) --added for HF_193932
                  INTO l_max_amt_for_ded_300
                  FROM xx_refd_headers
                  WHERE id_number     =cur_get_rfnd_details_rec.id_number
                  AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                  AND reference_id    <>cur_get_rfnd_details_rec.reference_id
                  AND irt_schedule_type='IT' ;
                EXCEPTION
                WHEN no_data_found THEN
                  l_max_amt_for_ded_300:=0;
                END;
                write_debug( g_debug_flag , 'l_amt_for_ded_300='|| l_amt_for_ded_300);
                write_debug( g_debug_flag , 'l_max_amt_for_ded_300='|| l_max_amt_for_ded_300);
                --- added in PT
                BEGIN
                  SELECT NVL(SUM(excess_receipt_amount),0)
                  INTO l_ts_exits_amt
                  FROM xx_refd_lines
                  WHERE reference_id =cur_get_rfnd_details_rec.reference_id
                  AND minor_head    IN ('100','200','XCL') ;
                EXCEPTION
                WHEN OTHERS THEN
                  l_ts_exits_amt:=0;
                END;
                BEGIN
                  SELECT MAX(excess_receipt_amount)
                  INTO l_ts_max_amt
                  FROM
                    (SELECT NVL(SUM(excess_receipt_amount),0) excess_receipt_amount
                    FROM xx_refd_lines
                    WHERE reference_id IN
                      (SELECT reference_id
                      FROM xx_refd_headers
                      WHERE id_number     =cur_get_rfnd_details_rec.id_number
                      AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                      AND reference_id    <> cur_get_rfnd_details_rec.reference_id
                      AND irt_schedule_type='IT'
                      )
                    AND minor_head IN ('100','200','XCL')
                    GROUP BY reference_id
                    ) ;
                EXCEPTION
                WHEN OTHERS THEN
                  l_ts_max_amt:=0;
                END;
                write_debug( g_debug_flag , 'l_ts_exits_amt='||l_ts_exits_amt );
                write_debug( g_debug_flag , 'l_ts_max_amt='||l_ts_max_amt);
                IF (l_ts_exits_amt    >l_ts_max_amt) THEN
                  IF (l_amt_for_ded_300>l_max_amt_for_ded_300) THEN
                    l_amt_for_ded     :=l_amt_for_ded+(l_amt_for_ded_300-
                    l_max_amt_for_ded_300);
                  END IF;
                elsif (l_ts_exits_amt <=l_ts_max_amt) THEN
                  IF (l_amt_for_ded_300 >l_max_amt_for_ded_300) THEN
                    l_amt_for_ded      :=(l_amt_for_ded_300-
                    l_max_amt_for_ded_300);
                  elsif (l_amt_for_ded_300<=l_max_amt_for_ded_300) THEN
                    l_amt_for_ded         :=0;
                  END IF;
                END IF;
              END IF; --l_pr_chk <> 0
            END IF;   -- IF cur_get_rfnd_details_rec.status IN ('REVISED', '
            -- RECTIFICATION') AND l_prev_chk > 1 AND l_ts_chk = 'Y'
            IF cur_get_rfnd_details_rec.status IN ('REVISED', 'RECTIFICATION') AND l_ts_chk = 'N' AND l_300_cnt=0 --added
              -- for Hotfix_131260
              THEN
              write_debug( g_debug_flag , 'Revised/Rect which has only 100,200/300 and no xx deducted');
              l_chr_exe_location   := 'TTR_11';
              l_stmt_processing    := 'Retrieving int_244_calc_amt from xx_ref_int_lines';
              l_amt_for_ded_300    :=0;--- added for Hotfix_131260
              l_max_amt_for_ded_300:=0;---added for Hotfix_131260
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              SELECT NVL(SUM (int_244_calc_amt),0)
              INTO l_amt_for_ded
              FROM xx_ref_int_lines
              WHERE rct_ref_id = cur_get_rfnd_details_rec.reference_id ;
              ---below code added for Hotfix_131260 to include refd interest
              -- amount from 300
              BEGIN
                SELECT NVL(to_number(attribute5),0)
                INTO l_amt_for_ded_300
                FROM xx_refd_headers
                WHERE reference_id   =cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type='IT' ;
              EXCEPTION
              WHEN no_data_found THEN
                l_amt_for_ded_300:=0;
              END;
              BEGIN
                --SELECT MAX(NVL(to_number(attribute5),0))
                SELECT NVL(MAX(to_number(attribute5)),0) --added for HF_193932
                INTO l_max_amt_for_ded_300
                FROM xx_refd_headers
                WHERE id_number     =cur_get_rfnd_details_rec.id_number
                AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                AND reference_id    <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type='IT' ;
              EXCEPTION
              WHEN no_data_found THEN
                l_max_amt_for_ded_300:=0;
              END;
              SELECT COUNT(1)
              INTO l_ts_chk_300
              FROM xx_irf_ts_header
              WHERE reference_id IN
                (SELECT xrl.reference_id
                FROM xx_refd_headers xrh,
                  xx_refd_lines xrl
                WHERE xrh.reference_id =xrl.reference_id
                AND xrh.id_number     =cur_get_rfnd_details_rec.id_number
                AND xrh.irt_ay         =cur_get_rfnd_details_rec.irt_ay
                AND xrh.reference_id  <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type  ='IT'
                AND xrl.minor_head     ='300'
                );
              write_debug( g_debug_flag , 'l_amt_for_ded_300='|| l_amt_for_ded_300);
              write_debug( g_debug_flag , 'l_max_amt_for_ded_300='|| l_max_amt_for_ded_300);
              write_debug( g_debug_flag , 'l_ts_chk_300='||l_ts_chk_300);
              IF l_ts_chk_300       >0 THEN
                IF (l_amt_for_ded_300>l_max_amt_for_ded_300) THEN
                  l_amt_for_ded     :=l_amt_for_ded+(l_amt_for_ded_300-
                  l_max_amt_for_ded_300);
                END IF;
              elsif l_ts_chk_300     =0 THEN
                IF (l_amt_for_ded_300>=l_max_amt_for_ded_300) THEN
                  l_amt_for_ded      :=l_amt_for_ded+l_amt_for_ded_300;
                ELSE
                  l_amt_for_ded:=l_amt_for_ded+l_max_amt_for_ded_300;
                END IF;
              END IF; ---l_ts_chk_300
              --- added for Hotfix_131260
            END IF; --IF cur_get_rfnd_details_rec.status IN ('REVISED', '
            -- RECTIFICATION') AND l_ts_chk = 'N' AND l_300_cnt=0
            -- below code added for Hotfix_131260 to deduct xx which has minor
            -- head only 300
            IF cur_get_rfnd_details_rec.status IN ('REVISED', 'RECTIFICATION') AND l_ts_chk = 'N' AND l_300_cnt>0 THEN
              write_debug( g_debug_flag , 'Revised/Rect which has only 300 and no xx deducted');
              BEGIN
                --SELECT MAX(NVL(to_number(attribute5),0))
                SELECT NVL(MAX(to_number(attribute5)),0) --added for HF_193932
                INTO l_max_amt_for_ded_300
                FROM xx_refd_headers
                WHERE id_number     =cur_get_rfnd_details_rec.id_number
                AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                AND reference_id    <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type='IT' ;
              EXCEPTION
              WHEN no_data_found THEN
                l_max_amt_for_ded_300:=0;
              END;
              SELECT COUNT(1)
              INTO l_ts_chk_300
              FROM xx_irf_ts_header
              WHERE reference_id IN
                (SELECT xrl.reference_id
                FROM xx_refd_headers xrh,
                  xx_refd_lines xrl
                WHERE xrh.reference_id =xrl.reference_id
                AND xrh.id_number     =cur_get_rfnd_details_rec.id_number
                AND xrh.irt_ay         =cur_get_rfnd_details_rec.irt_ay
                AND xrh.reference_id  <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type  ='IT'
                AND xrl.minor_head     ='300'
                );
              SELECT NVL(SUM (int_244_calc_amt),0)
              INTO l_amt_ts_ded
              FROM xx_ref_int_lines
              WHERE rct_ref_id = cur_get_rfnd_details_rec.reference_id ;
              write_debug( g_debug_flag , 'l_amt_for_ded='||l_amt_for_ded);
              write_debug( g_debug_flag , 'l_max_amt_for_ded_300='|| l_max_amt_for_ded_300);
              write_debug( g_debug_flag , 'l_amt_ts_ded='||l_amt_ts_ded);
              IF (l_amt_for_ded    >l_max_amt_for_ded_300) AND l_ts_chk_300=0 THEN
                l_amt_for_ded     :=l_amt_for_ded+l_amt_ts_ded;
              elsif (l_amt_for_ded >l_max_amt_for_ded_300) AND l_ts_chk_300>0 THEN
                l_amt_for_ded     :=(l_amt_for_ded-l_max_amt_for_ded_300)+ l_amt_ts_ded;
              elsif (l_amt_for_ded<=l_max_amt_for_ded_300) AND l_ts_chk_300=0 THEN
                l_amt_for_ded     :=l_max_amt_for_ded_300+l_amt_ts_ded;
              elsif (l_amt_for_ded<=l_max_amt_for_ded_300) AND l_ts_chk_300>0 THEN
                l_amt_for_ded     :=l_amt_ts_ded;
                --RAISE e_skip_calc;
              END IF;
            END IF; --- cur_get_rfnd_details_rec.status IN ('REVISED', '
            -- RECTIFICATION') AND l_ts_chk = 'N' AND l_300_cnt>0
            write_debug( g_debug_flag ,'amount considered for xx='|| l_amt_for_ded);
            IF (l_amt_for_ded<=0) THEN
              RAISE e_skip_calc;
            END IF;
            -- above code added for Hotfix_131260 to deduct xx which has minor
            -- head only 300
            l_chr_exe_location := 'TTR_12';
            l_stmt_processing  := 'Retrieving count of(Customer_type,active_flag,assessment_year) from xx_xx_rate_master' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            SELECT COUNT (1)
            INTO l_cnt_chk
            FROM xx_xx_rate_master
            WHERE Customer_type = 'CO'
            AND active_flag     = 'Y'
            AND assessment_year = l_ay_ts_rates
            ORDER BY xx_calculation_sequence ASC;
            l_chr_exe_location := 'TTR_13';
            L_STMT_PROCESSING  := 'Retrieving xx_rate,xx_rate_id from xx_xx_rate_master';
            WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| L_STMT_PROCESSING );
            SELECT xx_rate,
              xx_rate_id
            INTO l_base_tx_rt,
              l_tx_rt_id
            FROM xx_xx_rate_master
            WHERE Customer_type   = 'CO'
            AND active_flag       = 'Y'
            AND xx_code          = 'BTX'
            AND assessment_year   = l_ay_ts_rates;
            IF l_cnt_chk         <> 0 THEN
              l_chr_exe_location := 'TTR_14';
              l_stmt_processing  := 'Inserting records into xx_IRF_TS_HEADER';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              -- inserting records into xx_IRF_TS_HEADER
              INSERT
              INTO xx_irf_ts_header
                (
                  reference_id ,
                  cash_receipt_id ,
                  irt_id ,
                  schedule_type ,
                  irt_approval_date ,
                  amount_for_deduction ,
                  base_xx_rate ,
                  xx_rate_id ,
                  processing_year ,
                  processing_month ,
                  creation_date ,
                  last_update_date,
                  refd_seq_number --Version 1.1
                )
                VALUES
                (
                  cur_get_rfnd_details_rec.reference_id ,
                  cur_get_rfnd_details_rec.cash_receipt_id ,
                  cur_get_rfnd_details_rec.irt_id ,
                  cur_get_rfnd_details_rec.irt_schedule_type ,
                  cur_get_rfnd_details_rec.approval_date ,
                  l_amt_for_ded ,
                  l_base_tx_rt ,
                  l_tx_rt_id ,
                  l_ast_ts_rates ,
                  l_mon_ts_rates ,
                  SYSDATE ,
                  SYSDATE,
                  l_num_refd_seq_num --Version 1.1
                );
            ELSE
              write_debug ( g_debug_flag ,'No Xx rates available for AY '|| l_ay_ts_rates ) ;
            END IF; --IF l_cnt_chk <> 0
            l_chr_exe_location := 'TTR_15';
            l_stmt_processing  := 'Calling ts_xx_calc_proc procedure to calculate TS deduction';
            write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
            -- Calling ts_xx_calc_proc procedure to calculate TS deduction
            ts_xx_calc_proc ( p_out_chr_errbuff, p_out_chr_retcode, l_ay_ts_rates, cur_get_rfnd_details_rec.reference_id, l_amt_for_ded, cur_get_rfnd_details_rec.cash_receipt_id, 'CO', p_in_irt_id ) ;
          EXCEPTION
          WHEN e_skip_calc THEN
            RAISE e_skip_calc;
          END;
          l_chr_exe_location := 'TTR_16';
          l_stmt_processing  := 'Updating XX Deducted Amount in xx_IRAF_TS_HEADER';
          write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
          -- Updating XX Deducted Amount in xx_IRAF_TS_HEADER
          UPDATE xx_irf_ts_header xith
          SET xith.xx_deducted_amount =
            (SELECT SUM (xitl.amount)
            FROM xx_irf_ts_lines xitl
            WHERE xitl.reference_id  =cur_get_rfnd_details_rec.reference_id
            AND xitl.cash_receipt_id = cur_get_rfnd_details_rec.cash_receipt_id
            )
          WHERE xith.reference_id  =cur_get_rfnd_details_rec.reference_id
          AND xith.cash_receipt_id =cur_get_rfnd_details_rec.cash_receipt_id;
          BEGIN
            l_chr_exe_location := 'TTR_17';
            l_stmt_processing  := 'Retrieving xx_deducted_amount from xx_irf_ts_header';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_xx_ded_amt := 0;
            SELECT xx_deducted_amount
            INTO l_xx_ded_amt
            FROM xx_irf_ts_header
            WHERE cash_receipt_id = cur_get_rfnd_details_rec.cash_receipt_id;
            --Start of code added for Version 1.1
            l_chr_exe_location := 'TTR_18';
            l_stmt_processing  :='Writing off for IRF NRI TS Cases';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_writeoff_amount :=l_xx_ded_amt;
            l_msg_count       := NULL;
            l_return_status   := NULL;
            --l_attribute_rec.attribute2 :=cur_dmd_inv_rec.customer_trx_id;
            l_attribute_rec.attribute4 := 'IRF NRI TS';
            l_attribute_rec.attribute1 := cur_get_rfnd_details_rec.major_head;
            l_attribute_rec.attribute3 :=l_ay_ts_rates;
            l_attribute_rec.attribute5 := l_num_refd_seq_num;
            IF l_writeoff_amount       <> 0 THEN
              l_chr_exe_location       := 'TTR_19';
              l_stmt_processing        := ' Calling the receipt API for write-off For Cash Receipt ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_get_rfnd_details_rec.cash_receipt_id);
              --ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_get_rfnd_details_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_get_rfnd_details_rec.approval_date, p_apply_gl_date => g_dte_sys_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Commented for Hotfix_199485 on 13-MAR-2019
              ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_get_rfnd_details_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_get_rfnd_details_rec.approval_date, p_apply_gl_date => cur_get_rfnd_details_rec.approval_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Added for Hotfix_199485 on 13-MAR-2019
              write_debug( g_debug_flag , 'Apply receipt writeoff for receipt ID '|| cur_get_rfnd_details_rec.cash_receipt_id || ' for refd adjustment amount '|| l_writeoff_amount|| ' - ' || l_return_status);
              IF l_msg_count = 1 THEN
                write_msg( g_write_logfile ,'l_msg_data '|| RTRIM (LTRIM ( l_msg_data)) );
                p_out_chr_retcode := g_chr_failure_code;
                p_out_chr_errbuff := RTRIM (LTRIM (l_msg_data));
                RAISE custom_exception;
              ELSIF l_msg_count > 1 THEN
                LOOP
                  p_count       := p_count + 1;
                  l_msg_data    := fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false );
                  IF l_msg_data IS NULL THEN
                    EXIT;
                  END IF;
                  write_msg( g_write_logfile ,'API Error Message '|| p_count|| ' ---'|| l_msg_data);
                  p_out_chr_errbuff := p_out_chr_errbuff || '-'||l_msg_data;
                END LOOP;
              END IF;
            END IF;

            IF p_in_par IS NULL THEN
              -- Updating refd tables
              l_chr_exe_location := 'TTR_20';
              l_stmt_processing  := 'Updating attribute2,refd_interest_amount in xx_refd_headers ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET attribute2           = l_amt_for_ded,
                refd_interest_amount = refd_interest_amount - l_xx_ded_amt
              WHERE reference_id       = cur_get_rfnd_details_rec.reference_id ;
              l_chr_exe_location      := 'TTR_21';
              l_stmt_processing       := 'Updating total_refd_amount in xx_refd_headers ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET total_refd_amount = refd_identify_amount + refd_interest_amount
              WHERE reference_id      = cur_get_rfnd_details_rec.reference_id;
              l_chr_exe_location     := 'TTR_22';
              l_stmt_processing      := 'Updating attribute1 and excess_receipt_amount in xx_refd_lines ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_lines
              SET attribute1          = cur_get_rfnd_details_rec.excess_receipt_amount,
                excess_receipt_amount = excess_receipt_amount - l_xx_ded_amt
              WHERE reference_id      =cur_get_rfnd_details_rec.reference_id
              AND cash_receipt_id     = cur_get_rfnd_details_rec.cash_receipt_id;
            ELSIF p_in_par            = 'P' -- IF p_in_par IS NULL
              THEN
              l_chr_exe_location := 'TTR_23';
              l_stmt_processing  := 'Updating attribute3 and ref_400_int_amt in xx_refd_headers ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET attribute3      = l_amt_for_ded,
                ref_400_int_amt   = ref_400_int_amt - l_xx_ded_amt
              WHERE reference_id  = cur_get_rfnd_details_rec.reference_id;
              l_chr_exe_location := 'TTR_24';
              l_stmt_processing  := 'Updating attribute2 and excess_receipt_amount in xx_refd_lines ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_lines
              SET attribute2          = cur_get_rfnd_details_rec.excess_receipt_amount,
                excess_receipt_amount = excess_receipt_amount - l_xx_ded_amt
              WHERE reference_id      = cur_get_rfnd_details_rec.reference_id
              AND cash_receipt_id     = cur_get_rfnd_details_rec.cash_receipt_id;
              l_chr_exe_location     := 'TTR_25';
              l_stmt_processing      := 'Updating total_400_ref_amt in xx_refd_headers ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET total_400_ref_amt = ref_400_identify_amt + ref_400_int_amt
              WHERE reference_id    = cur_get_rfnd_details_rec.reference_id;
              l_chr_exe_location   := 'TTR_26';
              l_stmt_processing    := 'Updating net_refd_amount in xx_refd_headers ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET net_refd_amount = net_refd_amount + total_400_ref_amt
              WHERE reference_id    = cur_get_rfnd_details_rec.reference_id;
            END IF; -- IF p_in_par IS NULL
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_xx_ded_amt := 0;
          END;
          l_batch_seq    := 0;
          l_btch_ctrl_id := 0;
          BEGIN
            BEGIN
              l_chr_exe_location := 'TTR_27';
              l_stmt_processing  := 'Retrieving maximum batch_sequence_nbr from xx_irf_ts_btch_ctrl ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              SELECT MAX (batch_sequence_nbr)
              INTO l_btch_ctrl_id
              FROM xx_irf_ts_btch_ctrl
              WHERE processing_yr  = l_ast_ts_rates
              AND processing_month = l_mon_ts_rates;
              IF l_btch_ctrl_id   IS NULL THEN
                l_btch_ctrl_id    :=0;
              END IF;
            EXCEPTION
            WHEN NO_DATA_FOUND THEN
              l_btch_ctrl_id := 0;
            END;
            write_debug( g_debug_flag ,'l_btch_ctrl_id '||l_btch_ctrl_id );
            l_chr_exe_location := 'TTR_28';
            l_stmt_processing  := 'Retrieving maximum batch_sequence_nbr from xx_irf_ts_btch_ctrl ' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            SELECT MAX (batch_sequence_nbr)
            INTO l_batch_seq
            FROM xx_irf_ts_btch_ctrl
            WHERE processing_yr  = l_ast_ts_rates
            AND processing_month = l_mon_ts_rates
            AND batch_status_cd  = 'O';
            IF l_batch_seq      IS NULL THEN
              l_batch_seq       :=0;
            END IF;
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_batch_seq := 0;
          END;
          write_debug( g_debug_flag ,' l_batch_seq '|| l_batch_seq );
          IF l_batch_seq        > 0 THEN
            l_chr_exe_location := 'TTR_29';
            l_stmt_processing  := 'Updating batch_sequence_number in xx_irf_ts_header ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            -- Updating batch_sequence
            UPDATE xx_irf_ts_header
            SET batch_sequence_number  = l_batch_seq
            WHERE reference_id         = cur_get_rfnd_details_rec.reference_id
            AND batch_sequence_number IS NULL
            AND processing_year        = l_ast_ts_rates
            AND processing_month       = l_mon_ts_rates ;
          ELSIF l_batch_seq            = 0 THEN
            l_btch_ctrl_id            := l_btch_ctrl_id + 1;
            l_chr_exe_location        := 'TTR_30';
            l_stmt_processing         := 'Insert into xx_irf_ts_btch_ctrl table';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            INSERT
            INTO xx_irf_ts_btch_ctrl
              (
                processing_yr ,
                processing_month ,
                batch_sequence_nbr ,
                batch_status_cd,
                mode_of_payment_cd -- Added for Version 1.1
              )
              VALUES
              (
                l_ast_ts_rates ,
                l_mon_ts_rates ,
                l_btch_ctrl_id ,
                'O',
                'R' -- Added for Version 1.1
              );
            l_chr_exe_location := 'TTR_31';
            l_stmt_processing  := 'Updating batch_sequence_number in xx_irf_ts_header ';
            write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
            -- Updating batch_sequence
            UPDATE xx_irf_ts_header
            SET batch_sequence_number  = l_btch_ctrl_id
            WHERE reference_id         = cur_get_rfnd_details_rec.reference_id
            AND batch_sequence_number IS NULL
            AND processing_year        = l_ast_ts_rates
            AND processing_month       = l_mon_ts_rates;
          END IF; -- IF l_batch_seq > 0
          -- If the Customer is NON CORP
        ELSIF l_Customer_typ_cd = 1 OR l_Customer_typ_cd = 3 THEN --added for SR #179493 on 27-APR-2018
          BEGIN
            l_chr_exe_location := 'TTR_30';
            l_stmt_processing  := 'Retrieving approval_date(month) from xx_refd_headers ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_ay_ts_rates  := 0;
            l_cnt_chk       := 0;
            l_ast_ts_rates := 0;
            l_int_amt_tot   := 0;

            --Added for Hotfix_199485 on 13-MAR-2019--START--
            SELECT DISTINCT TO_NUMBER (TO_CHAR (IRT_APPROVAL_DATE, 'mm')) ,
              TO_NUMBER (TO_CHAR (irt_approval_date, 'YYYY'))
            INTO l_mon_ts_rates ,
              l_ast_ts_rates
            FROM xx_AR_TRANS_STG
            WHERE transaction_number = p_in_irt_id;
            --Added for Hotfix_199485 on 13-MAR-2019--END--
            IF l_mon_ts_rates     < 4 THEN
              l_ay_ts_rates      := l_ast_ts_rates;
            ELSIF l_mon_ts_rates >= 4 THEN
              l_ay_ts_rates      := l_ast_ts_rates + 1;
            END IF;
            -- IF l_mon_ts_rates < 4
            l_chr_exe_location := 'TTR_32';
            l_stmt_processing  := 'Check if prior records exist in refd headers for the (id,irt_ay,irt_id,schedule_type) combination' ;
            Write_msg( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing||' l_ast_ts_rates: '||l_ast_ts_rates );
            FND_FILE.PUT_LINE(FND_FILE.LOG,'l_ast_ts_rates: '||l_ast_ts_rates);
            -- Checking whether prior records exist in refd headers for the (
            -- id,irt_ay,schedule_type) combination
            SELECT COUNT (1)
            INTO l_prev_chk
            FROM xx_refd_headers
            WHERE id_number      = cur_get_rfnd_details_rec.id_number
            AND irt_ay            = cur_get_rfnd_details_rec.irt_ay
            AND irt_schedule_type = cur_get_rfnd_details_rec.irt_schedule_type;
            BEGIN
              l_chr_exe_location := 'TTR_33';
              l_stmt_processing  := 'Checking whether for prior refds TS has been deducted ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_ts_chk     := NULL;
              l_amt_for_ded := cur_get_rfnd_details_rec.refd_interest_amount;
              -- Checking whether for prior refds TS has been deducted
              SELECT DISTINCT 'Y'
              INTO l_ts_chk
              FROM xx_irf_ts_header xith
              WHERE EXISTS
                (SELECT 1
                FROM xx_ref_int_lines xril
                WHERE xril.prev_ref_id = xith.reference_id
                AND xril.rct_ref_id    = cur_get_rfnd_details_rec.reference_id
                AND xril.prev_ref_id  <> cur_get_rfnd_details_rec.reference_id
                );
            EXCEPTION
            WHEN NO_DATA_FOUND THEN
              l_ts_chk := 'N';
            END;
            IF ( (cur_get_rfnd_details_rec.status IN ('REVISED', 'RECTIFICATION') ) AND ( l_prev_chk > 1 ) AND ( l_ts_chk = 'Y' ) ) THEN
              write_debug( g_debug_flag , 'Revised/Rect which has 100/200/300 and previously xx deducted') ;
              l_chr_exe_location := 'TTR_34';
              l_stmt_processing  := 'Checking if the refd amount is increasing,decreasing or remaining the same' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_pr_chk := 0;
              -- Checking if the refd amount is increasing,decreasing or
              -- remaining the same
              FOR l_rec_chk IN
              (SELECT xril.prev_ref_id prev_ref_id ,
                xril.rct_ref_id rct_ref_id ,
                xril.irt_id ,
                xrh.refd_identify_amount
              FROM xx_ref_int_lines xril,
                xx_refd_headers xrh
              WHERE rct_ref_id     = cur_get_rfnd_details_rec.reference_id
              AND xril.prev_ref_id = xrh.reference_id
              AND prev_ref_id     <> cur_get_rfnd_details_rec.reference_id
              AND reversal_status IS NULL
              ORDER BY xril.seq
              )
              LOOP
                IF cur_get_rfnd_details_rec.refd_identify_amount <= l_rec_chk.refd_identify_amount THEN
                  l_pr_chk                                         := l_pr_chk + 1;
                ELSE
                  l_pr_chk := l_pr_chk;
                END IF;
              END LOOP; -- FOR l_rec_chk
              l_chr_exe_location := 'TTR_35';
              l_stmt_processing  := 'If the refd amount is same or decreasing then skipping TS deduction' ;
              Write_msg( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              IF l_pr_chk <> 0 THEN
                RAISE e_skip_calc;
                --- below code added for Hotfix_131260 -- if amount is
                -- increasing then add 300 refd interest amount aslo if
                -- exists
              ELSE
                BEGIN
                  SELECT NVL(to_number(attribute5),0)
                  INTO l_amt_for_ded_300
                  FROM xx_refd_headers
                  WHERE reference_id   =cur_get_rfnd_details_rec.reference_id
                  AND irt_schedule_type='IT' ;
                EXCEPTION
                WHEN no_data_found THEN
                  l_amt_for_ded_300:=0;
                END;
                BEGIN
                  --SELECT MAX(NVL(to_number(attribute5),0))
                  SELECT NVL(MAX(to_number(attribute5)),0) --added for HF_193932
                  INTO l_max_amt_for_ded_300
                  FROM xx_refd_headers
                  WHERE id_number     =cur_get_rfnd_details_rec.id_number
                  AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                  AND reference_id    <>cur_get_rfnd_details_rec.reference_id
                  AND irt_schedule_type='IT' ;
                EXCEPTION
                WHEN no_data_found THEN
                  l_max_amt_for_ded_300:=0;
                END;
                write_debug( g_debug_flag , 'l_amt_for_ded_300='|| l_amt_for_ded_300);
                write_debug( g_debug_flag , 'l_max_amt_for_ded_300='|| l_max_amt_for_ded_300);
                --- added in PT
                BEGIN
                  SELECT NVL(SUM(excess_receipt_amount),0)
                  INTO l_ts_exits_amt
                  FROM xx_refd_lines
                  WHERE reference_id =cur_get_rfnd_details_rec.reference_id
                  AND minor_head    IN ('100','200','XCL') ;
                EXCEPTION
                WHEN OTHERS THEN
                  l_ts_exits_amt:=0;
                END;
                BEGIN
                  SELECT MAX(excess_receipt_amount)
                  INTO l_ts_max_amt
                  FROM
                    (SELECT NVL(SUM(excess_receipt_amount),0) excess_receipt_amount
                    FROM xx_refd_lines
                    WHERE reference_id IN
                      (SELECT reference_id
                      FROM xx_refd_headers
                      WHERE id_number     =cur_get_rfnd_details_rec.id_number
                      AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                      AND reference_id    <> cur_get_rfnd_details_rec.reference_id
                      AND irt_schedule_type='IT'
                      )
                    AND minor_head IN ('100','200','XCL')
                    GROUP BY reference_id
                    ) ;
                EXCEPTION
                WHEN OTHERS THEN
                  l_ts_max_amt:=0;
                END;
                write_debug( g_debug_flag , 'l_ts_exits_amt='||l_ts_exits_amt );
                write_debug( g_debug_flag , 'l_ts_max_amt='||l_ts_max_amt);
                IF (l_ts_exits_amt    >l_ts_max_amt) THEN
                  IF (l_amt_for_ded_300>l_max_amt_for_ded_300) THEN
                    l_amt_for_ded     :=l_amt_for_ded+(l_amt_for_ded_300-
                    l_max_amt_for_ded_300);
                  END IF;
                elsif (l_ts_exits_amt <=l_ts_max_amt) THEN
                  IF (l_amt_for_ded_300 >l_max_amt_for_ded_300) THEN
                    l_amt_for_ded      :=(l_amt_for_ded_300-
                    l_max_amt_for_ded_300);
                  elsif (l_amt_for_ded_300<=l_max_amt_for_ded_300) THEN
                    l_amt_for_ded         :=0;
                  END IF;
                END IF;
                --- above code added for Hotfix_131260
              END IF; -- IF l_pr_chk <> 0
            END IF;
            l_chr_exe_location := 'TTR_07';
            l_stmt_processing  :=' Getting the refd Seq Number';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            -- Refd Seq Fetch
            --Start of code added in version 2.1
            /*SELECT NVL (refd_seq_no, 6999999999)
            INTO l_num_refd_seq_num
            FROM xx_refd_seq_num; */
            -- Commented as part of Recomendation 3 from ACS
            /* Start of Code Added for Version 1.1*/
            SELECT num_refd_seq.nextval
            INTO l_num_refd_seq_num
            FROM dual;
            /* End of Code Added for Version 1.1*/
            IF cur_get_rfnd_details_rec.status IN ('REVISED', 'RECTIFICATION') AND l_ts_chk = 'N' AND l_300_cnt=0 --added
              -- for Hotfix_131260
              THEN
              write_debug( g_debug_flag , 'Revised/Rect which has only 100,200,300 and no xx deducted');
              l_chr_exe_location := 'TTR_36';
              l_stmt_processing  := 'Retrieving sum of int_244_calc_amt from xx_ref_int_lines ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_amt_for_ded_300    :=0;--- added for Hotfix_131260
              l_max_amt_for_ded_300:=0;---added for Hotfix_131260
              SELECT NVL(SUM (int_244_calc_amt),0)
              INTO l_amt_for_ded
              FROM xx_ref_int_lines
              WHERE rct_ref_id = cur_get_rfnd_details_rec.reference_id;
              ---below code added for Hotfix_131260 to include refd interest
              -- amount from 300
              BEGIN
                SELECT NVL(to_number(attribute5),0)
                INTO l_amt_for_ded_300
                FROM xx_refd_headers
                WHERE reference_id   =cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type='IT' ;
              EXCEPTION
              WHEN no_data_found THEN
                l_amt_for_ded_300:=0;
              END;
              BEGIN
                --SELECT MAX(NVL(to_number(attribute5),0))
                SELECT NVL(MAX(to_number(attribute5)),0) --added for HF_193932
                INTO l_max_amt_for_ded_300
                FROM xx_refd_headers
                WHERE id_number     =cur_get_rfnd_details_rec.id_number
                AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                AND reference_id    <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type='IT' ;
              EXCEPTION
              WHEN no_data_found THEN
                l_max_amt_for_ded_300:=0;
              END;
              SELECT COUNT(1)
              INTO l_ts_chk_300
              FROM xx_irf_ts_header
              WHERE reference_id IN
                (SELECT xrl.reference_id
                FROM xx_refd_headers xrh,
                  xx_refd_lines xrl
                WHERE xrh.reference_id =xrl.reference_id
                AND xrh.id_number     =cur_get_rfnd_details_rec.id_number
                AND xrh.irt_ay         =cur_get_rfnd_details_rec.irt_ay
                AND xrh.reference_id  <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type  ='IT'
                AND xrl.minor_head     ='300'
                );
              write_debug( g_debug_flag , 'l_amt_for_ded_300='|| l_amt_for_ded_300);
              write_debug( g_debug_flag , 'l_max_amt_for_ded_300='|| l_max_amt_for_ded_300);
              write_debug( g_debug_flag , 'l_ts_chk_300='||l_ts_chk_300);
              IF l_ts_chk_300       >0 THEN
                IF (l_amt_for_ded_300>l_max_amt_for_ded_300) THEN
                  l_amt_for_ded     :=l_amt_for_ded+(l_amt_for_ded_300-
                  l_max_amt_for_ded_300);
                END IF;
              elsif l_ts_chk_300     =0 THEN
                IF (l_amt_for_ded_300>=l_max_amt_for_ded_300) THEN
                  l_amt_for_ded      :=l_amt_for_ded+l_amt_for_ded_300;
                ELSE
                  l_amt_for_ded:=l_amt_for_ded+l_max_amt_for_ded_300;
                END IF;
              END IF; ---l_ts_chk_300
              --- added for Hotfix_131260
            END IF; -- IF cur_get_rfnd_details_rec.status IN ('REVISED', '
            -- RECTIFICATION') AND l_ts_chk = 'N'
            -- below code added for Hotfix_131260 to deduct xx which has minor
            -- head only 300
            IF cur_get_rfnd_details_rec.status IN ('REVISED', 'RECTIFICATION') AND l_ts_chk = 'N' AND l_300_cnt>0 THEN
              write_debug( g_debug_flag , 'Revised/Rect which has only 300 and no xx deducted');
              BEGIN
                --SELECT MAX(NVL(to_number(attribute5),0))
                SELECT NVL(MAX(to_number(attribute5)),0) --added for HF_193932
                INTO l_max_amt_for_ded_300
                FROM xx_refd_headers
                WHERE id_number     =cur_get_rfnd_details_rec.id_number
                AND irt_ay           = cur_get_rfnd_details_rec.irt_ay
                AND reference_id    <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type='IT' ;
              EXCEPTION
              WHEN no_data_found THEN
                l_max_amt_for_ded_300:=0;
              END;
              SELECT COUNT(1)
              INTO l_ts_chk_300
              FROM xx_irf_ts_header
              WHERE reference_id IN
                (SELECT xrl.reference_id
                FROM xx_refd_headers xrh,
                  xx_refd_lines xrl
                WHERE xrh.reference_id =xrl.reference_id
                AND xrh.id_number     =cur_get_rfnd_details_rec.id_number
                AND xrh.irt_ay         =cur_get_rfnd_details_rec.irt_ay
                AND xrh.reference_id  <>cur_get_rfnd_details_rec.reference_id
                AND irt_schedule_type  ='IT'
                AND xrl.minor_head     ='300'
                );
              SELECT NVL(SUM (int_244_calc_amt),0)
              INTO l_amt_ts_ded
              FROM xx_ref_int_lines
              WHERE rct_ref_id = cur_get_rfnd_details_rec.reference_id ;
              write_debug( g_debug_flag , 'l_amt_for_ded='||l_amt_for_ded);
              write_debug( g_debug_flag , 'l_max_amt_for_ded_300='|| l_max_amt_for_ded_300);
              write_debug( g_debug_flag , 'l_amt_ts_ded='||l_amt_ts_ded);
              IF (l_amt_for_ded    >l_max_amt_for_ded_300) AND l_ts_chk_300=0 THEN
                l_amt_for_ded     :=l_amt_for_ded+l_amt_ts_ded;
              elsif (l_amt_for_ded >l_max_amt_for_ded_300) AND l_ts_chk_300>0 THEN
                l_amt_for_ded     :=(l_amt_for_ded-l_max_amt_for_ded_300)+ l_amt_ts_ded;
              elsif (l_amt_for_ded<=l_max_amt_for_ded_300) AND l_ts_chk_300=0 THEN
                l_amt_for_ded     :=l_max_amt_for_ded_300+l_amt_ts_ded;
              elsif (l_amt_for_ded<=l_max_amt_for_ded_300) AND l_ts_chk_300>0 THEN
                l_amt_for_ded     :=l_amt_ts_ded;
                --RAISE e_skip_calc;
              END IF;
            END IF; --- cur_get_rfnd_details_rec.status IN ('REVISED', '
            -- RECTIFICATION') AND l_ts_chk = 'N' AND l_300_cnt>0
            write_debug( g_debug_flag ,'amount considered for xx='|| l_amt_for_ded);
            IF (l_amt_for_ded<=0) THEN
              RAISE e_skip_calc;
            END IF;
            -- above code added for Hotfix_131260 to deduct xx which has minor
            -- head only 300
            l_chr_exe_location := 'TTR_37';
            l_stmt_processing  := 'Retrieving count of (Customer_type,active_flag,assessment_year) from xx_xx_rate_master ' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            SELECT COUNT (1)
            INTO l_cnt_chk
            FROM xx_xx_rate_master
            WHERE Customer_type = 'NC'
            AND active_flag     = 'Y'
            AND assessment_year = l_ay_ts_rates
            ORDER BY xx_calculation_sequence ASC;
            fnd_file.put_line(fnd_file.log,'l_cnt_chk: '||l_cnt_chk||' l_ay_ts_rates: '||l_ay_ts_rates);
            l_chr_exe_location := 'TTR_38';
            l_stmt_processing  := 'Retrieving xx_rate,xx_rate_id from xx_xx_rate_master ';
            WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| L_STMT_PROCESSING );
            IF(L_Customer_TYP_CD = 1) THEN --added for SR_179493 on 11-May-2018
              SELECT xx_rate,
                xx_rate_id
              INTO l_base_tx_rt,
                l_tx_rt_id
              FROM xx_xx_rate_master
              WHERE Customer_type     = 'NC'
              AND active_flag         = 'Y'
              AND xx_code            = 'BTX'
              AND ASSESSMENT_YEAR     = L_AY_TS_RATES
              AND Customer_DESCRIPTION='Individual/HUF/AOP/BOI';
            ELSIF(L_Customer_TYP_CD   = 3) THEN
              SELECT xx_rate,
                xx_rate_id
              INTO l_base_tx_rt,
                l_tx_rt_id
              FROM xx_xx_rate_master
              WHERE Customer_type     = 'NC'
              AND active_flag         = 'Y'
              AND xx_code            = 'BTX'
              AND ASSESSMENT_YEAR     = L_AY_TS_RATES
              AND Customer_DESCRIPTION='Other than Individual/HUF/AOP/BOI';
            END IF;
            IF l_cnt_chk         <> 0 THEN
              l_chr_exe_location := 'TTR_39';
              l_stmt_processing  := 'Inserting records into xx_IRF_TS_HEADER';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              INSERT
              INTO xx_irf_ts_header
                (
                  reference_id ,
                  cash_receipt_id ,
                  irt_id ,
                  schedule_type ,
                  irt_approval_date ,
                  amount_for_deduction ,
                  base_xx_rate ,
                  xx_rate_id ,
                  processing_year ,
                  processing_month ,
                  creation_date ,
                  last_update_date,
                  refd_seq_number --Added for version 1.1
                )
                VALUES
                (
                  cur_get_rfnd_details_rec.reference_id ,
                  cur_get_rfnd_details_rec.cash_receipt_id ,
                  cur_get_rfnd_details_rec.irt_id ,
                  cur_get_rfnd_details_rec.irt_schedule_type ,
                  cur_get_rfnd_details_rec.approval_date ,
                  l_amt_for_ded ,
                  l_base_tx_rt ,
                  l_tx_rt_id ,
                  l_ast_ts_rates ,
                  l_mon_ts_rates ,
                  SYSDATE ,
                  SYSDATE,
                  l_num_refd_seq_num --Added for version 1.1
                );
            ELSE
              write_debug ( g_debug_flag ,'No Xx rates available for AY '|| l_ay_ts_rates ) ;
            END IF; -- IF l_cnt_chk <> 0
            l_chr_exe_location := 'TTR_40';
            l_stmt_processing  := 'Calling ts_xx_calc_proc procedure to calculate TS deduction';
            write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
            -- Calling ts_xx_calc_proc procedure to calculate TS deduction
            --added for SR #179493 on 27-APR-2018 --Start
            IF ( l_Customer_typ_cd = 1 ) THEN
              ts_xx_calc_proc ( p_out_chr_errbuff, p_out_chr_retcode, l_ay_ts_rates, cur_get_rfnd_details_rec.reference_id, l_amt_for_ded, cur_get_rfnd_details_rec.cash_receipt_id, 'NC', p_in_irt_id, 'Individual/HUF/AOP/BOI' ) ;
            END IF;
            IF ( l_Customer_typ_cd = 3 ) THEN
              ts_xx_calc_proc ( p_out_chr_errbuff, p_out_chr_retcode, l_ay_ts_rates, cur_get_rfnd_details_rec.reference_id, l_amt_for_ded, cur_get_rfnd_details_rec.cash_receipt_id, 'NC',p_in_irt_id, 'Other than Individual/HUF/AOP/BOI' ) ;
            END IF;
            --added for SR #179493 on 27-APR-2018 --End
          EXCEPTION
          WHEN e_skip_calc THEN
            RAISE e_skip_calc;
          WHEN OTHERS THEN
            l_chr_exe_location := 'TTR_40E';
            p_out_chr_errbuff  := 'EXCEPTION No Xx rates available for AY: '|| l_ay_ts_rates|| SQLERRM;
            RAISE custom_exception;
          END;
          l_chr_exe_location := 'TTR_41';
          l_stmt_processing  := 'Updating xx_deducted_amount in xx_irf_ts_header';
          write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
          UPDATE xx_irf_ts_header xith
          SET xith.xx_deducted_amount =
            (SELECT SUM (xitl.amount)
            FROM xx_irf_ts_lines xitl
            WHERE xitl.reference_id  = cur_get_rfnd_details_rec.reference_id
            AND xitl.cash_receipt_id = cur_get_rfnd_details_rec.cash_receipt_id
            )
          WHERE xith.reference_id  = cur_get_rfnd_details_rec.reference_id
          AND xith.cash_receipt_id = cur_get_rfnd_details_rec.cash_receipt_id;
          BEGIN
            /*Start of code Added for version 1.1*/
            l_chr_exe_location := 'TTR_42';
            l_stmt_processing  := 'Retrieving xx_deducted_amount from xx_irf_ts_header';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_xx_ded_amt := 0;
            SELECT xx_deducted_amount
            INTO l_xx_ded_amt
            FROM xx_irf_ts_header
            WHERE reference_id  = cur_get_rfnd_details_rec.reference_id
            AND cash_receipt_id = cur_get_rfnd_details_rec.cash_receipt_id; --
            -- ADDED ON 26FEB13 to fix for TS deduction on 400
            l_chr_exe_location := 'TTR_43';
            l_stmt_processing  :='Writing off for IRF NRI TS Cases';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_writeoff_amount :=l_xx_ded_amt;
            l_msg_count       := NULL;
            l_return_status   := NULL;
            --l_attribute_rec.attribute2 :=cur_dmd_inv_rec.customer_trx_id;
            l_attribute_rec.attribute4 := 'IRF NRI TS';
            l_attribute_rec.attribute1 := cur_get_rfnd_details_rec.major_head;
            l_attribute_rec.attribute3 :=l_ay_ts_rates;
            l_attribute_rec.attribute5 := l_num_refd_seq_num;
            IF l_writeoff_amount       <> 0 THEN
              l_chr_exe_location       := 'TTR_19';
              l_stmt_processing        := ' Calling the receipt API for write-off For Cash Receipt ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_get_rfnd_details_rec.cash_receipt_id);
              --ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_get_rfnd_details_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_get_rfnd_details_rec.approval_date, p_apply_gl_date => g_dte_sys_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Commented for Hotfix_199485 on 13-MAR-2019
              ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_get_rfnd_details_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_get_rfnd_details_rec.approval_date, p_apply_gl_date => cur_get_rfnd_details_rec.approval_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Added for Hotfix_199485 on 13-MAR-2019
              write_debug( g_debug_flag , 'Apply receipt writeoff for receipt ID '|| cur_get_rfnd_details_rec.cash_receipt_id || ' for refd adjustment amount '|| l_writeoff_amount|| ' - ' || l_return_status);
              IF l_msg_count = 1 THEN
                write_msg( g_write_logfile ,'l_msg_data '|| RTRIM (LTRIM ( l_msg_data)) );
                p_out_chr_retcode := g_chr_failure_code;
                p_out_chr_errbuff := RTRIM (LTRIM (l_msg_data));
                RAISE custom_exception;
              ELSIF l_msg_count > 1 THEN
                LOOP
                  p_count       := p_count + 1;
                  l_msg_data    := fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false );
                  IF l_msg_data IS NULL THEN
                    EXIT;
                  END IF;
                  write_msg( g_write_logfile ,'API Error Message '|| p_count|| ' ---'|| l_msg_data);
                  p_out_chr_errbuff := p_out_chr_errbuff || '-'||l_msg_data;
                END LOOP;
              END IF;
            END IF;
            /*End of code Added for version 1.1*/
            -- Writing off for IRF NRI TS Cases
            /* writeoff_proc
            (p_out_chr_errbuff => l_chr_errbuff,
            p_out_chr_retcode => l_chr_retcode,
            in_num_cash_receipt_id => cur_get_rfnd_details_rec.cash_receipt_id,
            in_num_writeoff_amount => l_xx_ded_amt,
            in_chr_appl_flag => 'IRF NRI TS',
            in_chr_major_head => cur_get_rfnd_details_rec.major_head,
            in_chr_assmt_year => l_ay_ts_rates,
            in_dte_apply_date => cur_get_rfnd_details_rec.approval_date,
            p_in_irt_id => p_in_irt_id
            );
            IF l_chr_retcode <> '0'
            THEN
            write_debug( g_debug_flag ,'Error in Writeoff for NRI TS ' || '-'|
            | l_chr_errbuff || ' _ '|| SQLERRM);
            RAISE custom_exception;
            END IF; -- IF l_chr_retcode <> '0'*/
            IF p_in_par          IS NULL THEN
              l_chr_exe_location := 'TTR_44';
              l_stmt_processing  := 'Updating attribute2,refd_interest_amount in xx_refd_headers ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              --Updating refd tables
              UPDATE xx_refd_headers
              SET attribute2           = l_amt_for_ded,
                refd_interest_amount = refd_interest_amount - l_xx_ded_amt
              WHERE reference_id       = cur_get_rfnd_details_rec.reference_id;
              l_chr_exe_location      := 'TTR_45';
              l_stmt_processing       := 'Updating attribute1 and excess_receipt_amount in xx_refd_lines ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_lines
              SET attribute1          =cur_get_rfnd_details_rec.excess_receipt_amount,
                excess_receipt_amount = excess_receipt_amount - l_xx_ded_amt
              WHERE reference_id      = cur_get_rfnd_details_rec.reference_id
              AND cash_receipt_id     = cur_get_rfnd_details_rec.cash_receipt_id;
              l_chr_exe_location     := 'TTR_46';
              l_stmt_processing      := 'Updating total_refd_amount in xx_refd_headers ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET total_refd_amount = refd_identify_amount + refd_interest_amount
              WHERE reference_id      = cur_get_rfnd_details_rec.reference_id;
            ELSIF p_in_par            = 'P' THEN
              l_chr_exe_location     := 'TTR_47';
              l_stmt_processing      := 'Updating attribute3 and ref_400_int_amt in xx_refd_headers ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              --Updating refd tables
              UPDATE xx_refd_headers
              SET attribute3      = l_amt_for_ded,
                ref_400_int_amt   =ref_400_int_amt - l_xx_ded_amt
              WHERE reference_id  = cur_get_rfnd_details_rec.reference_id;
              l_chr_exe_location := 'TTR_48';
              l_stmt_processing  := 'Updating attribute2 and excess_receipt_amount in xx_refd_lines ' ;
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_lines
              SET attribute2          = cur_get_rfnd_details_rec.excess_receipt_amount,
                excess_receipt_amount = excess_receipt_amount - l_xx_ded_amt
              WHERE reference_id      =cur_get_rfnd_details_rec.reference_id
              AND cash_receipt_id     = cur_get_rfnd_details_rec.cash_receipt_id;
              l_chr_exe_location     := 'TTR_49';
              l_stmt_processing      := 'Updating total_400_ref_amt in xx_refd_headers ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET total_400_ref_amt = ref_400_identify_amt + ref_400_int_amt
              WHERE reference_id    = cur_get_rfnd_details_rec.reference_id;
              l_chr_exe_location   := 'TTR_50';
              l_stmt_processing    := 'Updating net_refd_amount in xx_refd_headers ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              UPDATE xx_refd_headers
              SET net_refd_amount = net_refd_amount + total_400_ref_amt
              WHERE reference_id    = cur_get_rfnd_details_rec.reference_id;
            END IF; -- IF p_in_par IS NULL
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_xx_ded_amt := 0;
          WHEN OTHERS THEN
            l_chr_exe_location := 'TTR_50E';
            p_out_chr_errbuff  := 'Error While Writeoff Receipt '|| SQLERRM;
            RAISE custom_exception;
          END;
          l_batch_seq    := 0;
          l_btch_ctrl_id := 0;
          BEGIN
            BEGIN
              l_chr_exe_location := 'TTR_51';
              l_stmt_processing  := 'Updating max batch_sequence_nbr in xx_irf_ts_btch_ctrl ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              SELECT MAX (batch_sequence_nbr)
              INTO l_btch_ctrl_id
              FROM xx_irf_ts_btch_ctrl
              WHERE processing_yr  = l_ast_ts_rates
              AND processing_month = l_mon_ts_rates;
              IF l_btch_ctrl_id   IS NULL THEN
                l_btch_ctrl_id    :=0;
              END IF;
            EXCEPTION
            WHEN NO_DATA_FOUND THEN
              l_btch_ctrl_id := 0;
            WHEN OTHERS THEN
              l_chr_exe_location := 'TTR_51E';
              p_out_chr_errbuff  := 'Error While fetching max batch_sequence ' || SQLERRM;
              RAISE custom_exception;
            END;
            write_debug( g_debug_flag ,' l_btch_ctrl_id '|| l_btch_ctrl_id|| SQLERRM);
            l_chr_exe_location := 'TTR_52';
            l_stmt_processing  := 'Updating max batch_sequence_nbr in xx_irf_ts_btch_ctrl ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            SELECT MAX (batch_sequence_nbr)
            INTO l_batch_seq
            FROM xx_irf_ts_btch_ctrl
            WHERE processing_yr  = l_ast_ts_rates
            AND processing_month = l_mon_ts_rates
            AND batch_status_cd  = 'O';
            IF l_batch_seq      IS NULL THEN
              l_batch_seq       :=0;
            END IF;
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_batch_seq := 0;
          END;
          write_debug( g_debug_flag ,' l_batch_seq '|| l_batch_seq|| SQLERRM );
          IF l_batch_seq        > 0 THEN
            l_chr_exe_location := 'TTR_53';
            l_stmt_processing  := 'Updating batch_sequence_number in xx_irf_ts_header ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            --updating batch_sequence in updating batch_sequence
            UPDATE xx_irf_ts_header
            SET batch_sequence_number  = l_batch_seq
            WHERE reference_id         = cur_get_rfnd_details_rec.reference_id
            AND batch_sequence_number IS NULL
            AND processing_year        = l_ast_ts_rates
            AND processing_month       = l_mon_ts_rates;
          ELSIF l_batch_seq            = 0 -- IF l_batch_seq > 0
            THEN
            l_btch_ctrl_id     := l_btch_ctrl_id + 1;
            l_chr_exe_location := 'TTR_54';
            l_stmt_processing  :='Inserting into xx_irf_ts_btch_ctrl';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            INSERT
            INTO xx_irf_ts_btch_ctrl
              (
                processing_yr ,
                processing_month ,
                batch_sequence_nbr ,
                batch_status_cd,
                mode_of_payment_cd -- Added for version 1.1
              )
              VALUES
              (
                l_ast_ts_rates ,
                l_mon_ts_rates ,
                l_btch_ctrl_id ,
                'O',
                'R' -- Added for version 1.1
              );
            l_chr_exe_location := 'TTR_55';
            l_stmt_processing  := 'updating batch_sequence in xx_irf_ts_header ';
            write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
            -- updating batch_sequence
            UPDATE xx_irf_ts_header
            SET batch_sequence_number  = l_btch_ctrl_id
            WHERE reference_id         = cur_get_rfnd_details_rec.reference_id
            AND batch_sequence_number IS NULL
            AND processing_year        = l_ast_ts_rates
            AND processing_month       = l_mon_ts_rates;
          END IF; -- IF l_batch_seq > 0
        END IF;   --IF l_Customer_typ_cd = 2
      EXCEPTION
      WHEN e_skip_calc THEN
        NULL;
        write_debug( g_debug_flag , 'NO TS DEDUCTION');
      END;
    END LOOP; --FOR cur_get_rfnd_details_rec IN cur_get_rfnd_details(
    -- p_in_irt_id)
    write_debug( g_debug_flag , '*** TS DEDUCTION ON REFD INTEREST CALCULATION - ENDS ***');
  EXCEPTION
  WHEN custom_exception THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || p_out_chr_errbuff ;
    write_msg( g_write_logfile ,p_out_chr_errbuff);
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name);
      END IF;
    END IF;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255) ;
    write_debug( g_debug_flag ,'No Xx rates available for AY: ' || l_ay_ts_rates|| SQLERRM );
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name);
      END IF;
    END IF;
  END ts_xx_rate;
  --************************************* End of Procedure / Function *********
  -- ****************************
  --ADDED AS A PART AO PORTAL CONFIRMED DMDS - ADDED BY RAJESH - 17-DEC-2014
  -- STARTS HERE
  PROCEDURE refd_adjust_proc_ao(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      p_in_id_number IN VARCHAR2,
      p_in_irt_id     IN VARCHAR2,
      p_in_rrd_call   IN VARCHAR2 DEFAULT NULL --added for CR_HWSW_102
    )
  AS
    /****************************************************************************
    **************
    * TYPE                : PROCEDURE
    * NAME                : REFD_ADJUST_PROC_AO
    * INPUT PARAMETERS    : P_IN_ID_NUMBER, P_IN_IRT_ID
    * OUTPUT PARAMETERS   : OUT_CHR_ERRBUFF
    *                       OUT_CHR_RETCODE
    * PURPOSE             : PROCEDURE TO APPLY IDENTIFIED RECEIPTS TO PRIOR
    ASSMET YEAR DMDS
    WHICH IS CONFIRMED BY AO
    *
    * COMIDY             : INFOSYS TECHNOLOGIES LTD.
    * CREATED BY          : INFOSYS
    * CREATED DATE        : 17-DEC-2014
    * LAST REVIEWED BY    :
    * LAST REVIEWED DATE  :
    *****************************************************************************
    **********
    * MODIFIED DATE  MODIFIED BY  VERSION    MODIFICATION TYPE MODIFICATION
    DETAILS
    * -------------  ------------ -------- - -----------------
    --------------------------
    * 17-DEC-2014    INFOSYS      1.0        O                 BASELINE.
    *****************************************************************************
    *********/
    -- User defined exception for Commit with Warning
    l_exc_exit_error_proc      EXCEPTION;
    e_skip_dmd              EXCEPTION;
    e_skip_subsequent_adj      EXCEPTION;   --added for CR_HWSW_102
    v_400_rrd                  VARCHAR2(1); --added for CR_HWSW_102
    l_chr_proc_name            VARCHAR2(50) :='REFD_ADJUST_PROC_AO';
    l_chr_exe_location         VARCHAR2(50) :='';
    l_stmt_processing          VARCHAR2(250);
    l_out_chr_retcode          VARCHAR2(50)  :='';
    l_out_chr_errbuff          VARCHAR2(2500):='';
    l_msg_count                NUMBER;
    l_num_refd_seq_num       NUMBER;
    l_apply_amount             NUMBER;
    l_inv_amount               NUMBER;
    l_num_int_apply_amt        NUMBER := 0;
    l_inv_refd_adjust_amount NUMBER;
    l_amount               NUMBER;
    l_interest_calc_amt        NUMBER;
    l_total_adjust_amt         NUMBER;
    l_total_adjapp_amt         NUMBER;
    l_inv_amt_due_remaining    NUMBER := 0;
    l_num_avl_ref_adj_amt      NUMBER := 0;
    l_num_refd_exists        NUMBER := 0;
    l_num_int_computed         NUMBER := 0;
    no_int_calc                NUMBER := 0;--added for CR_HWSW_0785 on 04-Apr-2019
    l_orig_cust_trx_id         NUMBER ;       --added for CR_HWSW_785 on 04-Apr-2019
    l_orig_irt_id              VARCHAR2(150); --added for CR_HWSW_785 on 04-Apr-2019
    l_dem_int_sts              VARCHAR2(150); --added for CR_HWSW_785 on 04-Apr-2019
    p_count                    NUMBER;
    l_count                    NUMBER;
    l_calc_state_cd            NUMBER;
    l_calc_status              NUMBER;
    l_month_diff               NUMBER;
    l_inv_amt_remaining        NUMBER;
    l_adjust_amount            NUMBER;
    l_writeoff_amount          NUMBER;
    l_num_odd_exists           NUMBER := 0;
    l_num_count                NUMBER := 0;
    g_exec_location            NUMBER;
    l_num_final_odd_amt1       NUMBER := 0;
    l_num_temp_amt1            NUMBER := 0;
    l_curr_overdue_amt         NUMBER := 0;
    l_calc_dmd_serv_date    DATE;
    l_dmd_serv_date         DATE;
    l_max_to_month             DATE;
    l_final_dem_due_date1      DATE := NULL;
    l_calc_dmd_due_date     DATE;
    l_msg_data                 VARCHAR2 (5000);
    l_num_ref_maj_head         VARCHAR2 (50) := NULL;
    l_chr_dem_int_status       VARCHAR2 (50) := NULL;
    out_err_msg                VARCHAR2 (2000);
    l_chr_ood_errbuff          VARCHAR2 (500);
    l_chr_ood_retcode          VARCHAR2 (30);
    l_return_status2           VARCHAR2 (1);
    l_return_status            VARCHAR2 (1);
    l_num_int_calc_flag        VARCHAR2 (1);
    l_chr_int_calc             VARCHAR2 (1);
    l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
    l_application_ref_id ar_receivable_applications.application_ref_id%TYPE;
    l_application_ref_type ar_receivable_applications.application_ref_type%TYPE;
    l_application_ref_num ar_receivable_applications.application_ref_num%TYPE;
    l_secondary_application_ref_id ar_receivable_applications.secondary_application_ref_id%TYPE;
    l_receivable_application_id ar_receivable_applications.receivable_application_id%TYPE;
    v_tot_refd_amt   NUMBER;      -- Added for HF_187662 on 03-Oct-2018
    v_avl_dmd_amt   NUMBER;      -- Added for HF_187662 on 03-Oct-2018
    p_relaxaction_flag NUMBER := 0; -- Added for HF_187662 on 03-Oct-2018
    LV_DMD_INT_AMT  xx_dmd_headers.Dmd_Interest_AMount%TYPE; --Added for CR_0761-Refd in Interim Status
    LV_Cal_DMD_INT_AMT  xx_dmd_headers.Dmd_Interest_AMount%TYPE; --Added for CR_0761-Refd in Interim Status
    -- Cursor to Fetch if any earlier /old dmd due which has a refd now

    --CURSOR MODIFIED FOR AO_PORTAL - PREM STARTS HERE
    CURSOR CUR_DMD_INV (P_ID_NUM VARCHAR2)
    IS
      SELECT DMD.CUSTOMER_TRX_ID,
        DMD.TRX_NUMBER,
        DMD.IRT_AY ASSMT_YEAR,
        DMD.ID_NUMBER CUSTOMER_NUMBER,
        DMD.AVL_REFD_ADJUST_AMOUNT AMOUNT_DUE_REMAINING,
        DMD.MAJOR_HEAD,
        DMD.DMD_STATUS STATUS,
        DMD.IRT_SCHEDULE_TYPE SCHEDULE_TYPE,
        DMD.IRT_ID,
        DMD.DMD_SERVICE_DATE DMD_SERV_DATE,
        DMD.AVL_REFD_ADJUST_AMOUNT INV_REFD_ADJUST_AMOUNT,
        DMD.IRT_RETURNS_DUE_DATE IRT_DUE_DATE,
        DMD.CUSTOMER_TRX_DATE TRX_DATE,
        DMD.PAYMENT_SCHEDULE_ID,
        DMD.DMD_INTEREST_STATUS,
        DMD.CUST_TRX_TYPE_NAME,
        HEADER.IRT_AY REFD_IRT_AY,
        DMD.ATTRIBUTE6, -- Added for HF_187662 on 03-Oct-2018
        DMD.ATTRIBUTE9,  -- Added for HF_195331 on 12-Mar-2019
        DMD.DMD_IDENTIFICATION_NUMBER DIN,--Added for CR_761-Refd In Interim Status
        DMD.SEC_CODE --Added for CR_761-Refd In Interim Status
      FROM xx_DMD_HEADERS DMD ,
        xx_REFD_HEADERS HEADER
      WHERE ( ( ( ( DMD_STATUS = 'DMD'
      AND DMD_SERVICE_DATE    IS NOT NULL )
      OR DMD_STATUS            = 'INT DMD' ) ---#CR-644
      AND ( DMD.ATTRIBUTE1 ='Y'
      OR DMD.ATTRIBUTE6   IN ('Y','A','R') )-- added by kala --Modified as a Part of Hotfix#124199 - On 20-Jul-
        -- 2016
        -- AND DMD.ATTRIBUTE2 IS NOT NULL
      AND DMD.AVL_REFD_ADJUST_AMOUNT >100 )
      OR ( DMD_STATUS                 IN ( 'DMD','THRESHOLD DMD','INT DMD') --AND
        -- DMD.ATTRIBUTE1  IS NULL ---#CR-644
      AND dmd.AVL_REFD_ADJUST_AMOUNT <=100 )
        )
      AND DMD.IRT_SCHEDULE_TYPE <> 'FBB' --Added To restrict WTR Dmds on 02
        -- -Sep-2015
        -- AND DMD.AVL_REFD_ADJUST_AMOUNT > 0
      AND HEADER.ID_NUMBER = DMD.ID_NUMBER
      AND HEADER.ID_NUMBER = P_ID_NUM
        --AND TO_NUMBER (HEADER.IRT_AY)       > TO_NUMBER (DMD.IRT_AY)--
        -- CHANGED TO ADJUST SUBSEQUENT YEAR DMD TO PRIOR REFD.
      AND HEADER.REFD_STATUS                                                                                                    = 'PCM APPROVED'
      AND HEADER.APPROVAL_DATE                                                                                                   IS NOT NULL
      AND ( NVL (HEADER.TOTAL_REFD_AMOUNT, 0) - NVL ( HEADER.REFD_ADJUSTMENT_AMOUNT, 0) - NVL (HEADER.NET_REFD_AMOUNT, 0) ) > 0
      AND NOT EXISTS
        (SELECT 1
        FROM xx_IRT_FAS_PRCSNG_HOLD XIFPH
        WHERE DMD.IRT_ID     = XIFPH.IRT_ID
        AND XIFPH.HOLD_FLAG    IN('IRT REFD HOLD', 'IRTCLAIM HOLD')
        AND XIFPH.RELEASE_FLAG IS NULL
        )
      ---------Added for Hot fix #77468 start--------
    AND DMD.IRT_AY >1960
    AND DMD.IRT_AY<=
      ( SELECT EXTRACT (YEAR FROM SYSDATE) FROM dual
      )
      ---------Added for Hot fix #77468 end --------
    ORDER BY TO_NUMBER (DMD.IRT_AY),
      TO_NUMBER (DMD.MAJOR_HEAD),
      DMD.ID_NUMBER ASC,
      DMD.IRT_SCHEDULE_TYPE DESC FOR UPDATE;
    --CURSOR MODIFIED FOR AO_PORTAL - PREM ENDS HERE
    -- Cursor fetch the refd details that can be applied for the ID
    CURSOR cur_refd_header (p_in_customer_number IN VARCHAR2)
    IS
      SELECT HEAD.reference_id ,
        HEAD.irt_id ,
        HEAD.id_number customer_number ,
        HEAD.irt_ay assmt_year ,
        HEAD.major_head ,
        ( NVL (HEAD.total_refd_amount, 0) - NVL (HEAD.refd_adjustment_amount, 0) - NVL (HEAD.net_refd_amount, 0)) total_refd_amount ,
        HEAD.approval_date
      FROM xx_refd_headers head
      WHERE HEAD.id_number                                                                                                = p_in_customer_number
      AND HEAD.refd_status                                                                                               = 'PCM APPROVED'
      AND ( NVL (HEAD.total_refd_amount, 0) - NVL (HEAD.refd_adjustment_amount, 0) - NVL (HEAD.net_refd_amount, 0) ) > 0
      AND NOT EXISTS
        (SELECT 1
        FROM xx_irt_fas_prcsng_hold xifph
        WHERE head.irt_id       = xifph.irt_id
        AND xifph.hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
        AND xifph.release_flag IS NULL
        ) --Added in 4.6
    ORDER BY head.reference_id FOR UPDATE;
    -- Cursor fetch the refd line details
    CURSOR cur_refd_line (in_num_reference_id IN NUMBER)
    IS
      SELECT line.reference_id ,
        line.cash_receipt_id ,
        line.receipt_ay ,
        line.receipt_date ,
        ( NVL (line.excess_receipt_amount, 0) - NVL ( line.refd_adjustment_amount, 0) - NVL (line.net_refd_amount, 0) + NVL (line.refd_roundoff_amount, 0) - NVL ( line.refd_crossadjust_amount, 0) - NVL (line.rr_refdemadj_amount, 0) ) amount ,
        line.refd_adjustment_amount ,
        line.net_refd_amount
      FROM xx_REFD_LINES LINE
      WHERE line.reference_id = in_num_reference_id
      ORDER BY line.reference_id,
        line.receipt_date,
        line.cash_receipt_id FOR UPDATE;
  BEGIN -- main program
    p_out_chr_errbuff  := ' ';
    p_out_chr_retcode  := g_chr_success_code;
    l_chr_exe_location := 'RefAdj_AO_001';
    l_stmt_processing  :=' Entering the Refd Adjsutment API';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    write_debug( g_debug_flag , '-----------------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Refd Adjustment AO with Current/Cross Assmt Year - STARTS ***');
    write_debug( g_debug_flag , '-----------------------------------------------------------------------');
    /**************** DEFAULING SERVICE DATE ***************************/
    l_chr_exe_location := 'RefAdj_AO_002';
    l_stmt_processing  :=' Setting the dmd service Date ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_dmd_headers DMD
    SET dmd_service_date = dmd_identified_date + 5
      --last_update_date=g_dte_sys_date -- Added for AO Portal automation prem
    WHERE dmd_service_date IS NULL
    AND dmd_status NOT     IN ('THRESHOLD DMD','INT DMD') ---#CR644
    AND customer_trx_id       IN
      (SELECT DEM1.customer_trx_id
      FROM xx_refd_headers HEADER ,
        xx_dmd_headers dem1
      WHERE HEADER.id_number = p_in_id_number -- added as part of restruct
      AND HEADER.id_number   = DEM1.id_number
        -- AND TO_NUMBER (HEADER.irt_ay) > TO_NUMBER (DEM1.irt_ay)--changed to
        -- adjust subsequent year dmd for refd.
      AND HEADER.refd_status                                                                                                    = 'PCM APPROVED'
      AND HEADER.approval_date                                                                                                   IS NOT NULL
      AND ( NVL (HEADER.total_refd_amount, 0) - NVL ( HEADER.refd_adjustment_amount, 0) - NVL (HEADER.net_refd_amount, 0) ) > 0
      );
    l_chr_exe_location := 'RefAdj_AO_003';
    l_stmt_processing  :=' Getting the refd Seq Number';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- Refd Seq Fetch
    --Start of code added in version 2.1
    /*SELECT NVL (refd_seq_no, 6999999999)
    INTO l_num_refd_seq_num
    FROM xx_refd_seq_num; */
    -- Commented as part of Recomendation 3 from ACS
    SELECT num_refd_seq.nextval
    INTO l_num_refd_seq_num
    FROM dual;
    l_chr_exe_location := 'RefAdj_AO_004';
    l_stmt_processing  :=' opening the main cursor';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    --changes for CR_HWSW_102
    IF p_in_rrd_call IS NULL THEN
      v_400_rrd      := 'N';
      BEGIN
        SELECT 'Y'
        INTO v_400_rrd
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_400_rrd_int xri,
            ra_customer_trx_all rat
          WHERE rat.attribute5    = p_in_id_number
          AND rat.attribute8     IS NOT NULL
          AND rat.attribute9      = 'RR REF DEM'
          AND rat.customer_trx_id = xri.customer_trx_id
          AND XRI.CNV_FLAG        ='Y'--ADDED AS PART OF HOTFIX#140734
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_400_rrd := 'N';
      END;
    END IF;
    FOR cur_dmd_inv_rec IN cur_dmd_inv(p_in_id_number )
    LOOP
      --changes for CR_HWSW_102 (to prevent subsequent year adjustment if RRD
      -- with 400 component exists)
      IF cur_dmd_inv_rec.assmt_year > cur_dmd_inv_rec.refd_irt_ay AND v_400_rrd = 'Y' AND p_in_rrd_call IS NULL THEN
        write_debug( g_debug_flag ,'BEFORE RAISING e_skip_subsequent_adj : ' ||p_in_rrd_call);
        raise e_skip_subsequent_adj;
      END IF;
      -- Added for HF_187662 on 03-Oct-2018 - starts
      write_debug( g_debug_flag ,'Checking for Relaxaction cases: ');
      v_tot_refd_amt :=0 ;
      v_avl_dmd_amt :=0 ;
      BEGIN
        SELECT SUM(NVL(total_refd_amount,0))
        INTO v_tot_refd_amt
        FROM xx_refd_headers
        WHERE id_number = p_in_id_number
        AND irt_id       = p_in_irt_id;
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag ,'Error while fetching total_refd_amount from xx_refd_headers in IRT Acc:'||sqlerrm );
		dbms_output.put_line('Error while fetching total_refd_amount from xx_refd_headers in IRT Acc:'||sqlerrm );
      END;
      write_debug( g_debug_flag ,'v_tot_refd_amt: '||v_tot_refd_amt );
      BEGIN
        SELECT SUM(avl_refd_adjust_amount)
        INTO v_avl_dmd_amt
        FROM xx_dmd_headers
        WHERE id_number             = p_in_id_number
        AND avl_refd_adjust_amount > 0
        AND dmd_status           IN ('DMD','INT DMD','THRESHOLD DMD')
        AND MAJOR_HEAD              <> '0032';
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag ,'Error while fetching avl_refd_adjust_amount from xx_dmd_headers in IRT Acc:'||sqlerrm );
		dbms_output.put_line('Error while fetching avl_refd_adjust_amount from xx_dmd_headers in IRT Acc:'||sqlerrm );
      END;
      write_debug( g_debug_flag ,'v_avl_dmd_amt:'||v_avl_dmd_amt );
      IF ((v_tot_refd_amt>=1 AND v_tot_refd_amt<=5000) OR (v_avl_dmd_amt>=1 AND v_avl_dmd_amt<=5000)) THEN --modified condition for hotfix#165114
        write_debug( g_debug_flag , 'Relaxaction Case: ');
        p_relaxaction_flag := 1;
      END IF;
      --COMMENTED for HF_195331 on 12-Mar-2019
      --IF ((p_relaxaction_flag = 1 AND NVL(cur_dmd_inv_rec.attribute6,'X')='Y') OR (p_relaxaction_flag = 0)) THEN
      IF ((p_relaxaction_flag = 1 AND (NVL(cur_dmd_inv_rec.attribute6,'X')='Y' OR NVL(cur_dmd_inv_rec.status,'X')='THRESHOLD DMD' OR NVL(cur_dmd_inv_rec.ATTRIBUTE9,'X')='THRESHOLD DMD UPDATE')) OR (p_relaxaction_flag = 0)) THEN -- Added for HF_195331 on 12-Mar-2019
        -- Added for HF_187662 on 03-Oct-2018 - ends
        BEGIN
          l_num_refd_exists := 0;
          l_chr_exe_location  := 'RefAdj_AO_005';
          l_stmt_processing   :=' Checking if any refd exists';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          BEGIN
            SELECT DISTINCT 1
            INTO l_num_refd_exists
            FROM xx_refd_headers head
            WHERE head.id_number                                                                                                 =cur_dmd_inv_rec.customer_number
            AND head.refd_status                                                                                                = 'PCM APPROVED'
            AND ( NVL (HEAD.TOTAL_REFD_AMOUNT, 0) - NVL ( head.refd_adjustment_amount, 0) - NVL (head.net_refd_amount, 0) ) > 0;
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            RAISE e_skip_dmd;
          END;
          l_num_ref_maj_head      := NULL;
          l_num_avl_ref_adj_amt   :=cur_dmd_inv_rec.amount_due_remaining;
          l_inv_amt_due_remaining :=cur_dmd_inv_rec.amount_due_remaining;
          write_debug( g_debug_flag ,'************');
          write_debug( g_debug_flag ,' **** ASST YEAR DMD ***** ');
          write_debug( g_debug_flag ,' Invoice Number :'|| cur_dmd_inv_rec.trx_number);
          write_debug( g_debug_flag ,' Invoice Amt :'|| cur_dmd_inv_rec.amount_due_remaining);
          write_debug( g_debug_flag ,' ID Number :'|| cur_dmd_inv_rec.customer_number);
          write_debug( g_debug_flag ,' Assmt Year :'|| cur_dmd_inv_rec.assmt_year);
          write_debug( g_debug_flag ,' Major Head :'|| cur_dmd_inv_rec.major_head);
          l_inv_amount               := cur_dmd_inv_rec.amount_due_remaining;
          l_inv_refd_adjust_amount :=cur_dmd_inv_rec.inv_refd_adjust_amount;
          l_amount               := 0;
          l_chr_dem_int_status       :=cur_dmd_inv_rec.dmd_interest_status;
          l_chr_exe_location         := 'RefAdj_AO_006';
          l_stmt_processing          :=' Getting Id holder state code';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          BEGIN
-------Not commenting out the below as it will be dealt in exception. --Bhagya
            SELECT "pi_address_state_cd"
            INTO l_calc_state_cd
            FROM "efile"."irt_personal_info"@psql_process_fas --@pdcmis.ad.infosys.com
            WHERE TO_CHAR ("irt_id") = cur_dmd_inv_rec.irt_id;
          EXCEPTION
          WHEN OTHERS THEN
            l_calc_state_cd := NULL;
          END;
          IF cur_dmd_inv_rec.status = 'DMD' THEN
            BEGIN
              l_chr_exe_location := 'RefAdj_AO_007';
              l_stmt_processing  :=' Calling the API to get Next working day';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_calc_status       := NULL;
              l_calc_status       :=PKG_COMMON_APIS_V2.get_next_working_day_func ( ( cur_dmd_inv_rec.dmd_serv_date + 30) , l_calc_state_cd , l_calc_dmd_serv_date , out_err_msg );
              IF l_calc_status    <> 0 THEN
                p_out_chr_retcode := g_chr_failure_code;
                p_out_chr_errbuff := out_err_msg;
                write_msg( g_write_logfile , 'Error in Holiday Calendar api for getting next working day '|| out_err_msg);
                RAISE l_exc_exit_error_proc;
              END IF; -- IF l_calc_status <> 0
            EXCEPTION
            WHEN OTHERS THEN
              l_calc_dmd_serv_date := cur_dmd_inv_rec.dmd_serv_date + 30;
            END;
            l_chr_exe_location := 'RefAdj_AO_008';
            l_stmt_processing  :=' Updating the Dmd Due date';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
            -- dmd due date update:
            UPDATE xx_dmd_headers
            SET dmd_due_date = l_calc_dmd_serv_date
            WHERE dmd_status = 'DMD'
            AND customer_trx_id = cur_dmd_inv_rec.customer_trx_id;
          END IF; -- IF cur_dmd_inv_rec.status = 'DMD'
          IF ( cur_dmd_inv_rec.status IN ('DMD', 'THRESHOLD DMD', 'INT DMD') AND cur_dmd_inv_rec.cust_trx_type_name IS NULL) THEN
            ---#CR644
            l_chr_exe_location := 'RefAdj_AO_009';
            l_stmt_processing  := ' Opening the refd Header as status of record is ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing || cur_dmd_inv_rec.status );
			dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing || cur_dmd_inv_rec.status );
            /* REFD SEQ */
            --l_num_refd_seq_num := l_num_refd_seq_num + 1;-- Commented as part
            -- of Recomendation 3 from ACS
            SELECT num_refd_seq.nextval
            INTO l_num_refd_seq_num
            FROM dual;
            --
            -- Excess Identified receipt Start
            --
            FOR cur_refd_header_rec IN cur_refd_header ( cur_dmd_inv_rec.customer_number)
            LOOP
              l_chr_exe_location := 'RefAdj_AO_010';
              l_stmt_processing  :=' In Header Rec';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              l_msg_count                := NULL;
              l_msg_data                 := NULL;
              l_return_status            := NULL;
              l_apply_amount             := NULL;
              l_total_adjust_amt         := NULL;
              l_total_adjapp_amt         := NULL;
              l_dmd_serv_date         := NULL;
              l_inv_amount               := NULL;
              l_inv_refd_adjust_amount := NULL;
              p_count                    := NULL;
              l_count                    := NULL;
              l_month_diff               := 0;
              l_max_to_month             := NULL;
              l_chr_exe_location         := 'RefAdj_AO_011';
              l_stmt_processing          := ' Getting the Interest Calc Amt for Invoice ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
              IF ( cur_dmd_inv_rec.status IN ('DMD', 'THRESHOLD DMD')) THEN --#CR644
                SELECT avl_refd_adjust_amount
                INTO l_interest_calc_amt
                FROM xx_dmd_headers
                WHERE customer_trx_id =cur_dmd_inv_rec.customer_trx_id
                AND dmd_status    IN ('DMD','THRESHOLD DMD') --added on 4th
                AND MAJOR_HEAD       <> '0032';                       --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
                -- may as program errors for duplicate trx id
                EXIT
              WHEN l_interest_calc_amt  = 0;
                IF (l_num_ref_maj_head <> cur_refd_header_rec.major_head) AND l_num_ref_maj_head IS NOT NULL
                  --1st time l_num_ref_maj_head will be null
                  THEN
                  -- l_num_refd_seq_num := l_num_refd_seq_num + 1;-- Commented
                  -- as part of Recomendation 3 from ACS
                  SELECT num_refd_seq.nextval
                  INTO l_num_refd_seq_num
                  FROM dual;
                END IF;
                l_num_ref_maj_head := cur_refd_header_rec.major_head;
                -- Added for sc: whr IT AND FBT refd is there in refd headers
                -- table
                -- , int was getting computed on the whole dmd 2wce
                l_num_int_computed := 0;
                no_int_calc        :=0;
                -- 'if int already computed till int_calc_mnth '
                l_chr_exe_location := 'RefAdj_AO_012';
                l_stmt_processing  := ' Checking if Interested is computed for month ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                BEGIN
                  SELECT DISTINCT 1
                  INTO l_num_int_computed
                  FROM xx_dmd_lines
                  WHERE customer_trx_id =cur_dmd_inv_rec.customer_trx_id
                  AND int_calc_to_month = cur_refd_header_rec.approval_date
                  AND reversal_status  IS NULL;
                  write_debug( g_debug_flag ,'l_num_int_computed: '|| l_num_int_computed );
                EXCEPTION
                WHEN NO_DATA_FOUND THEN
                  NULL;
                END;
                --added for partial dmd adjustment----CR_HWSW_0785 on 04-Apr-2019
                SELECT COUNT(1)
                INTO no_int_calc
                FROM xx_dmd_headers a
                WHERE dmd_status='DMD ON STAY'
                AND EXISTS
                  (SELECT 1
                  FROM xx_dmd_headers b
                  WHERE b.irt_id       = cur_dmd_inv_rec.irt_id
                  AND a.irt_id         = b.irt_id
                  AND b.customer_trx_id= cur_dmd_inv_rec.customer_trx_id
                  AND to_number(b.attribute15) = a.customer_trx_id
                  );
                --added for partial dmd adjustment----CR_HWSW_0785 on 04-Apr-2019
                IF l_num_int_computed = 0 AND no_int_calc = 0 THEN --Added in Ver 4.1
                  l_chr_exe_location := 'RefAdj_AO_013';
                  l_stmt_processing  := ' Interest is not computed for the month so compute ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                  BEGIN
                    -- Added in Ver 20
                    IF cur_dmd_inv_rec.dmd_interest_status ='PROVISIONAL' THEN
                      l_count                                   := 1;
                    ELSE
                      l_count                                   := 0;
                      IF TO_CHAR (l_calc_dmd_serv_date, 'DD') = TO_CHAR(LAST_DAY (l_calc_dmd_serv_date),'DD') THEN
                        l_calc_dmd_serv_date                 :=l_calc_dmd_serv_date + 1;
                      END IF; -- IF TO_CHAR (l_calc_dmd_serv_date, 'DD') =
                    END IF;   -- IF cur_dmd_inv_rec.dmd_interest_status ='
                    -- PROVISIONAL'
                    l_chr_exe_location := 'RefAdj_AO_014';
                    l_stmt_processing  :=' Checking if the status is Provisional ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    IF l_count            = 1 THEN
                      l_chr_exe_location := 'RefAdj_AO_015';
                      l_stmt_processing  := ' Provisional so Computing the Months for interest Computation ' ;
                      write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                      SELECT TO_DATE ( '01-'
                        || TO_CHAR(ADD_MONTHS(MAX (int_calc_to_month),1), 'MON-RRRR') , 'DD-MON-RRRR' )
                      INTO l_max_to_month
                      FROM xx_dmd_lines
                      WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                      AND reversal_status  IS NULL;
                      l_month_diff         := MONTHS_BETWEEN (TO_DATE(TO_CHAR ( cur_refd_header_rec.approval_date, 'MON-YYYY' ) ,'MON-YYYY' ), TO_DATE (TO_CHAR (l_max_to_month, 'MON-YYYY' ), 'MON-YYYY' ) );
                    END IF; -- IF l_count = 1
                  EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                    l_count := 0;
                  WHEN OTHERS THEN
                    l_count := 0;
                  END;
                  l_chr_exe_location := 'RefAdj_AO_016';
                  l_stmt_processing  := ' Checking if interest has to be computed or not ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  IF (cur_dmd_inv_rec.status = 'DMD' AND l_count = 0 AND cur_refd_header_rec.approval_date > (l_calc_dmd_serv_date) ) OR ( cur_dmd_inv_rec.status = 'DMD' AND l_count = 1 AND l_month_diff >= 0 ) THEN
                    l_num_int_calc_flag        := 'Y';
                  ELSE
                    l_num_int_calc_flag := 'N';
                  END IF;
                  write_debug( g_debug_flag ,'l_num_int_calc_flag: '|| l_num_int_calc_flag);
                  IF l_num_int_calc_flag = 'Y' THEN
                    IF l_count           = 1 -- -1
                      THEN
                      l_dmd_serv_date := l_max_to_month;
                    ELSE
                      l_dmd_serv_date := l_calc_dmd_serv_date;
                      --Ver 20
                    END IF;
                    -- 'Error while calculating Int for Original'
                    write_debug( g_debug_flag ,'Refd Approval date: '|| cur_refd_header_rec.approval_date);
                    write_debug( g_debug_flag ,'l_dmd_serv_date: '|| l_dmd_serv_date);
                    write_debug( g_debug_flag ,'l_interest_calc_amt: '|| l_interest_calc_amt);
                    l_chr_exe_location := 'RefAdj_AO_017';
                    l_stmt_processing  := ' Calling the Dmd Interest Calc Procedure ';
					dbms_output.put_line(' Calling the Dmd Interest Calc Procedure ');
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    l_adjust_amount :=dmd_interest_calc ( cur_refd_header_rec.approval_date, l_dmd_serv_date, ( l_interest_calc_amt - MOD (l_interest_calc_amt, 100) ), cur_dmd_inv_rec.assmt_year );
                    write_debug( g_debug_flag , '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++' );
                    write_debug( g_debug_flag ,' Interest (Adjustment) Creation ');
                    write_debug( g_debug_flag ,' -------------------------------- ' );
                    write_debug( g_debug_flag ,' Receipt Approval Date := ' || TO_CHAR(cur_refd_header_rec.approval_date,'DD-MON-YYYY'));
                    write_debug( g_debug_flag ,' Receipt Amount := ' || cur_refd_header_rec.total_refd_amount);
                    write_debug( g_debug_flag ,' Dmd Invoice Amount := '|| l_interest_calc_amt);
                    write_debug( g_debug_flag ,' Interest(Adjustment) Amount:= '|| l_adjust_amount);
                    l_chr_exe_location := 'RefAdj_AO_018';
                    l_stmt_processing  := ' Inserting the interest line to dmd lines table ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    --'Error in Dmd Interest population '
                    INSERT
                    INTO xx_dmd_lines
                      (
                        customer_trx_id,
                        dmd_interest_amount,
                        int_calc_to_month,
                        cash_receipt_id,
                        last_updated_by,
                        last_update_date,
                        last_update_login,
                        created_by,
                        creation_date,
                        irt_id --Added in Ver 4.5
                      )
                      VALUES
                      (
                        cur_dmd_inv_rec.customer_trx_id,
                        l_adjust_amount,
                        cur_refd_header_rec.approval_date,
                        cur_refd_header_rec.reference_id,
                        g_num_user_id,
                        SYSDATE,
                        g_num_login_id,
                        g_num_user_id,
                        SYSDATE,
                        cur_dmd_inv_rec.irt_id
                        --Added in Ver 4.5
                      );
                    l_chr_exe_location := 'RefAdj_AO_019';
                    l_stmt_processing  := ' Updating the Interest computed to dmd headers ';
                    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                    --Added for CR_0761-Refd In Interim Status--START--
                    select NVL(Dmd_Interest_AMount,0)
                    into LV_DMD_INT_AMT
                    from xx_dmd_headers
                    WHERE customer_trx_id                  = cur_dmd_inv_rec.customer_trx_id
                    and irt_id=cur_dmd_inv_rec.irt_id
                    AND NVL (dmd_interest_status,'-1') <> 'FINAL';                
                   --Added for CR_0761-Refd In Interim Status--END--
                    -- 'Error in Dmd Interest status update'
                    UPDATE xx_dmd_headers head
                    SET head.dmd_interest_status ='PROVISIONAL',
                      head.dmd_interest_amount   =
                      (SELECT NVL(SUM(dmd_interest_amount),0)
                      FROM xx_dmd_lines
                      WHERE customer_trx_id =head.customer_trx_id
                      AND reversal_status  IS NULL
                      )
                    WHERE head.customer_trx_id                  = cur_dmd_inv_rec.customer_trx_id
                    AND NVL (head.dmd_interest_status,'-1') <> 'FINAL';
                    --Added for CR_0761-Refd In Interim Status--START--
                      select NVL(Dmd_Interest_AMount,0)
                      into LV_Cal_DMD_INT_AMT
                      from xx_dmd_headers
                      WHERE customer_trx_id                  = cur_dmd_inv_rec.customer_trx_id
                      and irt_id=cur_dmd_inv_rec.irt_id
                      AND NVL (dmd_interest_status,'-1') <> 'FINAL';    

                      LV_DMD_INT_AMT:=LV_Cal_DMD_INT_AMT-LV_DMD_INT_AMT;          
                    --Added for CR_0761-Refd In Interim Status--END--
                  END IF; -- IF l_num_int_calc_flag = 'Y'
                  --Added for CR_785 Partial Dmd Adjustment on 04-Apr-2019
                ELSIF(no_int_calc     >0) THEN
                  l_chr_exe_location := 'RefAdj_AOP_013';
                  l_stmt_processing  := ' Interest computation for Partial Dmd Adjustment ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                  BEGIN
                    -- Added in Ver 20
                    IF cur_dmd_inv_rec.dmd_interest_status ='PROVISIONAL' THEN
                      l_count                                   := 1;
                    ELSE
                      l_count                                   := 0;
                      IF TO_CHAR (l_calc_dmd_serv_date, 'DD') = TO_CHAR(LAST_DAY (l_calc_dmd_serv_date),'DD') THEN
                        l_calc_dmd_serv_date                 :=l_calc_dmd_serv_date + 1;
                      END IF; -- IF TO_CHAR (l_calc_dmd_serv_date, 'DD') =
                    END IF;   -- IF cur_dmd_inv_rec.dmd_interest_status ='PROVISIONAL'
                    l_chr_exe_location := 'RefAdj_AOP_014';
                    l_stmt_processing  :=' Checking if the status is Provisional ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    --Added for CR_785 Partial Dmd Adjustment on 04-Apr-2019
                    IF l_count            = 1 THEN
                      l_chr_exe_location := 'RefAdj_AOP_015';
                      l_stmt_processing  := ' Provisional so Computing the Months for interest Computation ' ;
                      write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                      SELECT TO_DATE ( '01-'
                        || TO_CHAR(ADD_MONTHS(MAX (int_calc_to_month),1), 'MON-RRRR') , 'DD-MON-RRRR' )
                      INTO l_max_to_month
                      FROM xx_dmd_lines
                      WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                      AND reversal_status  IS NULL;
                      l_month_diff         := MONTHS_BETWEEN (TO_DATE(TO_CHAR ( cur_refd_header_rec.approval_date, 'MON-YYYY' ) ,'MON-YYYY' ), TO_DATE (TO_CHAR (l_max_to_month, 'MON-YYYY' ), 'MON-YYYY' ) );
                    END IF; -- IF l_count = 1
                  EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                    l_count := 0;
                  WHEN OTHERS THEN
                    l_count := 0;
                  END;
                  l_chr_exe_location := 'RefAdj_AO_016';
                  l_stmt_processing  := ' Checking if interest has to be computed or not ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  IF (cur_dmd_inv_rec.status = 'DMD' AND l_count = 0 AND cur_refd_header_rec.approval_date > (l_calc_dmd_serv_date) ) OR ( cur_dmd_inv_rec.status = 'DMD' AND l_count = 1 AND l_month_diff >= 0 ) THEN
                    l_num_int_calc_flag        := 'Y';
                  ELSE
                    l_num_int_calc_flag := 'N';
                  END IF;
                  write_debug( g_debug_flag ,'l_num_int_calc_flag: '|| l_num_int_calc_flag);
                  IF l_num_int_calc_flag = 'Y' THEN
                    IF l_count           = 1 -- -1
                      THEN
                      l_dmd_serv_date := l_max_to_month;
                    ELSE
                      l_dmd_serv_date := l_calc_dmd_serv_date;
                      --Ver 20
                    END IF;
                    -- 'Error while calculating Int for Original'
                    write_debug( g_debug_flag ,'Refd Approval date: '|| cur_refd_header_rec.approval_date);
                    write_debug( g_debug_flag ,'l_dmd_serv_date: '|| l_dmd_serv_date);
                    write_debug( g_debug_flag ,'l_interest_calc_amt: '|| l_interest_calc_amt);
                    l_chr_exe_location := 'RefAdj_AOP_017';
                    l_stmt_processing  := ' Calling the Dmd Interest Calc Procedure ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    l_adjust_amount :=dmd_interest_calc ( cur_refd_header_rec.approval_date, l_dmd_serv_date, ( l_interest_calc_amt - MOD (l_interest_calc_amt, 100) ), cur_dmd_inv_rec.assmt_year );
                    write_debug( g_debug_flag , '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++' );
                    write_debug( g_debug_flag ,' Interest (Adjustment) Creation ');
                    write_debug( g_debug_flag ,' -------------------------------- ' );
                    write_debug( g_debug_flag ,' Receipt Approval Date := ' || TO_CHAR(cur_refd_header_rec.approval_date,'DD-MON-YYYY'));
                    write_debug( g_debug_flag ,' Receipt Amount := ' || cur_refd_header_rec.total_refd_amount);
                    write_debug( g_debug_flag ,' Dmd Invoice Amount := '|| l_interest_calc_amt);
                    write_debug( g_debug_flag ,' Interest(Adjustment) Amount:= '|| l_adjust_amount);
                    l_chr_exe_location := 'RefAdj_AOP_018';
                    l_stmt_processing  := ' Inserting the interest line to dmd lines table ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );

                    l_chr_exe_location := 'RefAdj_AOP_019';
                    l_stmt_processing  := ' Updating the Interest computed to dmd headers ';
                    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                    UPDATE xx_dmd_headers head
                    SET head.dmd_interest_status ='PROVISIONAL',
                      head.dmd_interest_amount   =
                      (SELECT NVL(SUM(dmd_interest_amount),0)
                      FROM xx_dmd_lines
                      WHERE customer_trx_id =head.customer_trx_id
                      AND reversal_status  IS NULL
                      )+l_adjust_amount
                    WHERE head.customer_trx_id                  = l_orig_cust_trx_id
                    AND NVL (head.dmd_interest_status,'-1') <> 'FINAL';
                  END IF; -- IF l_num_int_calc_flag = 'Y'
                END IF;
        --Added for CR_785 Partial Dmd Adjustment on 04-Apr-2019
              END IF;    ---#CR644
              /****** INT CALCULATION ENDS **********/
              /****** APPLICATION BEGINS **********/
              --' calling Calling Application Api for Adjustment knockoff '
              l_apply_amount     := NULL;
              l_chr_exe_location := 'RefAdj_AO_020';
              l_stmt_processing  :=' Getting the amount available for adjustment ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              SELECT avl_refd_adjust_amount
              INTO l_inv_amt_remaining
              FROM xx_dmd_headers
              WHERE customer_trx_id =cur_dmd_inv_rec.customer_trx_id
              AND dmd_status    IN ('DMD','THRESHOLD DMD','INT DMD')
              AND MAJOR_HEAD       <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
              -- added on 4th may as program errors for duplicate trx id.; ---
              -- #CR644
              IF l_inv_amt_remaining <= cur_refd_header_rec.total_refd_amount THEN
                l_apply_amount       := l_inv_amt_remaining;
              ELSE
                l_apply_amount := cur_refd_header_rec.total_refd_amount;
              END IF;
              l_chr_exe_location := 'RefAdj_AO_021';
              l_stmt_processing  := ' Updating the refd adj amt in Headers for Ref id ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_refd_header_rec.reference_id );
              -- update xx_Refd_header refd_adjustment_amount
              UPDATE xx_refd_headers head
              SET head.refd_adjustment_amount =NVL (head.refd_adjustment_amount, 0) + l_apply_amount
              WHERE head.reference_id           = cur_refd_header_rec.reference_id;
              l_chr_exe_location               := 'RefAdj_AO_022';
              l_stmt_processing                := ' Updating the avl_refd_adjust_amount in Headers for Invoice id ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_dmd_inv_rec.customer_trx_id);
              --To update the refd adjustment amount with APPly Amount
              UPDATE xx_dmd_headers
              SET avl_refd_adjust_amount =avl_refd_adjust_amount - l_apply_amount ,
                --last_update_date           =g_dte_sys_date -- Added for AO Portal
                -- automation prem
                last_update_date = sysdate --Changed from g_dte_sys_date to sysdate
                -- for CR_HWSW_0340
              WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id;
              /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --START*/
              UPDATE xx_tot_overdue_details
              SET overdue_dem_amt =
                (SELECT avl_refd_adjust_amount
                FROM xx_dmd_headers
                WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                AND dmd_status    IN ('DMD','THRESHOLD DMD','INT DMD')
                  -- added for Hotfix_139914 to fix subquery returns multiple
                  -- rows error ---#CR644
                )
              WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id;
              /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --END*/
              -----Added for CR_761-Refd In Interim Status--START-----
              INSERT
              INTO xxcus.xx_INTERIM_DEM_DTLS
                (
                    IRT_ID, 
                    ID_NUMBER ,
                    IRT_AY ,
                    CUSTOMER_TRX_ID ,
                    DMD_IDENTIFICATION_NUMBER ,
                    ADJUSTED_DMD_AMOUNT ,
                    PROV_INT_DMD_AMT ,
                    DMD_TYPE ,
                    IRT_SCHEDULE_TYPE ,
                    SEC_CODE ,
                    REF_NUM ,
                    REF_IRT_ID ,
                    Program_Name ,
                    REFERENCE_ID ,
                    LAST_UPDATE_DATE 
                )
                VALUES
                (
                  cur_dmd_inv_rec.IRT_ID ,
                  cur_dmd_inv_rec.CUSTOMER_NUMBER ,
                  cur_dmd_inv_rec.ASSMT_YEAR ,
                  cur_dmd_inv_rec.CUSTOMER_TRX_ID ,
                  cur_dmd_inv_rec.DIN,
                  l_apply_amount,
                  LV_DMD_INT_AMT,
                  cur_dmd_inv_rec.STATUS,
                  cur_dmd_inv_rec.SCHEDULE_TYPE ,
                  cur_dmd_inv_rec.SEC_CODE ,
                  l_num_refd_seq_num,                  
                  cur_refd_header_rec.irt_id,
                  'IRT ACCOUNTING',
                  cur_refd_header_rec.reference_id,
                  SYSDATE

                );
                If(sql%ROWCOUNT>0) then
                 dbms_output.put_line('Record is inserted into table xx_INTERIM_DEM_DTLS 104'||sql%ROWCOUNT);
                 FND_FILE.put_line ( FND_FILE.LOG,'Record is inserted into table xx_INTERIM_DEM_DTLS 104'|| sql%ROWCOUNT) ;
                end If;
            -----Added for CR_761-Refd In Interim Status--END-------
              --Refd adjustment writeoff start
              FOR cur_refd_line_rec IN cur_refd_line ( cur_refd_header_rec.reference_id)
              LOOP
                l_chr_exe_location := 'RefAdj_AO_023';
                l_stmt_processing  := ' In the refd Line cursor for calling Write-off';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_dmd_inv_rec.customer_trx_id);
                l_writeoff_amount          := 0;
                l_msg_count                := NULL;
                l_return_status2           := NULL;
                l_attribute_rec.attribute2 :=cur_dmd_inv_rec.customer_trx_id;
                l_attribute_rec.attribute4 := 'REFD ADJUSTMENT';
                l_attribute_rec.attribute1 :=cur_refd_header_rec.major_head;
                l_attribute_rec.attribute3 :=cur_refd_header_rec.assmt_year;
                l_attribute_rec.attribute5 := l_num_refd_seq_num;
                EXIT
              WHEN l_apply_amount    = 0;
                IF l_apply_amount   >= cur_refd_line_rec.amount THEN
                  l_writeoff_amount := cur_refd_line_rec.amount;
                ELSE
                  l_writeoff_amount := l_apply_amount;
                END IF;
                IF l_writeoff_amount <> 0 THEN
                  l_chr_exe_location := 'RefAdj_AO_024';
                  l_stmt_processing  := ' Calling the receipt API for write-off For Cash Receipt ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_refd_line_rec.cash_receipt_id);
                  --ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_refd_line_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_refd_header_rec.approval_date, p_apply_gl_date => g_dte_sys_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id );  --Commented for Hotfix_199485 on 13-MAR-2019
                  ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_refd_line_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_refd_header_rec.approval_date, p_apply_gl_date => cur_refd_header_rec.approval_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Added for Hotfix_199485 on 13-MAR-2019
                  write_debug( g_debug_flag , 'Apply receipt writeoff for receipt ID '|| cur_refd_line_rec.cash_receipt_id || ' for refd adjustment amount '|| l_writeoff_amount|| ' - ' || l_return_status2);
                  IF l_msg_count = 1 THEN
                    write_msg( g_write_logfile ,'l_msg_data '|| RTRIM (LTRIM ( l_msg_data)) );
                    p_out_chr_retcode := g_chr_failure_code;
                    p_out_chr_errbuff := RTRIM (LTRIM (l_msg_data));
                    RAISE l_exc_exit_error_proc;
                  ELSIF l_msg_count > 1 THEN
                    LOOP
                      p_count       := p_count + 1;
                      l_msg_data    := fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false );
                      IF l_msg_data IS NULL THEN
                        EXIT;
                      END IF;
                      write_msg( g_write_logfile ,'API Error Message '|| p_count|| ' ---'|| l_msg_data);
                      p_out_chr_errbuff := p_out_chr_errbuff || '-'||l_msg_data;
                    END LOOP;
                    p_out_chr_retcode := g_chr_failure_code;
                    RAISE l_exc_exit_error_proc;
                  END IF; -- IF l_msg_count = 1
                  l_chr_exe_location := 'RefAdj_AO_025';
                  l_stmt_processing  :=' Updating the Refd_Adjustment_amt ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  UPDATE xx_refd_lines line
                  SET line.refd_adjustment_amount = NVL ( line.refd_adjustment_amount,0) + l_writeoff_amount
                  WHERE line.reference_id           =cur_refd_line_rec.reference_id
                  AND line.cash_receipt_id          = cur_refd_line_rec.cash_receipt_id;
                  l_apply_amount                   :=l_apply_amount - l_writeoff_amount;
                END IF; -- IF l_writeoff_amount <> 0
              END LOOP; --FOR cur_refd_line_rec IN
            END LOOP;   -- FOR cur_refd_header_rec IN --refd header loop
            /**************** RECT REV DMDS ********************************/
            /*******************************************************************/
          ELSIF cur_dmd_inv_rec.cust_trx_type_name IN -- IF (
            -- cur_dmd_inv_rec.status IN ('DMD',
            ('REVISED', 'RECTIFICATION', 'RR REFD RCVBL') THEN
            l_chr_exe_location := 'RefAdj_AO_026';
            l_stmt_processing  :=' Customer Transaction Type is ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ||cur_dmd_inv_rec.cust_trx_type_name );
            l_stmt_processing :=' Checking if ODD exists ';
            -- checking ODD exists (Rev)** '
            l_num_odd_exists := 0;
            SELECT COUNT('x')
            INTO l_num_odd_exists
            FROM xx_overdue_dem_details odd
            WHERE odd.reversal_status IS NULL
            AND odd.customer_trx_id    = cur_dmd_inv_rec.customer_trx_id;
            IF l_num_odd_exists        = 0 THEN
              l_num_final_odd_amt1    := 0;
              l_num_temp_amt1         := 0;
              l_chr_exe_location      := 'RefAdj_AO_027';
              l_chr_exe_location      := 'RefAdj_AO_026';
              l_stmt_processing       :=' Customer Transaction Type is ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              FOR l_rec_prev_dem IN
              (SELECT overdue_dem_amt ,
                dem_due_date ,
                customer_trx_id ,
                dmd_status
              FROM xx_tot_overdue_details
              WHERE rectified_customer_trx_id =cur_dmd_inv_rec.customer_trx_id
              AND reversal_status            IS NULL -- Added by Neha for Hotfix #
                -- 110235 on 29-JUL-2016
              ORDER BY dem_due_date
              )
              LOOP
                write_debug( g_debug_flag ,'l_rec_prev_dem.overdue_dem_amt** '|| l_rec_prev_dem.overdue_dem_amt);
                write_debug( g_debug_flag ,'l_num_temp_amt1** '|| l_num_temp_amt1);
                write_debug( g_debug_flag ,'l_rec_prev_dem.dmd_status** '|| l_rec_prev_dem.dmd_status);
                IF l_rec_prev_dem.overdue_dem_amt > l_num_temp_amt1 THEN
                  IF l_rec_prev_dem.dmd_status IN ('DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED') THEN
                    l_final_dem_due_date1 := l_calc_dmd_due_date;
                  ELSE -- IF l_rec_prev_dem.dmd_status IN
                    l_final_dem_due_date1 := l_rec_prev_dem.dem_due_date;
                  END IF; -- IF l_rec_prev_dem.dmd_status IN
                  l_num_final_odd_amt1 :=l_rec_prev_dem.overdue_dem_amt -
                  l_num_temp_amt1;
                  write_debug( g_debug_flag ,'l_num_final_odd_amt1** '|| l_num_final_odd_amt1);
                  write_debug( g_debug_flag ,'l_final_dem_due_date1: '|| l_final_dem_due_date1);
                  l_num_temp_amt1 := l_rec_prev_dem.overdue_dem_amt;
                  write_debug( g_debug_flag ,'l_num_temp_amt1** '|| l_num_temp_amt1 );
                  l_chr_exe_location := 'RefAdj_AO_027';
                  l_stmt_processing  :=' Customer Transaction Type is ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  /**** GET PREV DMD DETAILS *****/
                  g_exec_location    := 1015;
                  l_chr_exe_location := 'RefAdj_AO_028';
                  l_stmt_processing  :=' Calling the ODD Details Proc';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  -- calling INSERT_ODD_DETAILS_PROC
                  insert_odd_details_proc (p_out_chr_errbuff => l_chr_ood_errbuff, p_out_chr_retcode => l_chr_ood_retcode, p_in_overdue_amt => l_num_final_odd_amt1, p_in_curr_overdue_amt => l_num_final_odd_amt1, p_in_dem_due_date => l_final_dem_due_date1, p_in_last_int_calc_dte => NULL, p_in_cust_trx_id => cur_dmd_inv_rec.customer_trx_id, p_in_irt_id => cur_dmd_inv_rec.irt_id );
                  IF l_chr_ood_retcode  = g_chr_failure_code THEN
                    g_exec_location    := 1015;
                    p_out_chr_retcode  := g_chr_failure_code;
                    p_out_chr_errbuff  := l_chr_ood_errbuff;
                    l_chr_exe_location := 'RefAdj_AO_029';
                    l_stmt_processing  :=' ODD Details Proc Failed ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    write_debug( g_debug_flag ,p_out_chr_errbuff);
                    RAISE l_exc_exit_error_proc;
                  END IF;
                  g_exec_location := 1016;
                END IF; -- -- IF l_rec_prev_dem.overdue_dem_amt > l_num_temp_amt1
              END LOOP; -- FOR l_rec_prev_dem IN
              g_exec_location := 1016;
            END IF; -- IF l_num_odd_exists = 0
            l_chr_exe_location := 'RefAdj_AO_030';
            l_stmt_processing  := ' About to Fetch info from the overdue dem Details ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
            l_num_count := 0;
            --l_num_rev_apply_amt := 0;
            --l_num_tot_apply_amt := 0;
            l_inv_refd_adjust_amount := 0;
            l_count                    := 0;
            l_num_avl_ref_adj_amt      := 0;
            -- l_num_refd_seq_num := l_num_refd_seq_num + 1;-- Commented as
            -- part of Recomendation 3 from ACS
            SELECT num_refd_seq.nextval
            INTO l_num_refd_seq_num
            FROM dual;
            FOR j IN
            (SELECT l_sequence_no,
              curr_overdue_amt,
              overdue_dem_amt,
              dem_due_date,
              int_calc_to_month
            FROM xx_overdue_dem_details
            WHERE curr_overdue_amt > 0
            AND reversal_status   IS NULL --Added in Ver 4.5
            AND customer_trx_id    =cur_dmd_inv_rec.customer_trx_id
            ORDER BY l_sequence_no
            )
            LOOP
              l_num_count         := l_num_count + 1;
              l_num_int_apply_amt := 0;
              l_chr_exe_location  := 'RefAdj_AO_031';
              l_stmt_processing   :=' Entering Overdue dmd detail of ID ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_number);
              -- l_num_ref_header_count := 0;
              FOR cur_refd_header_rec IN cur_refd_header ( cur_dmd_inv_rec.customer_number)
              LOOP
                l_chr_exe_location := 'RefAdj_AO_032';
                l_stmt_processing  := ' Fetching info from the refd Headers Invoice ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_dmd_inv_rec.customer_trx_id);
                -- fetching avl_refd_adjust_amount** '
                SELECT avl_refd_adjust_amount
                INTO l_interest_calc_amt
                FROM xx_dmd_headers
                WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                AND MAJOR_HEAD       <> '0032'                        --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
                AND dmd_status    IN ('DMD','THRESHOLD DMD');--added on 4th
                -- may as program errors for duplicate trx id.
                write_debug( g_debug_flag ,'avl_amount:'|| l_interest_calc_amt);
                EXIT
              WHEN l_interest_calc_amt = 0;
                l_chr_exe_location    := 'RefAdj_AO_033';
                l_stmt_processing     :=' Checking if the Major head is same ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing ||cur_refd_header_rec.major_head);
                IF (l_num_ref_maj_head <>cur_refd_header_rec.major_head) AND l_num_ref_maj_head IS NOT NULL THEN
                  -- l_num_refd_seq_num := l_num_refd_seq_num + 1;-- Commented
                  -- as part of Recomendation 3 from ACS
                  SELECT num_refd_seq.nextval
                  INTO l_num_refd_seq_num
                  FROM dual;
                END IF;
                l_num_ref_maj_head := cur_refd_header_rec.major_head;
                l_chr_int_calc     := 'N';
                --------------------- DETERMINE IF IT IS OVERDUE : --------------
                l_chr_exe_location := 'RefAdj_AO_034';
                l_stmt_processing  := ' Checking if Dmd Lines already exists for the Invoice ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                --Adding in Ver 4.1
                -- Added for sc: whr IT AND FBT refd is there in refd headers
                -- table
                -- , int was getting computed on the whole dmd 2wce
                BEGIN
                  l_num_int_computed := 0;
                  no_int_calc        :=0;
                  -- checking if int already computed till int_calc_mnth
                  SELECT DISTINCT 1
                  INTO l_num_int_computed
                  FROM xx_dmd_lines
                  WHERE customer_trx_id =cur_dmd_inv_rec.customer_trx_id
                  AND int_calc_to_month =cur_refd_header_rec.approval_date
                  AND reversal_status  IS NULL;
                EXCEPTION
                WHEN NO_DATA_FOUND THEN
                  NULL;
                END;
                --added for partial dmd adjustment----CR_HWSW_0785 on 04-Apr-2019
                SELECT COUNT(1)
                INTO no_int_calc
                FROM xx_dmd_headers a
                WHERE dmd_status='DMD ON STAY'
                AND EXISTS
                  (SELECT 1
                  FROM xx_dmd_headers b
                  WHERE b.irt_id       = cur_dmd_inv_rec.irt_id
                  AND a.irt_id         = b.irt_id
                  AND b.customer_trx_id= cur_dmd_inv_rec.customer_trx_id
                  AND to_number(b.attribute15)    = a.customer_trx_id
                  );
                --added for partial dmd adjustment----CR_HWSW_0785 on 04-Apr-2019
                -- End of addition in Ver 4.1
                IF l_num_int_computed = 0 AND no_int_calc = 0 THEN --Added in Ver 4.1
                  l_chr_exe_location := 'RefAdj_AO_035';
                  l_stmt_processing  := ' Dmd record does not exists for invoice and date combination ' ;
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                  IF j.int_calc_to_month IS NULL THEN
                    l_dmd_serv_date   := j.dem_due_date;
                  ELSE -- IF j.int_calc_to_month IS NULL
                    l_dmd_serv_date :=TO_DATE('01-'|| TO_CHAR(ADD_MONTHS ( j.int_calc_to_month,1), 'MON-RRRR'), 'DD-MON-RRRR');
                  END IF; -- IF j.int_calc_to_month IS NULL
                  l_chr_exe_location := 'RefAdj_AO_036';
                  l_stmt_processing  :=' Checking Dmd Interest Status ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  write_debug( g_debug_flag ,'cur_refd_header_rec.approval_date:' || cur_refd_header_rec.approval_date);
                  write_debug( g_debug_flag ,'j.curr_overdue_amt:'|| j.curr_overdue_amt);
                  write_debug( g_debug_flag ,'l_dmd_serv_date:'|| l_dmd_serv_date);
                  write_debug( g_debug_flag ,'l_chr_dem_int_status:'|| l_chr_dem_int_status);
                  IF l_chr_dem_int_status = 'PROVISIONAL'
                    --cur_dmd_inv_rec.dmd_interest_status = 'PROVISIONAL'
                    THEN
                    l_month_diff     :=MONTHS_BETWEEN(TO_DATE(TO_CHAR( cur_refd_header_rec.approval_date, 'MON-YYYY') ,'MON-YYYY'), TO_DATE (TO_CHAR (l_dmd_serv_date,'MON-YYYY'),'MON-YYYY') );
                    IF l_month_diff  >= 0 THEN
                      l_chr_int_calc := 'Y';
                    END IF;
                  ELSIF l_chr_dem_int_status IS NULL -- IF l_chr_dem_int_status = '
                    -- PROVISIONAL'
                    THEN
                    l_chr_exe_location := 'RefAdj_AO_037';
                    l_stmt_processing  := ' Checking Dmd Interest Status is null ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing);
                    IF TO_CHAR (l_dmd_serv_date, 'DD') = TO_CHAR (LAST_DAY ( l_dmd_serv_date),'DD') THEN
                      l_dmd_serv_date                 := l_dmd_serv_date + 1;
                    ELSE -- IF TO_CHAR (l_dmd_serv_date, 'DD') =
                      l_dmd_serv_date := l_dmd_serv_date;
                    END IF; -- IF TO_CHAR (l_dmd_serv_date, 'DD') =
                    IF cur_refd_header_rec.approval_date >l_dmd_serv_date THEN
                      l_chr_int_calc                      := 'Y';
                    END IF; -- IF cur_refd_header_rec.approval_date
                  END IF;   -- IF l_chr_dem_int_status = 'PROVISIONAL'
                  l_chr_exe_location := 'RefAdj_AO_038';
                  l_stmt_processing  :=' Checking if Interest calc flag is Y ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing);
                  write_debug( g_debug_flag ,'l_chr_int_calc (R-Adj):'|| l_chr_int_calc);
                  ----------------------------------------------------------------
                  IF (l_chr_int_calc              = 'Y') AND ( l_interest_calc_amt <> 0 ) -- 3.3.6 Fix
                    AND cur_dmd_inv_rec.status = 'DMD' THEN                         -- Threshold
                    -- dmd need not undergo int calc
                    /************* INT CALCULATION ****************/
                    -- calling dmd_interest_calc ** '
                    l_chr_exe_location := 'RefAdj_AO_039';
                    l_stmt_processing  := ' Calling the Interest Dmd routine to get Interest Amount';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    l_num_int_apply_amt := dmd_interest_calc ( cur_refd_header_rec.approval_date, l_dmd_serv_date,
                    -- do nvl in cursor
                    (j.curr_overdue_amt- MOD (j.curr_overdue_amt, 100)), cur_dmd_inv_rec.assmt_year );
                    l_chr_exe_location := 'RefAdj_AO_040';
                    l_stmt_processing  := ' Inserting the Interest Line to dmd lines Table ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    -- Error in Dmd Interest population
                    INSERT
                    INTO xx_dmd_lines
                      (
                        customer_trx_id,
                        dmd_interest_amount,
                        int_calc_to_month,
                        cash_receipt_id,
                        last_updated_by,
                        last_update_date,
                        last_update_login,
                        created_by,
                        creation_date,
                        sequence_id,
                        irt_id --Added in Ver 4.5
                      )
                      VALUES
                      (
                        cur_dmd_inv_rec.customer_trx_id,
                        l_num_int_apply_amt,
                        cur_refd_header_rec.approval_date,
                        cur_refd_header_rec.reference_id,
                        g_num_user_id,
                        SYSDATE,
                        g_num_login_id,
                        g_num_user_id,
                        SYSDATE,
                        j.l_sequence_no,
                        cur_dmd_inv_rec.irt_id
                        --Added in Ver 4.5
                      );
                    l_chr_exe_location := 'RefAdj_AO_041';
                    l_stmt_processing  := ' Updating the dmd Header Table with status Provisional ';
                    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                    --Added for CR_0761-Refd In Interim Status--START--
                    select NVL(Dmd_Interest_AMount,0)
                    into LV_DMD_INT_AMT
                    from xx_dmd_headers
                    WHERE customer_trx_id                  = cur_dmd_inv_rec.customer_trx_id
                    and irt_id=cur_dmd_inv_rec.irt_id
                    AND NVL (dmd_interest_status,'-1') <> 'FINAL';                
                    --Added for CR_0761-Refd In Interim Status--END--
                    UPDATE xx_dmd_headers head
                    SET head.dmd_interest_status ='PROVISIONAL',
                      head.dmd_interest_amount   =
                      (SELECT NVL(SUM(dmd_interest_amount),0)
                      FROM xx_dmd_lines
                      WHERE customer_trx_id =head.customer_trx_id
                      AND reversal_status  IS NULL
                      )
                    WHERE head.customer_trx_id                  =cur_dmd_inv_rec.customer_trx_id
                    AND NVL (head.dmd_interest_status,'-1') <> 'FINAL';
                     --Added for CR_0761-Refd In Interim Status--START--
                      select NVL(Dmd_Interest_AMount,0)
                      into LV_Cal_DMD_INT_AMT
                      from xx_dmd_headers
                      WHERE customer_trx_id                  = cur_dmd_inv_rec.customer_trx_id
                      and irt_id=cur_dmd_inv_rec.irt_id
                      AND NVL (dmd_interest_status,'-1') <> 'FINAL';                          
                      LV_DMD_INT_AMT:=LV_Cal_DMD_INT_AMT-LV_DMD_INT_AMT;          
                    --Added for CR_0761-Refd In Interim Status--END--
                    l_chr_dem_int_status                       := 'PROVISIONAL';
                    l_chr_exe_location                         := 'RefAdj_AO_042';
                    l_stmt_processing                          := ' Updating the Overdue Dmd Dtls with Int_cal_to_month ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing) ;
                    UPDATE xx_overdue_dem_details
                    SET int_calc_to_month = cur_refd_header_rec.approval_date,
                      request_id          = g_num_request_id,
                      last_update_date    = g_dte_sys_date,
                      last_updated_by     = g_num_user_id
                    WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                    AND reversal_status  IS NULL
                    AND l_sequence_no     = j.l_sequence_no;
                  END IF; -- IF (l_chr_int_calc = 'Y')
          --Added for CR_785 on 04-APR-2019
                ELSIF(no_int_calc     >0) THEN
                  l_chr_exe_location := 'RefAdj_AOP_013';
                  l_stmt_processing  := ' Interest computation for Partial Dmd Adjustment ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id);
                  --Getting the data of Original DMD
                  SELECT customer_trx_id,
                    irt_id,
                    dmd_interest_status
                  INTO l_orig_cust_trx_id,
                    l_orig_irt_id,
                    l_dem_int_sts
                  FROM xx_DMD_HEADERS
                  WHERE CUSTOMER_TRX_ID IN
                    (SELECT ATTRIBUTE15
                    FROM xx_Dmd_headers
                    WHERE TO_CHAR(customer_trx_id)=cur_dmd_inv_rec.customer_trx_id
                    )
                  AND dmd_status='DMD ON STAY';
                  --Getting the data of Original DMD
                  BEGIN
                    -- Added in Ver 20
                    IF l_dem_int_sts ='PROVISIONAL' THEN
                      l_count       := 1;
                    ELSE
                      l_count                                   := 0;
                      IF TO_CHAR (l_calc_dmd_serv_date, 'DD') = TO_CHAR(LAST_DAY (l_calc_dmd_serv_date),'DD') THEN
                        l_calc_dmd_serv_date                 :=l_calc_dmd_serv_date + 1;
                      END IF; -- IF TO_CHAR (l_calc_dmd_serv_date, 'DD') =
                    END IF;   -- IF cur_dmd_inv_rec.dmd_interest_status ='PROVISIONAL'
                    l_chr_exe_location := 'RefAdj_AOP_014';
                    l_stmt_processing  :=' Checking if the status is Provisional ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    --Added for CR_785 Partial Dmd Adjustment on 04-Apr-2019
                    IF l_count            = 1 THEN
                      l_chr_exe_location := 'RefAdj_AOP_015';
                      l_stmt_processing  := ' Provisional so Computing the Months for interest Computation ' ;
                      write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                      SELECT TO_DATE ( '01-'
                        || TO_CHAR(ADD_MONTHS(MAX (int_calc_to_month),1), 'MON-RRRR') , 'DD-MON-RRRR' )
                      INTO l_max_to_month
                      FROM xx_dmd_lines
                      WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                      AND reversal_status  IS NULL;
                      l_month_diff         := MONTHS_BETWEEN (TO_DATE(TO_CHAR ( cur_refd_header_rec.approval_date, 'MON-YYYY' ) ,'MON-YYYY' ), TO_DATE (TO_CHAR (l_max_to_month, 'MON-YYYY' ), 'MON-YYYY' ) );
                    END IF; -- IF l_count = 1
                  EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                    l_count := 0;
                  WHEN OTHERS THEN
                    l_count := 0;
                  END;
                  l_chr_exe_location := 'RefAdj_AO_016';
                  l_stmt_processing  := ' Checking if interest has to be computed or not ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  IF (cur_dmd_inv_rec.status = 'DMD' AND l_count = 0 AND cur_refd_header_rec.approval_date > (l_calc_dmd_serv_date) ) OR ( cur_dmd_inv_rec.status = 'DMD' AND l_count = 1 AND l_month_diff >= 0 ) THEN
                    l_num_int_calc_flag        := 'Y';
                  ELSE
                    l_num_int_calc_flag := 'N';
                  END IF;
                  write_debug( g_debug_flag ,'l_num_int_calc_flag: '|| l_num_int_calc_flag);
                  IF l_num_int_calc_flag = 'Y' THEN
                    IF l_count           = 1 -- -1
                      THEN
                      l_dmd_serv_date := l_max_to_month;
                    ELSE
                      l_dmd_serv_date := l_calc_dmd_serv_date;
                      --Ver 20
                    END IF;
                    -- 'Error while calculating Int for Original'
                    write_debug( g_debug_flag ,'Refd Approval date: '|| cur_refd_header_rec.approval_date);
                    write_debug( g_debug_flag ,'l_dmd_serv_date: '|| l_dmd_serv_date);
                    write_debug( g_debug_flag ,'l_interest_calc_amt: '|| l_interest_calc_amt);
                    l_chr_exe_location := 'RefAdj_AOP_017';
                    l_stmt_processing  := ' Calling the Dmd Interest Calc Procedure ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    l_adjust_amount :=dmd_interest_calc ( cur_refd_header_rec.approval_date, l_dmd_serv_date, ( l_interest_calc_amt - MOD (l_interest_calc_amt, 100) ), cur_dmd_inv_rec.assmt_year );
                    write_debug( g_debug_flag , '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++' );
                    write_debug( g_debug_flag ,' Interest (Adjustment) Creation ');
                    write_debug( g_debug_flag ,' -------------------------------- ' );
                    write_debug( g_debug_flag ,' Receipt Approval Date := ' || TO_CHAR(cur_refd_header_rec.approval_date,'DD-MON-YYYY'));
                    write_debug( g_debug_flag ,' Receipt Amount := ' || cur_refd_header_rec.total_refd_amount);
                    write_debug( g_debug_flag ,' Dmd Invoice Amount := '|| l_interest_calc_amt);
                    write_debug( g_debug_flag ,' Interest(Adjustment) Amount:= '|| l_adjust_amount);
                    l_chr_exe_location := 'RefAdj_AOP_018';
                    l_stmt_processing  := ' Inserting the interest line to dmd lines table ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );                   
                    l_chr_exe_location := 'RefAdj_AOP_019';
                    l_stmt_processing  := ' Updating the Interest computed to dmd headers ';
                    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                    UPDATE xx_dmd_headers head
                    SET head.dmd_interest_status ='PROVISIONAL',
                      head.dmd_interest_amount   =
                      (SELECT NVL(SUM(dmd_interest_amount),0)
                      FROM xx_dmd_lines
                      WHERE customer_trx_id =head.customer_trx_id
                      AND reversal_status  IS NULL
                      )+l_adjust_amount
                    WHERE head.customer_trx_id                  = l_orig_cust_trx_id
                    AND NVL (head.dmd_interest_status,'-1') <> 'FINAL';
                  END IF; -- IF l_num_int_calc_flag = 'Y'
                END IF;
        --Added for CR_785 on 04-APR-2019
                /************* END OF INT CALCULATION ****************/
                /*********************** APPLICATION ********************/
                g_exec_location    := 1018;
                l_curr_overdue_amt := 0;
                l_chr_exe_location := 'RefAdj_AO_043';
                l_stmt_processing  := ' Checking if Overdue Dmd Dtls exists for the seq_no ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || j.l_sequence_no) ;
                SELECT curr_overdue_amt
                INTO l_curr_overdue_amt
                FROM xx_overdue_dem_details
                WHERE l_sequence_no  = j.l_sequence_no
                AND reversal_status IS NULL;
                write_debug( g_debug_flag ,'l_curr_overdue_amt:'|| l_curr_overdue_amt);
                IF l_curr_overdue_amt <= cur_refd_header_rec.total_refd_amount THEN
                  l_apply_amount      := l_curr_overdue_amt;
                ELSE
                  l_apply_amount := cur_refd_header_rec.total_refd_amount;
                END IF;
                /*** UPDATE REFD HEADERS WITH APPLY AMOUNT **/
                l_chr_exe_location := 'RefAdj_AO_044';
                l_stmt_processing  := ' Updating Refd Headers with Adjustment_amt for ref id ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_refd_header_rec.reference_id) ;
                UPDATE xx_refd_headers head
                SET head.refd_adjustment_amount = NVL ( head.refd_adjustment_amount, 0) + l_apply_amount
                WHERE head.reference_id           = cur_refd_header_rec.reference_id;
                l_chr_exe_location               := 'RefAdj_AO_045';
                l_stmt_processing                := ' Updating Dmd Headers with refd_Adjust_amt for Invoice ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_dmd_inv_rec.customer_trx_id) ;
                --To update the refd adjustment amount with APPly Amount
                UPDATE xx_dmd_headers
                SET avl_refd_adjust_amount = avl_refd_adjust_amount - l_apply_amount,
                  -- last_update_date           =g_dte_sys_date -- Added for AO
                  -- Portal automation prem
                  last_update_date = sysdate --Changed from g_dte_sys_date to
                  -- sysdate for CR_HWSW_0340
                WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id;
                /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --START*/
                UPDATE xx_tot_overdue_details
                SET overdue_dem_amt =
                  (SELECT avl_refd_adjust_amount
                  FROM xx_dmd_headers
                  WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                  AND dmd_status    IN ('DMD','THRESHOLD DMD') -- added for
                    -- Hotfix_139914 to fix subquery returns multiple rows error
                  )
                WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id;
                /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --END*/
             -----Added for CR_761-Refd In Interim Status--START-----
              INSERT
              INTO xxcus.xx_INTERIM_DEM_DTLS
                (
                    IRT_ID, 
                    ID_NUMBER ,
                    IRT_AY ,
                    CUSTOMER_TRX_ID ,
                    DMD_IDENTIFICATION_NUMBER ,
                    ADJUSTED_DMD_AMOUNT ,
                    PROV_INT_DMD_AMT ,
                    DMD_TYPE ,
                    IRT_SCHEDULE_TYPE ,
                    SEC_CODE ,
                    REF_NUM ,
                    REF_IRT_ID ,
                    Program_Name ,
                    REFERENCE_ID ,
                    LAST_UPDATE_DATE 
                )
                VALUES
                (
                  cur_dmd_inv_rec.IRT_ID ,
                  cur_dmd_inv_rec.CUSTOMER_NUMBER ,
                  cur_dmd_inv_rec.ASSMT_YEAR ,
                  cur_dmd_inv_rec.CUSTOMER_TRX_ID ,
                  cur_dmd_inv_rec.DIN,
                  l_apply_amount,
                  LV_DMD_INT_AMT,
                  cur_dmd_inv_rec.STATUS,
                  cur_dmd_inv_rec.SCHEDULE_TYPE ,
                  cur_dmd_inv_rec.SEC_CODE ,
                  l_num_refd_seq_num,                  
                  cur_refd_header_rec.irt_id,
                  'IRT ACCOUNTING',
                  cur_refd_header_rec.reference_id,
                  SYSDATE

                );
                If(sql%ROWCOUNT>0) then
                 dbms_output.put_line('Record is inserted into table xx_INTERIM_DEM_DTLS 104'||sql%ROWCOUNT);
                 FND_FILE.put_line ( FND_FILE.LOG,'Record is inserted into table xx_INTERIM_DEM_DTLS 104'|| sql%ROWCOUNT) ;
                end If;
            -----Added for CR_761-Refd In Interim Status--END-------
                l_chr_exe_location := 'RefAdj_AO_046';
                l_stmt_processing  := ' Checking if Refd details exists for writeoff for ref_id ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || cur_refd_header_rec.reference_id);
                FOR cur_refd_line_rec IN cur_refd_line ( cur_refd_header_rec.reference_id)
                LOOP
                  l_writeoff_amount          := 0;
                  l_msg_count                := NULL;
                  l_return_status2           := NULL;
                  l_attribute_rec.attribute2 := cur_dmd_inv_rec.customer_trx_id;
                  l_attribute_rec.attribute4 := 'REFD ADJUSTMENT';
                  l_attribute_rec.attribute1 :=cur_refd_header_rec.major_head;
                  l_attribute_rec.attribute3 :=cur_refd_header_rec.assmt_year;
                  l_attribute_rec.attribute5 := l_num_refd_seq_num;
                  EXIT
                WHEN l_apply_amount    = 0;
                  IF l_apply_amount   >= cur_refd_line_rec.amount THEN
                    l_writeoff_amount := cur_refd_line_rec.amount;
                  ELSE
                    l_writeoff_amount := l_apply_amount;
                  END IF;
                  l_chr_exe_location := 'RefAdj_AO_047';
                  l_stmt_processing  :=' Computed Write_off_amt as ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || l_writeoff_amount) ;
                  IF l_writeoff_amount <> 0 THEN
                    l_chr_exe_location := 'RefAdj_AO_048';
                    l_stmt_processing  :=' Calling Write off API ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing) ;
                    --AR_RECEIPT_API_PUB.ACTIVITY_APPLICATION (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count , x_msg_data => l_msg_data, p_cash_receipt_id => cur_refd_line_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_refd_header_rec.approval_date, p_apply_gl_date => g_dte_sys_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id );  --Commented for Hotfix_199485 on 13-MAR-2019
                    AR_RECEIPT_API_PUB.ACTIVITY_APPLICATION (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count , x_msg_data => l_msg_data, p_cash_receipt_id => cur_refd_line_rec.cash_receipt_id, p_amount_applied => l_writeoff_amount, p_apply_date => cur_refd_header_rec.approval_date, p_apply_gl_date => cur_refd_header_rec.approval_date, p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id ); --Added for Hotfix_199485 on 13-MAR-2019
                    write_debug( g_debug_flag , 'Apply receipt writeoff for receipt ID ' || cur_refd_line_rec.cash_receipt_id || ' for refd adjustment amount '|| l_writeoff_amount || ' - Status - '|| l_return_status2);
                    l_chr_exe_location := 'RefAdj_AO_049';
                    l_stmt_processing  :=' API Call status is ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_return_status2 );
                    IF l_msg_count = 1 THEN
                      write_msg( g_write_logfile ,'l_msg_data '|| RTRIM (LTRIM ( l_msg_data))|| '****');
                      p_out_chr_errbuff := RTRIM (LTRIM (l_msg_data));
                      RAISE L_EXC_EXIT_ERROR_PROC;
                    ELSIF l_msg_count > 1 --IF l_msg_count = 1
                      THEN
                      LOOP
                        p_count       := p_count + 1;
                        l_msg_data    :=fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false);
                        IF l_msg_data IS NULL THEN
                          EXIT;
                        END IF; --IF l_msg_data IS NULL
                        p_out_chr_errbuff := p_out_chr_errbuff ||'-'||RTRIM (LTRIM (l_msg_data));
                        write_msg( g_write_logfile ,'Message'|| p_count|| ' ---'|| l_msg_data);
                      END LOOP;
                      RAISE l_exc_exit_error_proc;
                    END IF; -- ELSIF l_msg_count > 1
                    l_chr_exe_location := 'RefAdj_AO_050';
                    l_stmt_processing  := ' Recomputing the Overdue_amt In Overdue_dem_details ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-' || L_Stmt_Processing );
                    UPDATE xx_overdue_dem_details
                    SET curr_overdue_amt  = (curr_overdue_amt - l_writeoff_amount),
                      request_id          = g_num_request_id,
                      last_update_date    = g_dte_sys_date,
                      last_updated_by     = g_num_user_id
                    WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
                    AND l_sequence_no     = j.l_sequence_no
                    AND reversal_status  IS NULL;
                    l_chr_exe_location   := 'RefAdj_AO_051';
                    l_stmt_processing    := ' Recomputing the refd adjustment In refd lines table ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-' || L_Stmt_Processing );
                    --Added in Ver 4.5
                    UPDATE xx_refd_lines line
                    SET line.refd_adjustment_amount = NVL ( LINE.REFD_ADJUSTMENT_AMOUNT,0) + l_writeoff_amount
                    WHERE line.reference_id           =cur_refd_line_rec.reference_id
                    AND line.cash_receipt_id          =cur_refd_line_rec.cash_receipt_id;
                    l_apply_amount                   :=l_apply_amount - l_writeoff_amount;
                  END IF; -- IF l_writeoff_amount <> 0
                END LOOP; -- FOR cur_refd_line_rec--REFD LINE LOOP
              END LOOP;   --FOR cur_refd_header_rec IN -- REFD HEADER LOOP
            END LOOP;     --FOR j IN (SELECT l_sequence_no, curr_overdue_amt, -- J
            -- LOOP
          END IF; -- -- IF ( cur_dmd_inv_rec.status IN ('DMD', --ORIG/RECT
        EXCEPTION
        WHEN e_skip_dmd THEN
          NULL;
        END;
        -- End of addition in Ver 4.1
      END IF; --Added for HF_187662 on 3-Oct-2018
    END LOOP; -- FOR cur_dmd_inv_rec IN cur_dmd_inv --DMD LOOP
    l_chr_exe_location := 'RefAdj_AO_052';
    l_stmt_processing  :=' Updating the refd sequence number ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-' || L_Stmt_Processing );
    -- Check if it needs to be done like batch and not for each dmd?
    -- updating Refd Seq
    -- Commented as part of Recomendation 3 from ACS
    /* UPDATE xx_refd_seq_num
    SET refd_seq_no = l_num_refd_seq_num,
    last_update_date = g_dte_sys_date,
    request_id = g_num_request_id,
    program_id = g_num_program_id,
    last_updated_by = g_num_user_id;
    */
    write_debug( g_debug_flag , '--------------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Refd Adjustment with Current/Cross Assmt Year - ENDS ***');
    write_debug( g_debug_flag , '-------------------------------------------------------------');
  EXCEPTION
  WHEN l_exc_exit_error_proc THEN
    p_out_chr_retcode := g_chr_failure_code;
    write_msg( g_write_logfile , '------------------------------------------------------------');
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR( p_out_chr_errbuff,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_out_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  WHEN e_skip_subsequent_adj THEN
    NULL;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_out_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  END refd_adjust_proc_ao;
--ADDED AS A PART AO PORTAL CONFIRMED DMDS - ADDED BY RAJESH - 17-DEC-2014
-- ENDS HERE
  PROCEDURE refd_adjust_proc(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      p_in_id_number IN VARCHAR2,
      p_in_irt_id     IN VARCHAR2,
      p_in_rrd_call   IN VARCHAR2 DEFAULT NULL --added for CR_HWSW_102
    )
  AS
    /****************************************************************************
    **************
    * Type : Procedure
    * Name : REFD_ADJUST_PROC
    * Input Parameters : p_in_id_number, p_in_irt_id
    * Output Parameters : out_chr_errbuff
    * out_chr_retcode
    * Purpose : Procedure to apply identified receipts to prior assmet year
    dmds
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 13-Jan-2012
    * Last Reviewed By :
    * Last Reviewed Date :
    *****************************************************************************
    **********
    * Modified Date Modified By Version Modification Type Modification Details
    * ------------- ------------ -------- - -----------------
    --------------------------
    * 13-Jan-2012 Infosys 1.0 O Baseline.
    *****************************************************************************
    *********/
    -- User defined exception for Commit with Warning
    l_exc_exit_error_proc      EXCEPTION;
    e_skip_dmd              EXCEPTION;
    e_skip_subsequent_adj      EXCEPTION;   --added for CR_HWSW_102
    v_400_rrd                  VARCHAR2(1); --added for CR_HWSW_102
    l_chr_proc_name            VARCHAR2(50) :='REFD_ADJUST_PROC';
    l_chr_exe_location         VARCHAR2(50) :='';
    l_stmt_processing          VARCHAR2(250);
    l_out_chr_retcode          VARCHAR2(50)  :='';
    l_out_chr_errbuff          VARCHAR2(2500):='';
    l_msg_count                NUMBER;
    l_num_refd_seq_num       NUMBER;
    l_apply_amount             NUMBER;
    l_inv_amount               NUMBER;
    l_num_int_apply_amt        NUMBER := 0;
    l_inv_refd_adjust_amount NUMBER;
    l_amount               NUMBER;
    l_interest_calc_amt        NUMBER;
    l_total_adjust_amt         NUMBER;
    l_total_adjapp_amt         NUMBER;
    l_inv_amt_due_remaining    NUMBER := 0;
    l_num_avl_ref_adj_amt      NUMBER := 0;
    l_num_refd_exists        NUMBER := 0;
    l_num_int_computed         NUMBER := 0;
    p_count                    NUMBER;
    l_count                    NUMBER;
    l_calc_state_cd            NUMBER;
    l_calc_status              NUMBER;
    l_month_diff               NUMBER;
    l_inv_amt_remaining        NUMBER;
    l_adjust_amount            NUMBER;
    l_writeoff_amount          NUMBER;
    l_num_odd_exists           NUMBER := 0;
    l_num_count                NUMBER := 0;
    g_exec_location            NUMBER;
    l_num_final_odd_amt1       NUMBER := 0;
    l_num_temp_amt1            NUMBER := 0;
    l_curr_overdue_amt         NUMBER := 0;
    L_CONFIRMED_REC            NUMBER := 0; --ADDED AS A PART OF AO PORTAL
    -- VERIFICATION
    L_REJECTED_REC      NUMBER := 0; --ADDED AS A PART OF AO PORTAL VERIFICATION
    L_PENDING_REC_COUNT NUMBER := 0; --ADDED AS A PART OF AO PORTAL VERIFICATION
    L_NOT_ACTED_REC     NUMBER := 0; --ADDED AS A PART OF AO PORTAL VERIFICATION
    --- variables added by kala
    L_AO_CONFRM_REC    NUMBER := 0;
    L_ASSE_CONFRM_REC  NUMBER := 0;
    L_ASSE_PROTEST_REC NUMBER := 0;
    L_245_CNT          NUMBER := 0;
    --- variables addition ends
    l_calc_dmd_serv_date DATE;
    l_dmd_serv_date      DATE;
    l_max_to_month          DATE;
    l_final_dem_due_date1   DATE := NULL;
    l_calc_dmd_due_date  DATE;
    l_msg_data              VARCHAR2 (5000);
    l_num_ref_maj_head      VARCHAR2 (50) := NULL;
    l_chr_dem_int_status    VARCHAR2 (50) := NULL;
    out_err_msg             VARCHAR2 (2000);
    l_chr_ood_errbuff       VARCHAR2 (500);
    l_chr_ood_retcode       VARCHAR2 (30);
    l_return_status2        VARCHAR2 (1);
    l_return_status         VARCHAR2 (1);
    l_num_int_calc_flag     VARCHAR2 (1);
    l_chr_int_calc          VARCHAR2 (1);
    l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
    l_application_ref_id ar_receivable_applications.application_ref_id%TYPE;
    l_application_ref_type ar_receivable_applications.application_ref_type%TYPE;
    l_application_ref_num ar_receivable_applications.application_ref_num%TYPE;
    l_secondary_application_ref_id ar_receivable_applications.secondary_application_ref_id%TYPE;
    l_receivable_application_id ar_receivable_applications.receivable_application_id%TYPE;
    -- Cursor to Fetch if any earlier /old dmd due which has a refd now
    CURSOR cur_dmd_inv (p_id_num VARCHAR2)
    IS
      SELECT DMD.customer_trx_id,
        DMD.trx_number,
        DMD.irt_ay assmt_year,
        DMD.id_number customer_number,
        DMD.avl_refd_adjust_amount amount_due_remaining,
        DMD.major_head,
        DMD.dmd_status status,
        DMD.irt_schedule_type schedule_type,
        DMD.irt_id,
        DMD.dmd_service_date dmd_serv_date,
        DMD.avl_refd_adjust_amount inv_refd_adjust_amount,
        DMD.irt_returns_due_date irt_due_date,
        DMD.customer_trx_date trx_date,
        DMD.payment_schedule_id,
        DMD.dmd_interest_status,
        DMD.cust_trx_type_name,
        HEADER.irt_ay refd_irt_ay --for CR_HWSW_102
      FROM xx_dmd_headers DMD ,
        xx_refd_headers HEADER
      WHERE ( ( dmd_status             = 'DMD'
      AND DMD_SERVICE_DATE            IS NOT NULL )
      OR ( dmd_status                 IN('INT DMD', 'THRESHOLD DMD') ) )-- #CR-644
      AND DMD.avl_refd_adjust_amount > 0
      AND DMD.IRT_SCHEDULE_TYPE       <> 'FBB' --Added as a Part of
        -- Hotfix#92353 on 12-OCT-2015
      AND HEADER.ID_NUMBER = DMD.ID_NUMBER
      AND header.ID_NUMBER = P_ID_NUM
      AND HEADER.refd_status                                                                                                    = 'PCM APPROVED'
      AND HEADER.approval_date                                                                                                   IS NOT NULL
      AND ( NVL (HEADER.total_refd_amount, 0) - NVL ( HEADER.refd_adjustment_amount, 0) - NVL (HEADER.net_refd_amount, 0) ) > 0
      AND NOT EXISTS
        (SELECT 1
        FROM xx_irt_fas_prcsng_hold XIFPH
        WHERE DMD.irt_id     = XIFPH.irt_id
        AND XIFPH.hold_flag    IN('IRT REFD HOLD', 'IRTCLAIM HOLD')
        AND XIFPH.release_flag IS NULL
        )
      -----------------------added for hot fix #77468-----------
    AND DMD.IRT_AY >1960
    AND DMD.IRT_AY<=
      ( SELECT EXTRACT (YEAR FROM SYSDATE) FROM dual
      )
      -----------------------added for hot fix #77468-----------
    ORDER BY TO_NUMBER (DMD.irt_ay),
      TO_NUMBER (DMD.major_head),
      DMD.id_number ASC,
      DMD.irt_schedule_type DESC FOR UPDATE;
    -- Cursor fetch the refd details that can be applied for the ID
    CURSOR cur_refd_header (p_in_customer_number IN VARCHAR2)
    IS
      SELECT HEAD.reference_id ,
        HEAD.irt_id ,
        HEAD.id_number customer_number ,
        HEAD.irt_ay assmt_year ,
        HEAD.major_head ,
        ( NVL (HEAD.total_refd_amount, 0) - NVL (HEAD.refd_adjustment_amount, 0) - NVL (HEAD.net_refd_amount, 0)) total_refd_amount ,
        HEAD.approval_date
      FROM xx_refd_headers head
      WHERE HEAD.id_number                                                                                                = p_in_customer_number
      AND HEAD.refd_status                                                                                               = 'PCM APPROVED'
      AND ( NVL (HEAD.total_refd_amount, 0) - NVL (HEAD.refd_adjustment_amount, 0) - NVL (HEAD.net_refd_amount, 0) ) > 0
      AND NOT EXISTS
        (SELECT 1
        FROM xx_irt_fas_prcsng_hold xifph
        WHERE head.irt_id       = xifph.irt_id
        AND xifph.hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
        AND xifph.release_flag IS NULL
        ) --Added in 4.6
    ORDER BY head.reference_id FOR UPDATE;
    -- Cursor fetch the refd line details
    CURSOR cur_refd_line (in_num_reference_id IN NUMBER)
    IS
      SELECT line.reference_id ,
        line.cash_receipt_id ,
        line.receipt_ay ,
        line.receipt_date ,
        ( NVL (line.excess_receipt_amount, 0) - NVL ( line.refd_adjustment_amount, 0) - NVL (line.net_refd_amount, 0) + NVL (line.refd_roundoff_amount, 0) - NVL ( line.refd_crossadjust_amount, 0) - NVL (line.rr_refdemadj_amount, 0) ) amount ,
        line.refd_adjustment_amount ,
        line.net_refd_amount
      FROM xx_REFD_LINES LINE
      WHERE line.reference_id = in_num_reference_id
      ORDER BY line.reference_id,
        line.receipt_date,
        line.cash_receipt_id FOR UPDATE;
  BEGIN -- main program
    p_out_chr_errbuff  := ' ';
    p_out_chr_retcode  := g_chr_success_code;
    l_chr_exe_location := 'RefAdj_001';
    l_stmt_processing  :=' Entering the Refd Adjsutment API';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    write_debug( g_debug_flag , '-----------------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Refd Adjustment with Current/Cross Assmt Year - STARTS ***');
    write_debug( g_debug_flag , '-----------------------------------------------------------------------');
    /**************** DEFAULING SERVICE DATE ***************************/
    l_chr_exe_location := 'RefAdj_002';
    l_stmt_processing  :=' Setting the dmd service Date ';
    WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
    ---- below code added by kala
    SELECT COUNT(1)
    INTO L_245_cnt --- 245 sent cases
    FROM xxcus.IRT_NOTICE_US_245
    WHERE IRT_ID   =p_in_irt_id
    AND ETL_RD_FLAG='Y' ;
    --AO PORTAL CHANGES STARTS HERE - 23-DEC-2014 ADDED BY RAJESH - STRATS HERE
    WRITE_DEBUG( G_DEBUG_FLAG , '***   CHECKING AO CONFIRMED RECORDS EXISTING OR NOT - STARTS HERE ***');

    --- comented by kala
    SELECT COUNT(DECODE(ATTRIBUTE1,'Y',1)),
      COUNT(DECODE(ATTRIBUTE6,'Y',1)),
      COUNT(DECODE(ATTRIBUTE6,'R',1)),
      COUNT(DECODE(ATTRIBUTE6,'A',1))
    INTO L_AO_CONFRM_REC,
      L_ASSE_CONFRM_REC,
      L_NOT_ACTED_REC,
      L_ASSE_PROTEST_REC
    FROM xx_DMD_HEADERS
    WHERE ID_NUMBER   =P_IN_ID_NUMBER
    AND MAJOR_HEAD    <> '0032'                                      --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    AND DMD_STATUS IN ('DMD','THRESHOLD DMD','INT DMD'); --CR#644
    --if ((L_ao_confrm_REC>0 or L_asse_confrm_REC>0 or L_asse_protest_REC>0 ) and
    -- L_245_cnt>0) then --Commented as a Part of Hotfix#124199 - On 20-Jul-2016
    --if ((L_ao_confrm_REC>0 or L_asse_confrm_REC>0 or L_asse_protest_REC>0 or
    -- L_NOT_ACTED_REC > 0 ) and L_245_cnt>0) then --Modified as a Part of
    -- Hotfix#124199 - 20-jul-2016
    SELECT DISTINCT NVL(RELAX_FLAG,'X')
    INTO V_RELAX_FLAG
    FROM xxcus.xx_AR_TRANS_STG
    WHERE TRANSACTION_NUMBER=P_IN_IRT_ID;
    WRITE_DEBUG( G_DEBUG_FLAG ,'*** V_RELAX_FLAG='||V_RELAX_FLAG);
    WRITE_DEBUG( G_DEBUG_FLAG ,'*** L_245_CNT='||L_245_CNT);
    IF (((L_AO_CONFRM_REC>0 OR L_ASSE_CONFRM_REC>0 OR L_ASSE_PROTEST_REC>0 OR L_NOT_ACTED_REC > 0 ) )
      -- AND (L_245_CNT>0))
      OR ( V_RELAX_FLAG='RELAX' ) ) --- relax flag uncommented to adjust threshold dmd
      THEN                           --Modified as a Part of Hotfix#124199 - 20-jul-2016
      -- V_RELAX_FLAG added for CR_608
      WRITE_DEBUG( G_DEBUG_FLAG ,'*** before calling actual adjust');
      REFD_ADJUST_PROC_AO( P_OUT_CHR_ERRBUFF => P_OUT_CHR_ERRBUFF, P_OUT_CHR_RETCODE => P_OUT_CHR_RETCODE, P_IN_ID_NUMBER => P_IN_ID_NUMBER, P_IN_IRT_ID => P_IN_IRT_ID );
      WRITE_DEBUG( G_DEBUG_FLAG , '***   CHECKING AO CONFIRMED RECORDS EXISTING OR NOT - ENDS HERE ***');

    END IF; --END IF FOR AO PORTAL CHECK
  EXCEPTION
  WHEN l_exc_exit_error_proc THEN
    p_out_chr_retcode := g_chr_failure_code;
    write_msg( g_write_logfile , '------------------------------------------------------------');
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR( p_out_chr_errbuff,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_out_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  WHEN e_skip_subsequent_adj THEN
    NULL;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_out_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  END refd_adjust_proc;
----***************************** End of Procedure / Function *****************
  PROCEDURE dmd_intinv(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      p_in_id_num IN VARCHAR2,
      p_in_irt_id  IN VARCHAR2 )
  AS
    /****************************************************************************
    ****************************************
    * Type : Procedure
    * Name : DMD_INTINV_PROC
    * Input Parameters : p_in_irt_id
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * Purpose : Procedure to apply invoice to receipts
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 20-Jan-2012
    * Last Reviewed By : Infosys
    * Last Reviewed Date : ******************************************************
    ***************************************************************
    * Modified Date Modified By Version Modification Type Modification Details
    * ------------- ------------ -------- ----------------- ---------------------
    * 20-Jan-2012 Infosys 1.0 O Baseline.
    *****************************************************************************
    ****************************************/
    l_trx_id              NUMBER;
    l_trx_line_id         NUMBER;
    x_customer_trx_id     NUMBER;
    x_msg_count           NUMBER;
    l_party_id            NUMBER;
    l_memo_line_id        NUMBER;
    l_payment_schedule_id NUMBER;
    l_trx_type_id         NUMBER;
    l_term_id             NUMBER;
    l_batch_source_id     NUMBER;
    l_application_id      NUMBER;
    l_resp_id             NUMBER;
    l_chk                 NUMBER;
    l_cnt                 NUMBER := 0;
    L_COUNT               NUMBER := 1;
    l_num_dmd_seq_num  NUMBER := 3699999999;
    l_trx_number          VARCHAR2 (20);
    l_chr_processing_yr   VARCHAR2 (10);
    l_chr_errbuff         VARCHAR2(50);
    l_chr_retcode         VARCHAR2(50);
    l_chr_proc_name       VARCHAR2(50) :='dmd_intinv_proc';
    l_chr_exe_location    VARCHAR2(50) :='';
    l_stmt_processing     VARCHAR2(200);
    l_memo_line_name      VARCHAR2 (100);
    x_return_status       VARCHAR2 (2000);
    x_msg_data            VARCHAR2 (2000);
    l_batch_source_rec ar_invoice_api_pub.batch_source_rec_type;
    l_trx_header_tbl ar_invoice_api_pub.trx_header_tbl_type;
    l_trx_lines_tbl ar_invoice_api_pub.trx_line_tbl_type;
    l_trx_dist_tbl ar_invoice_api_pub.trx_dist_tbl_type;
    l_trx_salescredits_tbl ar_invoice_api_pub.trx_salescredits_tbl_type;
    custom_exception    EXCEPTION;
    e_skip_calc         EXCEPTION;
    L_IRT_APPROVAL_DATE DATE;--Added for Hotfix_199485 on 13-MAR-2019
    --Cursor Declaration
    --
    CURSOR cur_dmd_header(p_in_id IN VARCHAR2)
    IS
      SELECT customer_trx_id ,
        trx_number ,
        irt_ay assmt_year ,
        id_number customer_number ,
        irt_schedule_type ,
        dmd_identification_number ,
        avl_refd_adjust_amount amount_due_remaining ,
        major_head ,
        dmd_status status ,
        irt_schedule_type schedule_type ,
        irt_id ,
        dmd_service_date dmd_serv_date ,
        avl_refd_adjust_amount inv_refd_adjust_amount ,
        dmd_interest_amount ,
        irt_returns_due_date irt_due_date ,
        customer_trx_date trx_date ,
        payment_schedule_id ,
        irt_ay ,
        id_number
      FROM xx_dmd_headers DMD
      WHERE DMD.dmd_status         IN ('DMD', 'CLOSED')
      AND DMD.avl_refd_adjust_amount = 0
      AND DMD.dmd_interest_status   = 'PROVISIONAL'
      AND DMD.dmd_service_date     IS NOT NULL
      AND DMD.dmd_interest_number  IS NULL
      AND DMD.dmd_interest_amount   > 0
      AND DMD.IRT_SCHEDULE_TYPE       <> 'FBB' --Added as a Part of
        -- Hotfix#92353 on 12-OCT-2015
      AND DMD.id_number = p_in_id;
  BEGIN
    p_out_chr_errbuff  := ' ';
    p_out_chr_retcode  := g_chr_success_code;
    l_chr_exe_location := 'DII_0001';
    l_stmt_processing  := '*** Dmd Interest Invoice Program - STARTS ***' ;
    write_debug( g_debug_flag ,l_stmt_processing );
	dbms_output.put_line(l_stmt_processing);
    write_debug( g_debug_flag ,'For Id_number : ' || p_in_id_num );
    --Vendor id Fetch
    l_chr_exe_location := 'DII_0003';
    l_stmt_processing  :='Vendor id Fetch';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
   --Change--- venkat

   SELECT acct.cust_account_id
    INTO l_party_id
    FROM hz_parties party,
      hz_cust_accounts acct
    WHERE party.party_id                   = acct.party_id
	AND party.party_name                   = acct.account_number
	and acct.account_number =p_in_id_num; --//Added BY  kulasekhar ABC 2.0 Start
    --AND party.party_name                   = 'Xx Customer'; --//COMMENTED BY  kulasekhar ABC 2.0 Start

    IF TO_NUMBER (TO_CHAR (SYSDATE, 'MM')) < 4 THEN
      l_chr_processing_yr                 := TO_CHAR (SYSDATE, 'RRRR') - 1;
    ELSE
      l_chr_processing_yr := TO_CHAR (SYSDATE, 'RRRR');
    END IF;

    FOR cur_dmd_header_rec IN cur_dmd_header(p_in_id_num)
    LOOP
      l_chk             := 0;
      l_trx_id          := NULL;
      l_trx_line_id     := NULL;
      l_trx_type_id     := NULL;
      l_term_id         := NULL;
      l_memo_line_id    := NULL;
      l_batch_source_id := NULL;
      x_msg_count       := NULL;
      x_return_status   := NULL;
      x_customer_trx_id := NULL;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| ' Inside Loop - Dmd Status ' ||cur_dmd_header_rec.status );
      BEGIN
        IF cur_dmd_header_rec.status = 'CLOSED' THEN
          BEGIN
            l_chr_exe_location := 'DII_0005';
            l_stmt_processing  := 'DIN(dmd_identification_number) Fetch for CLOSED status';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
			dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
            SELECT 1
            INTO l_chk
            FROM DUAL
            WHERE EXISTS
              (SELECT 1
              FROM xx_dmd_headers xdh
              WHERE xdh.dmd_identification_number = cur_dmd_header_rec.dmd_identification_number
              AND xdh.id_number                     = cur_dmd_header_rec.id_number
              AND xdh.irt_ay                         = cur_dmd_header_rec.irt_ay
              AND xdh.major_head                     = cur_dmd_header_rec.major_head
              AND xdh.irt_schedule_type              = cur_dmd_header_rec.irt_schedule_type
              AND xdh.dmd_status                 <> 'CLOSED'
              AND xdh.irt_id                         = cur_dmd_header_rec.irt_id
              AND MAJOR_HEAD                        <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
              AND EXISTS
                (SELECT 1
                FROM xx_dmd_lines xdl
                WHERE xdh.customer_trx_id = xdl.customer_trx_id
                )
              );
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            l_chk := 0;
          END;
        ELSIF cur_dmd_header_rec.status = 'DMD' THEN
          BEGIN
            l_chr_exe_location := 'DII_0006';
            l_stmt_processing  := 'DIN(dmd_identification_number) Fetch for DMD status';
			dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            SELECT 1
            INTO l_chk
            FROM DUAL
            WHERE EXISTS
              (SELECT 1
              FROM xx_dmd_headers xdh
              WHERE xdh.dmd_identification_number = cur_dmd_header_rec.dmd_identification_number
              AND xdh.id_number                     = cur_dmd_header_rec.id_number
              AND xdh.irt_ay                         = cur_dmd_header_rec.irt_ay
              AND xdh.major_head                     = cur_dmd_header_rec.major_head
              AND xdh.irt_schedule_type              = cur_dmd_header_rec.irt_schedule_type
              AND xdh.dmd_status                 <> 'DMD'
              AND xdh.irt_id                         = cur_dmd_header_rec.irt_id
              AND MAJOR_HEAD                        <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
              AND EXISTS
                (SELECT 1
                FROM xx_dmd_lines xdl
                WHERE xdh.customer_trx_id = xdl.customer_trx_id
                )
              );
          EXCEPTION
          WHEN no_data_found THEN
            l_chk := 0;
          END;
        END IF; --IF cur_dmd_header_rec.status = 'CLOSED'
        IF l_chk = 1 THEN
          RAISE e_skip_calc;
        END IF; --l_chk = 1
        l_chr_exe_location := 'DII_0007';
        l_stmt_processing  := 'Generating ra_customer_trx_s Sequence id';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
        SELECT ra_customer_trx_s.NEXTVAL INTO l_trx_id FROM DUAL;
        l_chr_exe_location := 'DII_0008';
        l_stmt_processing  := 'Generating ra_customer_trx_lines_s Sequence id';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
        SELECT ra_customer_trx_lines_s.NEXTVAL INTO l_trx_line_id FROM DUAL;
        --batch source id Fetch
        l_chr_exe_location := 'DII_0009';
        l_stmt_processing  :=' Fetch batch_source_id from ra_customer_trx_all';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
        SELECT batch_source_id
        INTO l_batch_source_id
        FROM ra_customer_trx_all
        WHERE customer_trx_id = cur_dmd_header_rec.customer_trx_id;
        --Trx type id Fetch
        l_chr_exe_location := 'DII_0010';
        l_stmt_processing  :=' Fetch cust_trx_type_id from ra_customer_trx_all';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
        SELECT cust_trx_type_id
        INTO l_trx_type_id
        FROM ra_cust_trx_types_all
        WHERE attribute1 = cur_dmd_header_rec.major_head
        AND attribute2   = 'INT220'
        AND attribute3   = cur_dmd_header_rec.schedule_type;
        --Memo line id Fetch
        l_chr_exe_location := 'DII_0011';
        l_stmt_processing  :=' Fetch memo_line_id and name from ar_memo_lines';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
        SELECT memo_line_id,
          NAME
        INTO l_memo_line_id,
          l_memo_line_name
        FROM ar_memo_lines
        WHERE line_type = 'LINE'
        AND attribute1  = cur_dmd_header_rec.major_head
        AND attribute2  = 'Interest 220'
        AND attribute3  = cur_dmd_header_rec.schedule_type;
        --terms id Fetch
        --Added for Hotfix_199485 on 13-MAR-2019--START
        SELECT DISTINCT IRT_APPROVAL_DATE
        INTO L_IRT_APPROVAL_DATE
        FROM xx_AR_TRANS_STG XATSA
        WHERE NVL(XATSA.STATUS_CODE ,'NEW') NOT IN ('ERROR','INV_SUCCESS','NOT_TO_BE_PROC','FAS IRT STG HOLD')
        AND xatsa.transaction_number             = p_in_irt_id;
        --Added for Hotfix_199485 on 13-MAR-2019-END
        l_chr_exe_location := 'DII_0012';
        l_stmt_processing  :=' Assing Values to the PLSQL Table ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_trx_header_tbl (l_count).trx_header_id       := l_trx_id;
        l_trx_header_tbl (l_count).bill_to_customer_id := l_party_id;
        l_trx_header_tbl (l_count).cust_trx_type_id    := l_trx_type_id;
        --l_trx_header_tbl (l_count).trx_date                := TRUNC (SYSDATE);
        l_trx_header_tbl (l_count).trx_date                := L_IRT_APPROVAL_DATE; --Added for Hotfix_199485 on 13-MAR-2019
        l_trx_header_tbl (l_count).term_id                 := g_term_id;
        l_trx_header_tbl (l_count).attribute1              := cur_dmd_header_rec.major_head;
        l_trx_header_tbl (l_count).attribute4              := cur_dmd_header_rec.assmt_year ;
        l_trx_header_tbl (l_count).attribute5              := cur_dmd_header_rec.customer_number;
        l_trx_header_tbl (l_count).attribute7              := cur_dmd_header_rec.schedule_type;
        l_trx_header_tbl (l_count).attribute9              := 'INT DMD';
        l_trx_header_tbl (l_count).attribute11             := cur_dmd_header_rec.irt_id;
        l_batch_source_rec.batch_source_id                 := l_batch_source_id;
        l_trx_lines_tbl (l_count).trx_header_id            := l_trx_id;
        l_trx_lines_tbl (l_count).trx_line_id              := l_trx_line_id;
        l_trx_lines_tbl (l_count).line_number              := 1;
        l_trx_lines_tbl (l_count).description              := l_memo_line_name;
        l_trx_lines_tbl (l_count).memo_line_id             := l_memo_line_id;
        l_trx_lines_tbl (l_count).quantity_invoiced        := 1;
        l_trx_lines_tbl (l_count).unit_selling_price       := cur_dmd_header_rec.dmd_interest_amount;
        l_trx_lines_tbl (l_count).line_type                := 'LINE';
        l_trx_lines_tbl (l_count).amount_includes_xx_flag := 'N';
        l_chr_exe_location                                 := 'DII_0013';
        l_stmt_processing                                  := ' Calling create_single_invoice API';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
        ar_invoice_api_pub.create_single_invoice (p_api_version => 1.0, p_init_msg_list => FND_API.G_TRUE, p_commit => FND_API.G_FALSE, p_batch_source_rec => l_batch_source_rec, p_trx_header_tbl => l_trx_header_tbl, p_trx_lines_tbl => l_trx_lines_tbl, p_trx_dist_tbl => l_trx_dist_tbl, p_trx_salescredits_tbl => l_trx_salescredits_tbl, x_customer_trx_id => x_customer_trx_id, x_return_status => x_return_status, x_msg_count => x_msg_count, x_msg_data => x_msg_data );
        write_debug( g_debug_flag ,'A-customer trx id '|| x_customer_trx_id );
        write_debug( g_debug_flag ,'A-cRETURN STATUS '|| x_return_status );
		dbms_output.put_line('A-customer trx id '|| x_customer_trx_id );
        dbms_output.put_line('A-cRETURN STATUS '|| x_return_status );
        IF x_return_status       = 'S' THEN
          l_trx_number          := NULL;
          l_payment_schedule_id := NULL;
          --Dmd Interest details fetch
          l_chr_exe_location := 'DII_0014';
          l_stmt_processing  :='Dmd Interest details fetch';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          SELECT rat.trx_number,
            arp.payment_schedule_id
          INTO l_trx_number,
            l_payment_schedule_id
          FROM ra_customer_trx_all rat,
            ar_payment_schedules_all arp
          WHERE rat.customer_trx_id = arp.customer_trx_id
          AND rat.customer_trx_id   = x_customer_trx_id;
          -- l_num_dmd_seq_num := l_num_dmd_seq_num + 1;
          --Dmd Interest Invoice population
          l_chr_exe_location := 'DII_0015';
          l_stmt_processing  :='Dmd Interest Invoice population';
          WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
		  dbms_output.put_line(l_chr_exe_location ||'-'|| l_stmt_processing );
          INSERT
          INTO xx_dmd_headers
            (
              irt_id,
              customer_trx_id,
              trx_number,
              id_number,
              irt_ay,
              major_head,
              irt_schedule_type,
              dmd_original_amount,
              avl_refd_adjust_amount,
              dmd_identify_amount,
              dmd_interest_amount,
              sec_code, -- Added by Neha on 05-DEC-2017 for Interest Section code population issue- Hotfix # 169695
              irt_returns_due_date,
              customer_trx_date,
              dmd_identified_date,
              dmd_service_date,
              dmd_status,
              dmd_interest_number,
              dmd_interest_status,
              payment_schedule_id,
              dmd_identification_number,
              last_updated_by,
              last_update_date,
              last_update_login,
              created_by,
              CREATION_DATE
            )
            VALUES
            (
              cur_dmd_header_rec.irt_id,
              x_customer_trx_id,
              l_trx_number,
              cur_dmd_header_rec.customer_number,
              cur_dmd_header_rec.assmt_year,
              cur_dmd_header_rec.major_head,
              cur_dmd_header_rec.schedule_type,
              cur_dmd_header_rec.dmd_interest_amount,
              cur_dmd_header_rec.dmd_interest_amount,
              cur_dmd_header_rec.dmd_interest_amount,
              0,
              DECODE(cur_dmd_header_rec.schedule_type,'DDT','115P','BBS','115QB','220(2)'), -- Added as part of CR#690 on 7-May-18
              --'220(2)', -- Added by Neha on 05-DEC-2017 for Interest Section code population issue- Hotfix # 169695
              cur_dmd_header_rec.irt_due_date,
              g_dte_sys_date,
              g_dte_sys_date,
              NULL,
              'INT DMD',
              NULL,
              NULL,
              l_payment_schedule_id,
              derive_din (l_chr_processing_yr, cur_dmd_header_rec.assmt_year, cur_dmd_header_rec.major_head, l_num_dmd_seq_num ),
              g_num_user_id,
              -- g_dte_sys_date,
              sysdate, --Changed from g_dte_sys_date to sysdate for CR_HWSW_0340
              g_num_login_id,
              g_num_user_id,
              G_DTE_SYS_DATE
            );
          --Dmd Interest Invoice Number update
          l_chr_exe_location := 'DII_0016';
          l_stmt_processing  :='Dmd Interest Invoice Number update';
          write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
          UPDATE xx_dmd_headers
          SET dmd_interest_number = x_customer_trx_id,
            dmd_interest_status   = 'FINAL'
          WHERE customer_trx_id      = cur_dmd_header_rec.customer_trx_id;
          --- start of changes for CR0530
          UPDATE xx_DMD_HEADERS hd
          SET ATTRIBUTE15       ='PENALTY INT DMD'
          WHERE CUSTOMER_TRX_ID = X_CUSTOMER_TRX_ID
          AND dmd_status     ='INT DMD'
          AND EXISTS
            (SELECT 1
            FROM xx_DMD_HEADERS LN
            WHERE DMD_INTEREST_NUMBER                = X_CUSTOMER_TRX_ID
            AND SUBSTR(DMD_IDENTIFICATION_NUMBER,9,2)='40'
            );
          --- end of changes for CR0530        
        ELSE
          IF x_msg_count > 1 THEN
            FOR i IN 1 .. x_msg_count
            LOOP
              p_out_chr_errbuff := p_out_chr_errbuff ||i|| '. '|| SUBSTR( fnd_msg_pub.get(p_encoded => fnd_api.g_false), 1,355 );
            END LOOP; --FOR i IN 1 .. x_msg_count
          ELSE
            p_out_chr_errbuff := x_msg_data;
          END IF; -- IF x_msg_count > 1
          IF x_return_status = fnd_api.g_ret_sts_error OR x_return_status = fnd_api.g_ret_sts_unexp_error THEN
            write_debug( g_debug_flag ,'unexpected errors found!');
            RAISE custom_exception;
          ELSE
            SELECT COUNT (*) INTO l_cnt FROM ar_trx_errors_gt;
            IF l_cnt = 0 THEN
              write_debug( g_debug_flag , 'Customer Trx id '|| x_customer_trx_id );
              RAISE custom_exception;
            ELSE
              write_debug( g_debug_flag , 'Transaction not Created, Please check ar_trx_errors_gt tbl');
			  dbms_output.put_line('Transaction not Created, Please check ar_trx_errors_gt tbl');
              RAISE custom_exception;
            END IF; --IF l_cnt = 0
          END IF;   --IF x_return_status = fnd_api.g_ret_sts_error
        END IF;     --IF x_return_status = 'S'
      EXCEPTION
      WHEN e_skip_calc THEN
        NULL;
      END;
    END LOOP;
    /* -- Moved to derive_din Function
    l_chr_exe_location := 'DII_0017';
    l_stmt_processing :='Update dmd_seq_num in xx_dmd_seq_ctrl ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_dmd_seq_ctrl
    SET dmd_seq_num = l_num_dmd_seq_num
    WHERE processing_year = l_chr_processing_yr;
    */
    write_debug( g_debug_flag , '*** Dmd Interest Invoice Creation Program - ENDS ***' );
  EXCEPTION
  WHEN custom_exception THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' || p_out_chr_errbuff;
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || L_CHR_EXE_LOCATION ||'-' || L_STMT_PROCESSING ||'-' ||SUBSTR(SQLERRM,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    l_stmt_processing := l_chr_errbuff;
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  END dmd_intinv;
--********************************** End of Procedure / Function **************
-- *********************
  PROCEDURE intdmd_refnd_adj_proc(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      p_in_irt_id   IN VARCHAR2,
      p_in_id_num  IN VARCHAR2,
      p_in_rrd_call IN VARCHAR2 DEFAULT NULL --added for CR_HWSW_102
    )
  AS
    /****************************************************************************
    ************
    * Type : Procedure
    * Name : intdmd_refnd_adj_proc
    * Input Parameters : p_in_irt_id, p_in_id_num
    * Output Parameters : out_chr_errbuff
    * out_chr_retcode
    * Purpose : Procedure to apply identified receipts to prior assmet year
    dmds
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 13-Jan-2012
    * Last Reviewed By :
    * Last Reviewed Date :
    *****************************************************************************
    **********
    * Modified Date Modified By Version Modification Type Modification Details
    * ------------- ------------ --------- -----------------
    --------------------------
    * 13-Jan-2012 Infosys 1.0 O Baseline.
    *****************************************************************************
    **********/
    --
    -- User defined exception for Commit with Warning
    --
    l_inv_amount               NUMBER;
    l_inv_refd_adjust_amount NUMBER;
    l_amount               NUMBER;
    l_apply_amount             NUMBER;
    l_writeoff_amount          NUMBER;
    l_month_diff               NUMBER;
    l_interest_calc_amt        NUMBER;
    l_apply_adjust_amount      NUMBER;
    l_amount_applied           NUMBER;
    l_total_adjust_amt         NUMBER;
    l_total_adjapp_amt         NUMBER;
    l_inv_amt_remaining        NUMBER;
    l_num_refd_seq_num       NUMBER;
    l_id_number               VARCHAR2(50);
    l_msg_count                NUMBER;
    l_count                    NUMBER;
    p_count                    NUMBER;
    l_msg_data                 VARCHAR2 (5000);
    l_return_status            VARCHAR2 (1);
    l_return_status2           VARCHAR2 (1);
    l_chr_exe_location         VARCHAR2(50) :='';
    l_stmt_processing          VARCHAR2(250);
    l_chr_proc_name            VARCHAR2 (50);
    l_num_ref_maj_head         VARCHAR2 (50) := NULL;
    l_chr_errbuff              VARCHAR2(5000);
    l_chr_retcode              VARCHAR2 (50);
    l_count_int_not_adjust     NUMBER; --#CR-644
    l_dmd_serv_date         DATE;
    l_max_to_month             DATE;
    v_400_rrd                  VARCHAR2(2); --variable for CR_HWSW_102
    e_skip_upd                 EXCEPTION;   --variable for CR_HWSW_102
    e_skip_subsequent_adj      EXCEPTION;   --variable for CR_HWSW_102
    l_application_ref_type ar_receivable_applications.application_ref_type%TYPE;
    l_application_ref_id ar_receivable_applications.application_ref_id%TYPE;
    l_application_ref_num ar_receivable_applications.application_ref_num%type;
    l_secondary_application_ref_id ar_receivable_applications.secondary_application_ref_id%TYPE;
    l_receivable_application_id ar_receivable_applications.receivable_application_id%type;
    l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
    LV_DMD_INT_AMT  xx_dmd_headers.Dmd_Interest_AMount%TYPE; --Added for CR_0761-Refd in Interim Status
    LV_Cal_DMD_INT_AMT  xx_dmd_headers.Dmd_Interest_AMount%TYPE; --Added for CR_0761-Refd in Interim Status
    CURSOR cur_no_dmd(p_in_irt_id IN VARCHAR2)
    IS
      SELECT head.reference_id,
        head.irt_id,
        head.id_number customer_number,
        head.irt_ay assmt_year,
        head.major_head,
        head.total_refd_amount
      FROM xx_refd_headers head
      WHERE head.refd_status = 'PCM APPROVED'
      AND head.irt_id          =p_in_irt_id
      AND NOT EXISTS
        (SELECT 1
        FROM xx_dmd_headers DMD
        WHERE DMD.id_number             = head.id_number
        AND DMD.avl_refd_adjust_amount > 0
        AND MAJOR_HEAD                     <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          -- AND TO_number (DMD.irt_ay) <= TO_number (head.irt_ay)--added
          -- for subsequent dmd to refd
        AND ( ( DMD.dmd_status    = 'DMD'
        AND DMD.dmd_service_date IS NOT NULL )
        OR ( DMD.DMD_STATUS       = 'INT DMD' ) )
        );
    CURSOR cur_dmd_inv(p_id_number IN VARCHAR2)
    IS
      SELECT DMD.customer_trx_id,
        DMD.trx_number,
        DMD.irt_ay assmt_year,
        DMD.id_number customer_number,
        DMD.avl_refd_adjust_amount amount_due_remaining,
        DMD.major_head,
        DMD.dmd_status status,
        DMD.irt_schedule_type schedule_type,
        DMD.irt_id,
        DMD.dmd_service_date dmd_serv_date,
        DMD.avl_refd_adjust_amount inv_refd_adjust_amount,
        DMD.irt_returns_due_date irt_due_date,
        DMD.customer_trx_date trx_date,
        dmd.payment_schedule_id,
        HEADER.irt_ay refd_irt_ay, --for CR_HWSW_102
        DMD.DMD_IDENTIFICATION_NUMBER DIN,--Added for CR_761-Refd In Interim Status
        DMD.SEC_CODE --Added for CR_761-Refd In Interim Status
      FROM xx_dmd_headers DMD,
        xx_refd_headers HEADER
      WHERE DMD.dmd_status          = 'INT DMD'
      AND DMD.avl_refd_adjust_amount > 0
      AND HEADER.id_number               = DMD.ID_number
      AND DMD.IRT_SCHEDULE_TYPE       <> 'FBB' --Added as a Part of
        -- Hotfix#92353 on 12-OCT-2015
        -- AND TO_NUMBER (HEADER.irt_ay) > TO_number (DMD.irt_ay)--added to
        -- adjust subsequent dmd to refd
      AND HEADER.refd_status                                                                                                    = 'PCM APPROVED'
      AND HEADER.approval_date                                                                                                   IS NOT NULL
      AND ( NVL (HEADER.total_refd_amount, 0) - NVL ( HEADER.refd_adjustment_amount, 0) - NVL (HEADER.net_refd_amount, 0) ) > 0
      AND HEADER.id_number                                                                                                       =p_id_number
      ORDER BY TO_NUMBER (DMD.irt_ay) ,
        TO_NUMBER (DMD.major_head) ,
        DMD.id_number ASC ,
        DMD.irt_schedule_type DESC;
    CURSOR cur_refd_header (in_customer_number IN VARCHAR2)
    IS
      SELECT head.reference_id,
        head.irt_id,
        head.id_number customer_number,
        head.irt_ay assmt_year,
        head.major_head,
        ( NVL (head.total_refd_amount, 0) - NVL (head.refd_adjustment_amount, 0) - NVL (head.net_refd_amount, 0) ) total_refd_amount,
        head.approval_date
      FROM xx_refd_headers head
      WHERE head.id_number                                                                                                = in_customer_number
      AND head.refd_status                                                                                               = 'PCM APPROVED'
      AND ( NVL (head.total_refd_amount, 0) - NVL (head.refd_adjustment_amount, 0) - NVL (head.net_refd_amount, 0) ) > 0
      ORDER BY head.reference_id;
    CURSOR cur_refd_line (in_num_reference_id IN NUMBER)
    IS
      SELECT line.reference_id,
        line.cash_receipt_id,
        line.receipt_ay,
        line.receipt_date,
        ( NVL (line.excess_receipt_amount, 0) - NVL ( line.refd_adjustment_amount, 0) - NVL (line.net_refd_amount, 0) + NVL (line.refd_roundoff_amount, 0) - NVL ( line.refd_crossadjust_amount, 0) - NVL (line.rr_refdemadj_amount, 0) ) amount,
        line.refd_adjustment_amount,
        line.net_refd_amount
      FROM xx_refd_lines line
      WHERE line.reference_id = in_num_reference_id
      ORDER BY line.reference_id,
        line.receipt_date,
        line.cash_receipt_id;
  BEGIN -- main program
    p_out_chr_errbuff := ' ';
    p_out_chr_retcode := g_chr_success_code;
    l_chr_proc_name   :='intdmd_refnd_adj_proc';
    write_debug( g_debug_flag , '*** Refd Adjustment for INT DMD with Current/Cross Assmt Year ***' );
    write_debug( g_debug_flag , ' Starts ');
    --- Generating refd_seq_no Sequence no
    l_chr_exe_location := 'IRAP_01';
    l_stmt_processing  := 'Generating refd_seq_no Sequence no';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    /*SELECT NVL (refd_seq_no, 6999999999)
    INTO l_num_refd_seq_num
    FROM xx_refd_seq_num; */
    -- Commented as part of Recomendation 3 from ACS
    --changes for CR_HWSW_102
    IF p_in_rrd_call IS NULL THEN
      v_400_rrd      := 'N';
      BEGIN
        SELECT 'Y'
        INTO v_400_rrd
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_400_rrd_int xri,
            ra_customer_trx_all rat
          WHERE rat.attribute5    = p_in_id_num
          AND rat.attribute8     IS NOT NULL
          AND rat.attribute9      = 'RR REF DEM'
          AND rat.customer_trx_id = xri.customer_trx_id
          AND XRI.CNV_FLAG        ='Y'--ADDED AS PART OF HOTFIX#140734
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_400_rrd := 'N';
      END;
    END IF;
    SELECT num_refd_seq.nextval INTO l_num_refd_seq_num FROM dual;
    --
    -- No dmd for that excess collection
    --
    BEGIN --for CR_HWSW_102
      FOR cur_no_dmd_rec IN cur_no_dmd(p_in_irt_id)
      LOOP
        l_chr_exe_location := 'IRAP_02';
        l_stmt_processing  := 'Upadting xx_refd_headers with Status ,refd and adjustment amount' ;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_id_number := cur_no_dmd_rec.customer_number;
        --changes for CR_HWSW_102
        IF p_in_rrd_call IS NULL AND v_400_rrd = 'Y' THEN
          raise e_skip_upd;
        END IF;
        UPDATE xx_refd_headers
        SET refd_status          = 'TO PAY IDENTIFIED',
          net_refd_amount        = NVL (total_refd_amount, 0) - NVL ( refd_adjustment_amount, 0),
          refd_adjustment_amount = NVL (refd_adjustment_amount, 0)
        WHERE reference_id         = cur_no_dmd_rec.reference_id;
      END LOOP; -- FOR cur_no_dmd_rec IN cur_no_dmd(p_in_irt_id)
    EXCEPTION
    WHEN e_skip_upd THEN
      NULL;
    END;
    FOR cur_dmd_inv_rec IN cur_dmd_inv(p_in_id_num)
    LOOP
      l_num_ref_maj_head := NULL;
      write_msg( g_write_logfile , ' **** ASST YEAR DMD ***** ' );
      write_msg( g_write_logfile , ' Invoice number :' || cur_dmd_inv_rec.trx_number );
      write_msg( g_write_logfile , ' Invoice Amt :' || cur_dmd_inv_rec.amount_due_remaining );
      write_msg( g_write_logfile , ' ID number :' || cur_dmd_inv_rec.customer_numbeR );
      write_msg( g_write_logfile , ' Assmt Year :' || cur_dmd_inv_rec.assmt_year );
      write_msg( g_write_logfile , ' Major Head :' || cur_dmd_inv_rec.major_head );
      l_inv_amount               := cur_dmd_inv_rec.amount_due_remaining;
      l_inv_refd_adjust_amount := cur_dmd_inv_rec.inv_refd_adjust_amount;
      l_amount               := 0;
      --l_num_refd_seq_num := l_num_refd_seq_num + 1;-- Commented as part of
      -- Recomendation 3 from ACS
      --changes for CR_HWSW_102 (to prevent subsequent year adjustment if RRD
      -- with 400 component exists)
      IF cur_dmd_inv_rec.assmt_year > cur_dmd_inv_rec.refd_irt_ay AND v_400_rrd = 'Y' AND p_in_rrd_call IS NULL THEN
        raise e_skip_subsequent_adj;
      END IF;
      SELECT num_refd_seq.nextval INTO l_num_refd_seq_num FROM dual;
      --
      -- Excess Identified receipt Start
      --
      FOR cur_refd_header_rec IN cur_refd_header ( cur_dmd_inv_rec.customer_number)
      LOOP
        l_msg_count                := NULL;
        l_msg_data                 := NULL;
        l_return_status            := NULL;
        l_apply_amount             := NULL;
        l_total_adjust_amt         := NULL;
        l_total_adjapp_amt         := NULL;
        l_dmd_serv_date         := NULL;
        l_inv_amount               := NULL;
        l_inv_refd_adjust_amount := NULL;
        p_count                    := NULL;
        l_count                    := NULL;
        l_month_diff               := 0;
        l_max_to_month             := NULL;
        l_chr_exe_location         := 'IRAP_03';
        l_stmt_processing          := 'Fetching avl_refd_adjust_amount from xx_dmd_headers ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        SELECT avl_refd_adjust_amount
        INTO l_interest_calc_amt
        FROM xx_dmd_headers
        WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
        AND MAJOR_HEAD       <> '0032'      --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
        AND dmd_status     ='INT DMD';--added on 4th may as program errors for
        -- duplicate trx id.
        IF l_interest_calc_amt = 0 THEN
          l_chr_exe_location  := 'IRAP_04';
          l_stmt_processing   := 'interest calc amount is 0 ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          EXIT; -- moving out loop if interest calc amount is 0 /***************/
        END IF;
        -- #CR-644 STARTS
        IF ( cur_dmd_inv_rec.amount_due_remaining>100) THEN
          SELECT COUNT(XDH.DMD_IDENTIFICATION_NUMBER)
          INTO l_count_int_not_adjust
          FROM xxcus.xx_DMD_HEADERS XDH
          WHERE XDH.ID_NUMBER          =cur_dmd_inv_rec.customer_number
          AND XDH.IRT_AY                =cur_dmd_inv_rec.assmt_year
          AND XDH.DMD_INTEREST_NUMBER=cur_dmd_inv_rec.customer_trx_id
          AND XDH.DMD_STATUS        IN ('CLOSED')
            -- AND XDH.DMD_STATUS IN ('DMD') commented for Hotfix#170382 on 09-JAN-2018
          AND XDH.MAJOR_HEAD <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          AND NOT EXISTS
            (SELECT 1
            FROM xxcus.IRT_NOTICE_US_245
            WHERE IRT_ID=cur_refd_header_rec.IRT_ID
            AND DIN     =XDH.DMD_IDENTIFICATION_NUMBER
            );
          IF l_count_int_not_adjust<>0 THEN
            EXIT;
          END IF;
        END IF;
        -- #CR-644 ENDS
        IF (l_num_ref_maj_head <> cur_refd_header_rec.major_head ) AND l_num_ref_maj_head IS NOT NULL THEN
          --l_num_refd_seq_num := l_num_refd_seq_num + 1;-- Commented as part
          -- of Recomendation 3 from ACS
          SELECT num_refd_seq.nextval
          INTO l_num_refd_seq_num
          FROM dual;
        END IF;
        l_num_ref_maj_head := cur_refd_header_rec.major_head;
        l_apply_amount     := NULL;
        l_chr_exe_location := 'IRAP_04_1';
        l_stmt_processing  := 'Fetching avl_refd_adjust_amount from xx_dmd_headers ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        SELECT avl_refd_adjust_amount
        INTO l_inv_amt_remaining
        FROM xx_dmd_headers
        WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
        AND MAJOR_HEAD       <> '0032'      --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
        AND dmd_status     ='INT DMD';--added on 4th may as program errors for
        -- duplicate trx id;
        IF l_inv_amt_remaining <= cur_refd_header_rec.total_refd_amount THEN
          l_apply_amount       := l_inv_amt_remaining;
        ELSE -- IF l_inv_amt_remaining <=
          -- cur_refd_header_rec.total_refd_amount
          l_apply_amount := cur_refd_header_rec.total_refd_amount;
        END IF; -- IF l_inv_amt_remaining <=
        -- cur_refd_header_rec.total_refd_amount
        l_chr_exe_location := 'IRAP_05';
        l_stmt_processing  := 'updating xx_refd_headers with refd_adjustment_amount ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        -- update xx_Refd_header refd_adjustment_amount
        UPDATE xx_refd_headers HEAD
        SET HEAD.refd_adjustment_amount = NVL (HEAD.refd_adjustment_amount, 0) + l_apply_amount
        WHERE HEAD.reference_id           = cur_refd_header_rec.reference_id;
        l_chr_exe_location               := 'IRAP_06';
        l_stmt_processing                := 'updating xx_dmd_headers with avl_refd_adjust_amount ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        -- update xx_dmd_headers avl_refd_adjust_amount
        UPDATE xx_dmd_headers
        SET avl_refd_adjust_amount = avl_refd_adjust_amount - l_apply_amount,
          --last_update_date           =g_dte_sys_date -- Added for AO Portal
          -- automation prem
          last_update_date = sysdate --Changed from g_dte_sys_date to sysdate for
          -- CR_HWSW_0340
        WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id;
        /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --START*/
        UPDATE xx_tot_overdue_details
        SET overdue_dem_amt =
          (SELECT avl_refd_adjust_amount
          FROM xx_dmd_headers
          WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id
          AND dmd_status    IN ('INT DMD') -- added for Hotfix_139914 to fix
            -- subquery returns multiple rows error
          )
        WHERE customer_trx_id = cur_dmd_inv_rec.customer_trx_id;
        /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --END*/
        -----Added for CR_761-Refd In Interim Status--START-----
              INSERT
              INTO xxcus.xx_INTERIM_DEM_DTLS
                (
                    IRT_ID, 
                    ID_NUMBER ,
                    IRT_AY ,
                    CUSTOMER_TRX_ID ,
                    DMD_IDENTIFICATION_NUMBER ,
                    ADJUSTED_DMD_AMOUNT ,
                    PROV_INT_DMD_AMT ,
                    DMD_TYPE ,
                    IRT_SCHEDULE_TYPE ,
                    SEC_CODE ,
                    REF_NUM ,
                    REF_IRT_ID ,
                    Program_Name ,
                    REFERENCE_ID ,
                    LAST_UPDATE_DATE 
                )
                VALUES
                (
                  cur_dmd_inv_rec.IRT_ID ,
                  cur_dmd_inv_rec.CUSTOMER_NUMBER ,
                  cur_dmd_inv_rec.ASSMT_YEAR ,
                  cur_dmd_inv_rec.CUSTOMER_TRX_ID ,
                  cur_dmd_inv_rec.DIN,
                  l_apply_amount,
                  NULL,
                  cur_dmd_inv_rec.STATUS,
                  cur_dmd_inv_rec.SCHEDULE_TYPE ,
                  cur_dmd_inv_rec.SEC_CODE ,
                  l_num_refd_seq_num,                  
                  cur_refd_header_rec.irt_id,
                  'IRT ACCOUNTING',
                  cur_refd_header_rec.reference_id,
                  SYSDATE

                );
                If(sql%ROWCOUNT>0) then
                 dbms_output.put_line('Record is inserted into table xx_INTERIM_DEM_DTLS 104'||sql%ROWCOUNT);
                 FND_FILE.put_line ( FND_FILE.LOG,'Record is inserted into table xx_INTERIM_DEM_DTLS 104'|| sql%ROWCOUNT) ;
                end If;
            -----Added for CR_761-Refd In Interim Status--END-------
        --Refd adjustment writeoff start
        FOR cur_refd_line_rec IN cur_refd_line ( cur_refd_header_rec.reference_id)
        LOOP
          l_writeoff_amount          := 0;
          l_msg_count                := NULL;
          l_return_status2           := NULL;
          l_attribute_rec.attribute2 := cur_dmd_inv_rec.customer_trx_id;
          l_attribute_rec.attribute4 := 'REFD ADJUSTMENT';
          l_attribute_rec.attribute1 := cur_refd_header_rec.major_head;
          l_attribute_rec.attribute3 := cur_refd_header_rec.assmt_year;
          l_attribute_rec.attribute5 := l_num_refd_seq_num;
          IF l_apply_amount           = 0 THEN
            l_chr_exe_location       := 'IRAP_07';
            l_stmt_processing        := 'Fetching avl_refd_adjust_amount from xx_dmd_headers ';
            write_debug( g_debug_flag ,l_chr_exe_location ||' - '|| l_stmt_processing );
          END IF; -- IF l_apply_amount = 0
          IF l_apply_amount   >= cur_refd_line_rec.amount THEN
            l_writeoff_amount := cur_refd_line_rec.amount;
          ELSE
            l_writeoff_amount := l_apply_amount;
          END IF;
          IF l_writeoff_amount <> 0 THEN
            --AR_RECEIPT_API_PUB.ACTIVITY_APPLICATION (p_api_version => 1.0 , p_init_msg_list => fnd_api.g_true ,p_commit => FND_API.G_FALSE , p_validation_level => fnd_api.g_valid_level_full ,x_return_status => l_return_status2 ,x_msg_count => l_msg_count ,x_msg_data => l_msg_data ,p_cash_receipt_id => cur_refd_line_rec.cash_receipt_id ,p_amount_applied => l_writeoff_amount ,p_apply_date => cur_refd_header_rec.approval_date ,p_apply_gl_date => g_dte_sys_date ,p_applied_payment_schedule_id => g_payment_schedule_id ,p_receivables_trx_id => g_receivables_trx_id , p_attribute_rec => l_attribute_rec ,p_application_ref_type => l_application_ref_type ,p_application_ref_id => l_application_ref_id ,p_application_ref_num => l_application_ref_num , p_secondary_application_ref_id => l_secondary_application_ref_id , p_receivable_application_id => l_receivable_application_id );  --Commented for Hotfix_199485 on 13-MAR-2019
            AR_RECEIPT_API_PUB.ACTIVITY_APPLICATION (p_api_version => 1.0 , p_init_msg_list => fnd_api.g_true ,p_commit => FND_API.G_FALSE , p_validation_level => fnd_api.g_valid_level_full ,x_return_status => l_return_status2 ,x_msg_count => l_msg_count ,x_msg_data => l_msg_data ,p_cash_receipt_id => cur_refd_line_rec.cash_receipt_id ,p_amount_applied => l_writeoff_amount ,p_apply_date => cur_refd_header_rec.approval_date ,p_apply_gl_date => cur_refd_header_rec.approval_date ,p_applied_payment_schedule_id => g_payment_schedule_id ,p_receivables_trx_id => g_receivables_trx_id , p_attribute_rec => l_attribute_rec ,p_application_ref_type => l_application_ref_type ,p_application_ref_id => l_application_ref_id ,p_application_ref_num => l_application_ref_num , p_secondary_application_ref_id => l_secondary_application_ref_id , p_receivable_application_id => l_receivable_application_id ); --Added for Hotfix_199485 on 13-MAR-2019
            write_msg( g_write_logfile , 'Apply receipt writeoff for receipt ID ' || cur_refd_line_rec.cash_receipt_id || ' for refd adjustment amount ' || l_writeoff_amount || ' - ' || l_return_status2 );
            IF l_return_status2  <> 'S' THEN
              l_chr_exe_location := 'IRAP_07_1';
              l_stmt_processing  := ' Receipt Write off API fails ';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing || l_msg_data);
              p_count := 1;
              LOOP
                p_out_chr_errbuff := p_out_chr_errbuff || '-' || fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false );
                IF l_msg_data     IS NULL THEN
                  EXIT;
                END IF; -- IF l_msg_data IS NULL
                p_out_chr_errbuff := NVL(p_out_chr_errbuff,l_msg_data ) ;
              END LOOP; -- LOOP
              p_out_chr_retcode := g_chr_failure_code ;
              write_msg( g_write_logfile , 'Message ' || ' ---' || p_out_chr_errbuff );
              Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
              IF l_chr_retcode = g_chr_failure_code THEN
                write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - ' || l_chr_errbuff);
              ELSE
                log_exception ( p_out_chr_errbuff => l_chr_errbuff , p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
                IF l_chr_retcode = g_chr_failure_code THEN
                  write_msg( g_write_logfile , ' Error also while writing error data of Procedure - ' || l_chr_proc_name);
                END IF; --IF l_out_chr_retcode = G
              END IF;
              RETURN;
            END IF; -- IF l_return_status2 <> 'S'
            l_chr_exe_location := 'IRAP_08';
            l_stmt_processing  := 'updating xx_refd_lines with refd_adjustment_amount ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            UPDATE xx_refd_lines line
            SET line.refd_adjustment_amount = NVL (line.refd_adjustment_amount, 0) + l_writeoff_amount
            WHERE line.reference_id           = cur_refd_line_rec.reference_id
            AND line.cash_receipt_id          = cur_refd_line_rec.cash_receipt_id;
            l_apply_amount                   := l_apply_amount - l_writeoff_amount;
          END IF; --IF l_writeoff_amount <> 0 THEN
        END LOOP; -- FOR cur_refd_line_rec IN cur_refd_line
        --Refd adjustment writeoff end
        l_count               := NULL;
        l_apply_adjust_amount := 0;
        l_amount_applied      := 0;
      END LOOP; -- FOR cur_refd_header_rec IN cur_refd_header
    END LOOP;   -- FOR cur_dmd_inv_rec in cur_dmd_inv(
    --- Upadating Upadating xx_refd_seq_num 
    --- Upadating xx_refd_headers with refd_status ,net_refd_amount,
    -- refd_adjustment_amount
    l_chr_exe_location := 'IRAP_10';
    l_stmt_processing  := 'Upadating xx_refd_headers with refd_status ,net_refd_amount,refd_adjustment_amount' ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_refd_headers head
    SET head.net_refd_amount      = NVL (head.total_refd_amount, 0) - NVL ( head.refd_adjustment_amount, 0),
      head.refd_adjustment_amount = NVL (head.refd_adjustment_amount, 0),
      HEAD.refd_status            = 'TO PAY IDENTIFIED'
    WHERE head.refd_status        = 'PCM APPROVED'
    AND head.irt_id                 = p_in_irt_id;
    WRITE_DEBUG( G_DEBUG_FLAG ,'No.of Rows updated in RH1 '||SQL%ROWCOUNT);
    --- Upadating xx_refd_headers with refd_status
    l_chr_exe_location := 'IRAP_11';
    l_stmt_processing  := 'Upadating xx_refd_headers with refd_status';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_refd_headers
    SET refd_status      = 'THRESHOLD LIMIT IDENTIFIED'
    WHERE refd_status    = 'TO PAY IDENTIFIED'
    AND net_refd_amount <= 100
    AND irt_id             = p_in_irt_id ;
    WRITE_DEBUG( G_DEBUG_FLAG ,'No.of Rows updated in RH2 '||SQL%ROWCOUNT);
  EXCEPTION
  WHEN e_skip_subsequent_adj THEN
    NULL;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name || '-' || l_chr_exe_location ||'-' ||l_stmt_processing ||'-' || SUBSTR(sqlerrm,1 ,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name || '-' ||l_chr_errbuff );
      END IF;
    END IF;
  END intdmd_refnd_adj_proc;
-- ***************** End of Function / Procedure **********************--
  PROCEDURE dmd_populate_proc(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      p_in_irt_id   IN VARCHAR2,
      p_in_rrd_call IN VARCHAR2 DEFAULT NULL -- for CR_HWSW_102
    )
  AS
    /****************************************************************************
    ****************************************
    * Type : Procedure
    * Name : DMD_POPULATE_PROC
    * Input Parameters : p_in_irt_id
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * Purpose : Procedure to apply invoice to receipts
    * * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 19-Jan-2012
    * Last Reviewed By : Infosys
    * Last Reviewed Date :
    *****************************************************************************
    ****************************************
    * Modified Date Modified By Version Modification Type Modification Details
    * ------------- ------------ -------- ----------------- ---------------------
    * 19-Jan-2012 Infosys 1.0 O Baseline.
    *****************************************************************************
    ****************************************/
    l_calc_status        NUMBER;
    l_roundoff_amount    NUMBER;
    l_status             NUMBER;
    l_dmd_amount      NUMBER;
    l_num_seq_num        NUMBER := 0;
    l_num_counter        NUMBER := 0;
    l_num_max_prev_amt   NUMBER := 0;
    l_num_existing_amt   NUMBER := 0;
    l_num_insert_count   NUMBER := 0;
    l_num_final_odd_amt  NUMBER := 0;
    l_num_dmd_seq_num NUMBER := 6999999999;
    l_orig_dem_due_date  DATE;
    l_dte_service_date   DATE := NULL;
    l_final_dem_due_date DATE := NULL;
    l_dte_cut_off_date   DATE := NULL;
    l_chr_errbuff        VARCHAR2 (5000);
    l_chr_retcode        VARCHAR2 (10);
    l_chr_processing_yr  VARCHAR2 (10);
    l_stmt_processing    VARCHAR2(200);
    out_err_msg          VARCHAR2 (2000);
    l_chr_proc_name      VARCHAR2(50) :='dmd_populate_proc';
    l_chr_exe_location   VARCHAR2(50) :='';
    l_char_din           VARCHAR2(50) :='';
    l_test_chk           NUMBER       := 0;
    --Start of hotfix#14570 --
    l_attr4 VARCHAR2(150);
    l_attr1 VARCHAR2(150);
    l_attr8 VARCHAR2(150);
    l_din   VARCHAR2(150);
    --End of hotfix#14570 --
    custom_exception EXCEPTION;
    L_REF_ADJ_AMT    NUMBER :=0; -- Added as part of CR#690 start -- DDT-BBS ABC changes 08-JUN-2018
    V_CUSTOMER_TRX_ID AR_RECEIVABLE_APPLICATIONS_ALL.ATTRIBUTE2%TYPE;
    V_DMD_STATUS xx_DMD_HEADERS.DMD_STATUS%type;
    V_AVL_REFD_ADJUST xx_DMD_HEADERS.AVL_REFD_ADJUST_AMOUNT%type;
    V_DOA xx_DMD_HEADERS.DMD_ORIGINAL_AMOUNT%TYPE;
    V_AVL_ref NUMBER := 0 ;
    v_cust    NUMBER;
    v_gl1     VARCHAR2(4000);
    v_gl2     VARCHAR2(4000);
    v_gl3     VARCHAR2(4000);
    --690 ends - 08-JUN-2018
    --changes for cr_tcm starts
    CURSOR C_DMND_1
    IS
      SELECT *
      FROM xx_DMD_HEADERS XDH
      WHERE IRT_ID     = P_IN_IRT_ID
      AND DMD_STATUS='DMD IDENTIFIED'
      AND IRT_ID NOT LIKE ('%#%')
      AND MAJOR_HEAD <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      AND NOT EXISTS
        (SELECT 1
        FROM xxcus.irt_ABC_xx_credit_mismatch TCM
        WHERE TCM.DMD_IDENTIFICATION_NUMBER=XDH.DMD_IDENTIFICATION_NUMBER
        AND tcm.customer_trx_id               =xdh.customer_trx_id
        );
    V_TCM_CASE          NUMBER       :=0;
    V_form_type_code      VARCHAR2(150):='';
    XX_CREDIT_FAIL_EXP EXCEPTION;
    V_XX_MISMATCH_AMT  NUMBER:=0;
    --changes for cr_tcm ends
  BEGIN
    p_out_chr_errbuff  := ' ';
    p_out_chr_retcode  := g_chr_success_code;
    l_chr_exe_location := 'DPP_0001';
    l_stmt_processing  := ' Identify Dmd for Custom Dmd Table population - STARTS ' ;
    write_debug( g_debug_flag ,l_stmt_processing );
	dbms_output.put_line(l_stmt_processing );
    write_debug( g_debug_flag ,'Program Request ID : ' || g_num_request_id );
    --Populate Identify Dmd
    l_chr_exe_location := 'DPP_0002';
    l_stmt_processing  :='Populate Identify Dmd';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    IF TO_NUMBER (TO_CHAR (SYSDATE, 'MM')) < 4 THEN
      l_chr_processing_yr                 := TO_CHAR (SYSDATE, 'RRRR') - 1;
    ELSE
      l_chr_processing_yr := TO_CHAR (SYSDATE, 'RRRR');
    END IF;

    l_chr_exe_location := 'DPP_0003';
    l_stmt_processing  :='Insert into xx_dmd_headers ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    INSERT
    INTO xx_dmd_headers
      (
        irt_id ,
        customer_trx_id ,
        trx_number ,
        id_number ,
        irt_ay ,
        major_head ,
        sec_code, -- Added  section code for Hotfix #169695 on 05-DEC-2017
        irt_schedule_type ,
        dmd_original_amount ,
        avl_refd_adjust_amount ,
        dmd_interest_amount ,
        irt_returns_due_date ,
        customer_trx_date ,
        dmd_identified_date ,
        dmd_service_date ,
        dmd_status ,
        dmd_interest_number ,
        dmd_interest_status ,
        payment_schedule_id ,
        dmd_identification_number ,
        last_updated_by ,
        last_update_date ,
        last_update_login ,
        created_by ,
        creation_date ,
        cust_trx_type_name
      )
    SELECT rat.attribute11 ,
      rat.customer_trx_id ,
      rat.trx_number ,
      rat.attribute5 ,
      rat.attribute4 ,
      rat.attribute1 ,
      ---start of Hotfix #169695 Added on 05-DEC-2017 -- added 'DDT','115O','BBS','115QA' for CR#690 on 7-May-18 ---start---
      DECODE(rat.attribute7 ,'DDT','115O','BBS','115QA',
      (SELECT "x_section_txt"
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM
      WHERE pcm."irt_id"=rat.attribute11
      )) sect_code,
      ----end of Hotfix #169695 Added on 05-DEC-2017 -- added 'DDT','115O','BBS','115QA' for CR#690 on 7-May-18 ---End---
      rat.attribute7 ,
      (SELECT ABS (arp.amount_due_remaining )
      FROM ar_payment_schedules_all arp
      WHERE arp.customer_trx_id = rat.customer_trx_id
      ) dmd_original_amount ,
      (SELECT ABS(arp.amount_due_remaining )
      FROM ar_payment_schedules_all arp
      WHERE arp.customer_trx_id = rat.customer_trx_id
      ) avl_refd_adj_amount ,
      0 ,
      TO_DATE (rat.attribute13, 'DD-MON-YYYY') ,
      rat.trx_date ,
      TO_DATE (rat.attribute3, 'DD-MON-YYYY'),
      NULL ,
      'DMD IDENTIFIED' ,
      NULL ,
      NULL ,
      (SELECT arp.payment_schedule_id
      FROM ar_payment_schedules_all arp
      WHERE arp.customer_trx_id = rat.customer_trx_id
      ) payment_schedule_id ,
      derive_din(l_chr_processing_yr -- Calling derive_din function
      ,rat.attribute4 ,rat.attribute1 ,l_num_dmd_seq_num + ROWNUM) ,
      g_num_user_id ,
      SYSDATE ,
      g_num_login_id ,
      g_num_user_id ,
      SYSDATE ,
      DECODE (rctta.attribute2, 'REVISED', 'REVISED', 'RECTIFICATION', 'RECTIFICATION', 'RR REFD RCVBL', 'RR REFD RCVBL', NULL )
    FROM ra_customer_trx_all rat ,
      ra_cust_trx_types_all rctta
    WHERE 1                             = 1
    AND rat.cust_trx_type_id            = rctta.cust_trx_type_id
    AND rat.attribute9                  = 'DMD'
    AND rat.attribute10                IS NULL
    AND rat.attribute8                 IS NULL
    AND rat.interface_header_attribute1 = p_in_irt_id ;
    l_num_insert_count                 := SQL%ROWCOUNT;
    -- l_num_dmd_seq_num := l_num_dmd_seq_num + l_num_insert_count;
    l_chr_exe_location := 'DPP_0004';
    l_stmt_processing  :='Insert into xx_dmd_headers ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing ||'row count: '||l_num_insert_count);
    --Start of hotfix#14570(Intimation Issue)--
    l_attr8:=NULL;
    BEGIN
      SELECT attribute4 ,
        attribute1,
        attribute8
      INTO l_attr4,
        l_attr1,
        l_attr8
      FROM ra_customer_trx_all
      WHERE attribute9                = 'DMD'
      AND attribute10                IS NULL
      AND attribute8                 IS NOT NULL
      AND interface_header_attribute1 = p_in_irt_id
      AND rownum                      =1;
    EXCEPTION
    WHEN No_Data_Found THEN
      l_attr8:=NULL;
    END;
    IF l_attr8 IS NOT NULL THEN
      l_din    :=derive_din (l_chr_processing_yr -- Calling derive_din function
      ,l_attr4,l_attr1,l_num_dmd_seq_num);
	  dbms_output.put_line('l_din : '||l_din);
    END IF;
    --End of hotfix#14570--
    BEGIN
      FOR rec IN
      (SELECT NVL(ABS(arp.amount_due_remaining ), 0) amt
        -- INTO l_rrd_amt
      FROM AR_PAYMENT_SCHEDULES_ALL ARP,
        ra_customer_trx_all rat
      WHERE arp.customer_trx_id           = rat.customer_trx_id
      AND rat.attribute9                  = 'DMD'
      AND rat.attribute10                IS NULL
      AND RAT.ATTRIBUTE8                 IS NOT NULL
      AND rat.interface_header_attribute1 = p_in_irt_id
      )
      LOOP
        write_debug( g_debug_flag ,'rec.amt '||rec.amt);
      END LOOP;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      write_debug( g_debug_flag ,'No data found for amount_due_remaining: '|| SQLERRM);
	  dbms_output.put_line('No data found for amount_due_remaining: '|| SQLERRM);
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Error deriving RRD Amt: '||SQLERRM);
	  dbms_output.put_line('Error deriving RRD Amt: '||SQLERRM);
    END;
    BEGIN
      FOR i IN
      (SELECT arp.payment_schedule_id payment_schedule_id
      FROM ar_payment_schedules_all arp,
        ra_customer_trx_all rat
      WHERE arp.customer_trx_id           = rat.customer_trx_id
      AND rat.interface_header_attribute1 = p_in_irt_id
      )
      LOOP
        write_debug( g_debug_flag ,'i.payment_schedule_id '|| i.payment_schedule_id);
      END LOOP;
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Error deriving payment schedule id: '||SQLERRM) ;
    END;
    write_debug( g_debug_flag ,'l_rrd_amt ');
    BEGIN --Added for debugging
      SELECT COUNT(1)
      INTO l_test_chk
      FROM xx_dmd_headers xdh,
        ra_customer_trx_all rat
      WHERE xdh.irt_id          = rat.attribute11
      AND xdh.id_number        = rat.attribute5
      AND xdh.irt_ay            = rat.attribute4
      AND xdh.major_head        = rat.attribute1
      AND xdh.irt_schedule_type = rat.attribute7
      AND xdh.dmd_status     = 'DMD IDENTIFIED'
      AND xdh.irt_id            = p_in_irt_id
      AND xdh.MAJOR_HEAD       <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Error debugging '||SQLERRM);
    END;
    write_debug( g_debug_flag ,'l_test_chk '||l_test_chk);
    l_num_insert_count := 0;
    INSERT
    INTO xx_dmd_headers
      (
        irt_id ,
        customer_trx_id ,
        trx_number ,
        id_number ,
        irt_ay ,
        major_head ,
        sec_code, -- Added by Neha for Hotfix# 169695 on 05-DEC-2017
        irt_schedule_type ,
        dmd_original_amount ,
        avl_refd_adjust_amount ,
        dmd_interest_amount ,
        irt_returns_due_date ,
        customer_trx_date ,
        dmd_identified_date ,
        dmd_service_date ,
        dmd_status ,
        dmd_interest_number ,
        dmd_interest_status ,
        payment_schedule_id ,
        dmd_identification_number ,
        last_updated_by ,
        last_update_date ,
        last_update_login ,
        created_by ,
        creation_date ,
        cust_trx_type_name
      )
    SELECT rat.attribute11 ,
      rat.customer_trx_id ,
      rat.trx_number ,
      rat.attribute5 ,
      rat.attribute4 ,
      rat.attribute1 ,
      --added 'DDT','115O','BBS','115QA' for CR#690 on 7-May-18 ---start---
      DECODE(rat.attribute7 ,'DDT','115O','BBS','115QA',
      (SELECT "x_section_txt"
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM
      WHERE pcm."irt_id"=rat.attribute11
      )) sect_code, -- Added by Neha for Hotfix# 169695 on 05-DEC-2017
      --added 'DDT','115O','BBS','115QA' for CR#690 on 7-May-18 ---End---
      rat.attribute7 ,
      (SELECT ABS(arp.amount_due_remaining )
      FROM ar_payment_schedules_all arp
      WHERE arp.customer_trx_id = rat.customer_trx_id
      ) dmd_original_amount ,
      (SELECT ABS(arp.amount_due_remaining )
      FROM ar_payment_schedules_all arp
      WHERE arp.customer_trx_id = rat.customer_trx_id
      ) avl_refd_adj_amount ,
      0 ,
      TO_DATE (rat.attribute13, 'DD-MON-YYYY') ,
      rat.trx_date ,
      TO_DATE (rat.attribute3, 'DD-MON-YYYY'),
      NULL ,
      'DMD IDENTIFIED' ,
      NULL ,
      NULL ,
      (SELECT arp.payment_schedule_id
      FROM ar_payment_schedules_all arp
      WHERE arp.customer_trx_id = rat.customer_trx_id
      ) payment_schedule_id ,
      NVL (
      (SELECT dmd_identification_number
      FROM xx_dmd_headers xdh
      WHERE xdh.irt_id          = rat.attribute11
      AND xdh.id_number        = rat.attribute5
      AND xdh.irt_ay            = rat.attribute4
      AND xdh.major_head        = rat.attribute1
      AND xdh.irt_schedule_type = rat.attribute7
      AND xdh.dmd_status     = 'DMD IDENTIFIED'
      ) ,
      /*derive_din (l_chr_processing_yr -- Calling derive_din function
      ,rat.attribute4 ,rat.attribute1 ,l_num_dmd_seq_num + ROWNUM )*/
      --commented for hotfix#14570
      l_din ) ,--added for hotfix#14570--
      g_num_user_id ,
      SYSDATE ,
      g_num_login_id ,
      g_num_user_id ,
      SYSDATE ,
      DECODE (rctta.attribute2, 'REVISED', 'REVISED', 'RECTIFICATION', 'RECTIFICATION', 'RR REFD RCVBL', 'RR REFD RCVBL', NULL )
    FROM ra_customer_trx_all rat,
      ra_cust_trx_types_all rctta
    WHERE 1                             = 1
    AND rat.cust_trx_type_id            = rctta.cust_trx_type_id
    AND rat.attribute9                  = 'DMD'
    AND rat.attribute10                IS NULL
    AND rat.attribute8                 IS NOT NULL
    AND rat.interface_header_attribute1 = p_in_irt_id ;
    l_num_insert_count                 := SQL%ROWCOUNT;
    l_chr_exe_location                 := 'DPP_0005';
    l_stmt_processing                  :='Insert into xx_dmd_headers ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing ||' '||l_num_insert_count);
    /* -- MOved to Derive Din function
    UPDATE xx_dmd_seq_ctrl
    SET dmd_seq_num = l_num_dmd_seq_num + l_num_insert_count
    WHERE processing_year = l_chr_processing_yr;
    */
    write_debug( g_debug_flag , 'No of Dmd identified records population in custom table : '|| l_num_insert_count );
    --updating dem headers with FAS DMD HOLD
    l_chr_exe_location := 'DPP_0006';
    -- Added as part of CR#690 on -08-JUN-2018 --DDT-BBS ABC changes -- starts --add also for CR_661 on 31-Jan-2019--start--
    SELECT SUM(NVL(REFD_CROSSADJUST_AMOUNT,0))
    INTO l_ref_adj_amt
    FROM xx_REFD_LINES
    WHERE REFERENCE_ID IN
      (SELECT REFERENCE_ID
      FROM xx_REFD_HEADERS
      WHERE IRT_ID           = p_in_irt_id
      AND irt_schedule_type <> 'FBT'
      );
    IF L_REF_ADJ_AMT > 0 THEN
      FOR I IN
      (SELECT A.CASH_RECEIPT_ID,
        A.REFD_CROSSADJUST_AMOUNT,
        A.MINOR_HEAD,
        B.MAJOR_HEAD,
        B.IRT_AY
      FROM xx_REFD_LINES A,
        xx_REFD_HEADERS B
      WHERE A.REFERENCE_ID                    = B.REFERENCE_ID
      AND B.IRT_ID                            = P_IN_IRT_ID
      AND NVL(A.REFD_CROSSADJUST_AMOUNT, 0) > 0
      AND b.irt_schedule_type                <> 'FBT'
      )
      LOOP
        WRITE_DEBUG( G_DEBUG_FLAG ,' CASH_RECEIPT_ID: '||i.CASH_RECEIPT_ID);
        WRITE_DEBUG( G_DEBUG_FLAG ,' REFD_CROSSADJUST_AMOUNT: '||i.REFD_CROSSADJUST_AMOUNT);
        WRITE_DEBUG( G_DEBUG_FLAG ,' MINOR_HEAD: '||I.MINOR_HEAD);
        WRITE_DEBUG( G_DEBUG_FLAG ,' MAJOR_HEAD: '||i.MAJOR_HEAD);
        WRITE_DEBUG( G_DEBUG_FLAG ,' IRT_AY: '||i.IRT_AY);
        FOR J IN
        (SELECT ATTRIBUTE2,
          amount_applied
        FROM AR_RECEIVABLE_APPLICATIONS_ALL
        WHERE CASH_RECEIPT_ID = I.CASH_RECEIPT_ID
          --AND ATTRIBUTE4                  = 'CROSS HEAD ADJUSTED' -- Added on 28-MAY-2018, aDDED ON 31-MAY-2018
        AND ATTRIBUTE4                 IN ('115TD CROSSHEAD ADJUSTED','CROSS HEAD ADJUSTED') --added for CR_661 on 31-Jan-2019
        AND ATTRIBUTE3                  = I.IRT_AY
        AND ATTRIBUTE1                  = I.MAJOR_HEAD
        AND APPLIED_PAYMENT_SCHEDULE_ID = -3
        AND DISPLAY                     = 'Y'
        AND status                      = 'ACTIVITY'
        )
        LOOP
          WRITE_DEBUG( G_DEBUG_FLAG ,' V_CUSTOMER_TRX_ID: '||J.ATTRIBUTE2);
          WRITE_DEBUG( G_DEBUG_FLAG ,'amount_applied: '||J.AMOUNT_APPLIED);
		  dbms_output.put_line(' V_CUSTOMER_TRX_ID: '||J.ATTRIBUTE2);
          dbms_output.put_line('amount_applied: '||J.AMOUNT_APPLIED);
          UPDATE xx_DMD_HEADERS XDH
          SET AVL_REFD_ADJUST_AMOUNT = AVL_REFD_ADJUST_AMOUNT - J.AMOUNT_APPLIED
          WHERE CUSTOMER_TRX_ID        = j.ATTRIBUTE2
          AND DMD_STATUS            = 'DMD IDENTIFIED'
          AND XDH.IRT_ID               = P_IN_IRT_ID;
          WRITE_DEBUG( G_DEBUG_FLAG ,'Rows updated in DH '||SQL%ROWCOUNT);
		  dbms_output.put_line('Rows updated in DH '||SQL%ROWCOUNT);
          SELECT AVL_REFD_ADJUST_AMOUNT
          INTO V_AVL_ref
          FROM xx_DMD_HEADERS
          WHERE CUSTOMER_TRX_ID = j.ATTRIBUTE2
          AND DMD_STATUS     = 'DMD IDENTIFIED'
          AND IRT_ID            = P_IN_IRT_ID;
          WRITE_DEBUG( G_DEBUG_FLAG ,'V_AVL_ref '||V_AVL_ref);
		  dbms_output.put_line('V_AVL_ref '||V_AVL_ref);
        END LOOP; -- loop for ara
      END LOOP;   -- loop for RL+RH
    END IF;       --L_REF_ADJ_AMT > 0
    -- Added as part of CR#690 on 08-JUN-2018 -- ends --add also for CR_661 on 31-Jan-2019--end--
    l_stmt_processing :='Updating xx_dmd_headers with FAS DMD HOLD';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    FOR i IN
    (SELECT xdh.customer_trx_id,
      rct.GLOBAL_ATTRIBUTE1,
      rct.global_attribute2,
      rct.global_attribute3
      -- into v_cust, v_gl1, v_gl2, v_gl3
    FROM xx_dmd_headers xdh,
      RA_CUSTOMER_TRX_ALL RCT
    WHERE dmd_status     = 'DMD IDENTIFIED'
    AND xdh.irt_id          = p_in_irt_id
    AND RCT.ATTRIBUTE11     =XDH.IRT_ID
    AND RCT.CUSTOMER_TRX_ID =XDH.CUSTOMER_TRX_ID
    )
    LOOP
      write_debug( g_debug_flag ,'v_cust: ' ||i.customer_trx_id||' v_gl1'||i.global_attribute1||' v_gl2'||i.global_attribute2||' v_gl3'||i.global_attribute3);
    END LOOP; -- 21-May-12 Included the changes in Old
    UPDATE xx_dmd_headers xdh
    SET dmd_status   = 'FAS DMD HOLD IDENTIFIED'
    WHERE dmd_status = 'DMD IDENTIFIED'
    AND xdh.irt_id      = p_in_irt_id
    AND ( EXISTS
      (SELECT 1
      FROM xx_irt_fas_prcsng_hold xifph
      WHERE xifph.irt_id      = xdh.irt_id
      AND xifph.hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
      AND xifph.release_flag IS NULL
      )
    OR EXISTS
      (SELECT 1
      FROM RA_CUSTOMER_TRX_ALL RCT
      WHERE RCT.ATTRIBUTE11     =XDH.IRT_ID
      AND RCT.GLOBAL_ATTRIBUTE1 >0
      AND RCT.ATTRIBUTE7        =XDH.IRT_SCHEDULE_TYPE
      AND RCT.CUSTOMER_TRX_ID   =XDH.CUSTOMER_TRX_ID -- 21-May-12 Included
        -- the changes in Old code
        -- Added on 09/03/2012 to bypass FAS DMD HOLD for prior refd
        -- records
      AND RCT.ATTRIBUTE8 IS NULL -- 21-May-12 Included the changes in Old
        -- code
      ) );
    write_debug( g_debug_flag ,'No. of rows updated on HOLD'||'-'||sql%rowcount);
	dbms_output.put_line('No. of rows updated on HOLD'||'-'||sql%rowcount);
    ---changes for Xx Credit Mismatch cases update starts --cr_tcm
    l_chr_exe_location := 'DPP_0006.1';
    l_stmt_processing  :='Status update for Xx Credit Mismatch cases';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    BEGIN--1
      WRITE_DEBUG( G_DEBUG_FLAG ,'entering cr_tcm');
      FOR C_TCM IN C_DMND_1
      LOOP--1
        WRITE_DEBUG( G_DEBUG_FLAG ,'in for loop');
        BEGIN  --2
          BEGIN--3
            SELECT "form_type_code"
            INTO V_form_type_code
            FROM "process_store"."irt_process_control_mstr"@psql_process_fas
            WHERE "irt_id"=C_TCM.IRT_ID;
            WRITE_DEBUG( G_DEBUG_FLAG ,' V_form_type_code: '||V_form_type_code);
			dbms_output.put_line(' V_form_type_code: '||V_form_type_code);
          EXCEPTION
          WHEN OTHERS THEN
            WRITE_DEBUG( G_DEBUG_FLAG ,'SOMETHING IS WRONG WITH form_type_code');
            P_OUT_CHR_ERRBUFF:='SOMETHING IS WRONG WITH form_type_code'||SUBSTR( sqlerrm,1,255);
            RAISE XX_CREDIT_FAIL_EXP;
          END ;--3
          IF (V_form_type_code=1) THEN
		  BEGIN
            SELECT COUNT(1),
              (ITTL."tp_tot_xxs_paid_amt"-ITTLP."tp_tot_xxs_paid_amt")
            INTO V_TCM_CASE,
              V_XX_MISMATCH_AMT
            FROM "efile"."irt_irt1_xx_liab"@psql_process_fas ITTL,
              "process_store"."irt_irt1_xx_liab_prcssd"@psql_process_fas ITTLP
            WHERE ITTL."irt_id"                                             =C_TCM.IRT_ID
            AND ITTL."irt_id"                                               =ITTLP."irt_id"
            AND ( ITTL."tp_tot_xxs_paid_amt"    -ITTLP."tp_tot_xxs_paid_amt" ) >100
            GROUP BY (ITTL."tp_tot_xxs_paid_amt"-ITTLP."tp_tot_xxs_paid_amt");
            WRITE_DEBUG( G_DEBUG_FLAG ,'if block -- V_TCM_CASE: '||V_TCM_CASE);
			dbms_output.put_line('if block -- V_TCM_CASE: '||V_TCM_CASE);
			EXCEPTION
			WHEN NO_DATA_FOUND THEN 
			DBMS_OUTPUT.PUT_LINE('No data in either irt_irt1_xx_liab or irt_irt1_xx_liab_prcssd');
			END;
          ELSE
           SELECT COUNT(1),
              (ITLT."tp_xx_paid_tot_amt"-ITLTP."tp_xx_paid_tot_amt")
            INTO V_TCM_CASE,
              V_XX_MISMATCH_AMT
            FROM "efile"."irt_xx_lia_tot_incm"@psql_process_fas ITLT,
              "process_store"."irt_xx_lia_tot_incm_prcssd"@psql_process_fas ITLTP
            WHERE ITLT."efile_id"                                           =C_TCM.IRT_ID
            AND ITLT."efile_id"                                             =ITLTP."irt_id"
            AND ( ITLT."tp_xx_paid_tot_amt"    -ITLTP."tp_xx_paid_tot_amt" ) >100
            GROUP BY (ITLT."tp_xx_paid_tot_amt"-ITLTP."tp_xx_paid_tot_amt");
            WRITE_DEBUG( G_DEBUG_FLAG ,'else block -- V_TCM_CASE: '||V_TCM_CASE);
          END IF;
          WRITE_DEBUG( G_DEBUG_FLAG ,'V_TCM_CASE: '||V_TCM_CASE);
          IF(V_TCM_CASE>0) THEN
            WRITE_DEBUG( G_DEBUG_FLAG ,'INSERT INTO IRT_ABC_XX_CREDIT_MISMATCH') ;
			dbms_output.put_line('INSERT INTO IRT_ABC_XX_CREDIT_MISMATCH') ;
            BEGIN--4
              INSERT
              INTO xxcus.IRT_ABC_XX_CREDIT_MISMATCH
                (
                  ID_NUMBER,
                  IRT_AY,
                  IRT_ID,
                  CUSTOMER_TRX_ID,
                  DMD_IDENTIFICATION_NUMBER,
                  XX_MISMATCH_AMT
                )
                VALUES
                (
                  C_TCM.ID_NUMBER,
                  C_TCM.IRT_AY,
                  C_TCM.IRT_ID,
                  C_TCM.CUSTOMER_TRX_ID,
                  C_TCM.DMD_IDENTIFICATION_NUMBER,
                  V_XX_MISMATCH_AMT
                );
              UPDATE xx_dmd_headers
              SET attribute13  ='TCM'
              WHERE IRT_ID     =C_TCM.IRT_ID
              AND DMD_STATUS='DMD IDENTIFIED';
            EXCEPTION
            WHEN OTHERS THEN
              WRITE_DEBUG( G_DEBUG_FLAG ,'Exception is '||SQLERRM);
              P_OUT_CHR_ERRBUFF:= 'ERROR WHILE INSERTING INTO XX CREDIT MISMATCH or updating dmd headers' ||SUBSTR(SQLERRM,1,255);
			  dbms_output.put_line(P_OUT_CHR_ERRBUFF);
              RAISE XX_CREDIT_FAIL_EXP;
            END;--4
          END IF;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          WRITE_DEBUG( G_DEBUG_FLAG ,'Not a TCM Case');
        WHEN XX_CREDIT_FAIL_EXP THEN
          WRITE_DEBUG( G_DEBUG_FLAG ,'Exception is '||SQLERRM);
          P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
        WHEN OTHERS THEN
          WRITE_DEBUG( G_DEBUG_FLAG ,'Exception is '||SQLERRM);
          P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
          P_OUT_CHR_ERRBUFF := 'ERROR WHILE INSERTING INTO XX CREDIT MISMATCH or updating dmd headers' ||SUBSTR(SQLERRM,1,255);
        END;   --2
      END LOOP;--1
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Exception is '||SQLERRM);
      p_out_chr_retcode := g_chr_failure_code;
      P_OUT_CHR_ERRBUFF := 'Error in procedure ' ||'updating for tcm'|| '-' || SUBSTR(SQLERRM,1,255);
    END;--1
    ---changes for Xx Credit Mismatch cases update ends --cr_tcm
    --Status update for dmd identified data
    l_chr_exe_location := 'DPP_0007';
    l_stmt_processing  :='Status update for dmd identified data';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE ra_customer_trx_all
    SET attribute9                  = 'DMD IDENTIFIED'
    WHERE attribute9                = 'DMD'
    AND attribute10                IS NULL
    AND interface_header_attribute1 = p_in_irt_id ;
    write_debug( g_debug_flag , 'Status update for no of Dmd idenfied records: '|| SQL%ROWCOUNT);
	dbms_output.put_line('Status update for no of Dmd idenfied records: '|| SQL%ROWCOUNT);
    FOR j IN
    (SELECT customer_trx_id,
      dmd_original_amount,
      irt_ay,
      major_head
    FROM xx_dmd_headers
    WHERE dmd_status IN ('DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED')
    AND irt_id           = p_in_irt_id
    AND MAJOR_HEAD      <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    AND p_in_rrd_call   IS NULL
    UNION
    SELECT customer_trx_id,
      dmd_original_amount,
      irt_ay,
      major_head
    FROM xx_dmd_headers xdh
    WHERE dmd_status   IN ('DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED')
    AND irt_id             = p_in_irt_id
    AND MAJOR_HEAD        <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    AND CUST_TRX_TYPE_NAME = 'RR REFD RCVBL'
    AND p_in_rrd_call      = 'E400'
    AND EXISTS
      (SELECT 1
      FROM xx_400_rrd_int xri
      WHERE xri.customer_trx_id = xdh.customer_trx_id
      AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
      )
    ) -- cursor chaned for CR_HWSW_102
    LOOP
      l_dmd_amount    := NULL;
      l_roundoff_amount  := NULL;
      l_status           := NULL;
      l_chr_exe_location := 'DPP_0008';
      l_stmt_processing  :='Calling roundoff_calc function';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      l_status               := roundoff_calc (j.dmd_original_amount, l_dmd_amount, l_roundoff_amount );
      IF l_status             = 0 THEN
        l_chr_errbuff        := NULL;
        l_chr_retcode        := NULL;
        IF l_roundoff_amount <> 0 THEN
          l_chr_exe_location := 'DPP_0009';
          l_stmt_processing  :='Calling adjust_proc procedure';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          adjust_proc ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,in_num_customer_trx_id => j.customer_trx_id , in_num_adjust_amount => l_roundoff_amount ,in_chr_major_head => j.major_head ,in_chr_assmt_year => j.irt_ay );
          IF l_chr_retcode    <> '0' THEN
            p_out_chr_errbuff := l_chr_errbuff;
            write_debug( g_debug_flag , 'Error in Dmd Round off amount adjustment creation : ' || l_chr_errbuff );
            RAISE custom_exception;
          END IF; -- IF l_chr_retcode <> '0'
        END IF;   -- IF l_roundoff_amount <> 0
        l_chr_exe_location := 'DPP_0010';
        l_stmt_processing  :='Dmd identify/Roundoff update';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        --Dmd identify/Roundoff update
        UPDATE xx_dmd_headers
        SET --avl_refd_adjust_amount = l_dmd_amount, -- Commented for CR - 690 on 30-MAY-2018 --add for CR_661 on 31-Jan-2019
          AVL_REFD_ADJUST_AMOUNT = (
          CASE
            WHEN NVL(AVL_REFD_ADJUST_AMOUNT, 0) = DMD_ORIGINAL_AMOUNT
            THEN L_DMD_AMOUNT
            ELSE avl_refd_adjust_amount
          END), -- Added for CR - 690 on 29-MAY-2018 --add for CR_661 on 31-Jan-2019
          dmd_identify_amount = l_dmd_amount,
          dmd_roundoff_amount = l_roundoff_amount
        WHERE customer_trx_id    = j.customer_trx_id;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| 'WHILE UPDATING DMD HEADERS' );
		dbms_output.put_line(l_chr_exe_location ||'-'|| 'WHILE UPDATING DMD HEADERS' );
        /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --START*/
        UPDATE xx_tot_overdue_details
        SET overdue_dem_amt =
          (SELECT avl_refd_adjust_amount
          FROM xx_dmd_headers
          WHERE customer_trx_id = j.customer_trx_id
          AND dmd_status    IN ('DMD IDENTIFIED', 'FAS DMD HOLD IDENTIFIED') -- added for Hotfix_139914 to fix
            -- subquery returns multiple rows error
          )
        WHERE customer_trx_id = j.customer_trx_id;
        /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --END*/
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| 'xx_tot_overdue_details' );
		dbms_output.put_line(l_chr_exe_location ||'-'|| 'xx_tot_overdue_details' );
      ELSE
        write_debug( g_debug_flag , 'Error in Dmd identify/Roundoff calculation : '|| SQLERRM );
        p_out_chr_errbuff := 'Error in Dmd identify/Roundoff calculation : ';
        RAISE custom_exception;
      END IF; --IF l_status = 0
    END LOOP; --FOR j IN (SELECT customer_trx_id, dmd_original_amount, irt_ay,
    FOR j IN
    (SELECT customer_trx_id ,
      dmd_original_amount ,
      irt_ay ,
      major_head ,
      cust_trx_type_name ,
      avl_refd_adjust_amount ,
      irt_id ,
      irt_schedule_type ,
      id_number ,
      dmd_status
    FROM xx_dmd_headers
    WHERE dmd_status       IN ('DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED')
    AND dmd_identify_amount > 0
    AND cust_trx_type_name    IN ('REVISED', 'RECTIFICATION', 'RR REFD RCVBL' )
    AND irt_id                 = p_in_irt_id
    AND MAJOR_HEAD            <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    AND p_in_rrd_call         IS NULL
    UNION
    SELECT customer_trx_id ,
      dmd_original_amount ,
      irt_ay ,
      major_head ,
      cust_trx_type_name ,
      avl_refd_adjust_amount ,
      irt_id ,
      irt_schedule_type ,
      id_number ,
      dmd_status
    FROM xx_dmd_headers xdh
    WHERE dmd_status       IN ('DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED')
    AND dmd_identify_amount > 0
    AND cust_trx_type_name     = 'RR REFD RCVBL'
    AND irt_id                 = p_in_irt_id
    AND MAJOR_HEAD            <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    AND p_in_rrd_call          = 'E400'
    AND EXISTS
      (SELECT 1
      FROM xx_400_rrd_int xri
      WHERE xri.customer_trx_id = xdh.customer_trx_id
      AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
      )
    ) -- cursor changed for CR_HWSW_102
    LOOP
      l_chr_exe_location := 'DPP_0011';
      l_stmt_processing  :='deleting prev dem xx_prev_dem_details_gtt';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      DELETE FROM xx_prev_dem_details_gtt;
      l_chr_exe_location := 'DPP_0012';
      l_stmt_processing  :='Insert into xx_prev_dem_details_gtt ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO xx_prev_dem_details_gtt xpddg
        (
          amount_due_remaining ,
          dmd_due_date ,
          customer_trx_id ,
          new_customer_trx_id ,
          irt_id ,
          dmd_identified_date ,
          irt_type ,
          irt_return_type ,
          dmd_status
        )
      SELECT DMD.dmd_identify_amount ,
        DMD.dmd_due_date ,
        DMD.customer_trx_id ,
        j.customer_trx_id ,
        DMD.irt_id ,
        DMD.dmd_identified_date ,
        'DMD' ,
        DMD.cust_trx_type_name ,
        DMD.dmd_status
      FROM xx_dmd_headers DMD
      WHERE DMD.id_number                              = j.id_number
      AND DMD.major_head                                = j.major_head
      AND DMD.irt_schedule_type                         = j.irt_schedule_type
      AND DMD.irt_ay                                    = j.irt_ay
      AND DMD.dmd_status                             = 'RR DEM CANCEL'
      AND j.cust_trx_type_name                            IN('REVISED', 'RECTIFICATION')
      AND NVL (DMD.cust_trx_type_name, 'ORIGINAL') NOT IN ('RR REFD RCVBL')
      OR ( j.cust_trx_type_name                           IN ('RR REFD RCVBL')
      AND DMD.customer_trx_id                           = j.customer_trx_id
      AND DMD.dmd_status                             = 'RR DEM CANCEL' )
      UNION

      /*-- inserting current dmd details also :*/
      SELECT DMD.avl_refd_adjust_amount ,
        DMD.dmd_due_date ,
        DMD.customer_trx_id ,
        j.customer_trx_id ,
        DMD.irt_id ,
        DMD.dmd_identified_date ,
        'DMD' ,
        DMD.cust_trx_type_name ,
        DMD.dmd_status
      FROM xx_dmd_headers DMD
      WHERE DMD.customer_trx_id = j.customer_trx_id
      AND MAJOR_HEAD              <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      AND DMD.dmd_status    IN('DMD IDENTIFIED' , 'THRESHOLD DMD IDENTIFIED' ,'FAS DMD HOLD IDENTIFIED' );
      ----------------------220 --------
      write_debug ( g_debug_flag ,'rowcount for DMD IN GTT: ' || sql%rowcount ) ;
	  dbms_output.put_line('rowcount for DMD IN GTT: ' || sql%rowcount ) ;
      ----------------------------220-------------------------------------
      l_chr_exe_location := 'DPP_0013';
      l_stmt_processing  :='Insert into xx_prev_dem_details_gtt ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO xx_prev_dem_details_gtt xpddg
        (
          amount_due_remaining ,
          dmd_due_date ,
          customer_trx_id ,
          new_customer_trx_id ,
          irt_id ,
          dmd_identified_date ,
          irt_type ,
          irt_return_type ,
          dmd_status
        )
      SELECT DISTINCT 0 dmd_identify_amount -- -- Distinct added to avoid sch type join.
        --NULL -- 0 added for 220 logic
        ,
        TO_DATE (xrh.approval_date) dmd_due_date ,
        xrh.customer_trx_id ,
        j.customer_trx_id ,
        xrh.irt_id ,
        NULL ,
        'REFD' ,
        NULL ,
        NULL
      FROM xx_refd_headers xrh
      WHERE j.id_number                  = xrh.id_number
      AND j.irt_ay                        = xrh.irt_ay
      AND j.major_head                    = xrh.major_head
      AND j.irt_schedule_type             = xrh.irt_schedule_type
      AND NVL (refd_identify_amount, 0) > 0
      AND xrh.irt_id NOT                 IN
        ( SELECT irt_id FROM xx_prev_dem_details_gtt
        );
      ----------------------220 --------
      write_debug ( g_debug_flag ,'rowcount for REFD IN GTT: ' || sql%rowcount ) ;
      ----------------------------220-------------------------------------
      /***************** NDNR ****************************/
      -- Only irt_approval_date will be used to check cut-off
      l_chr_exe_location := 'DPP_0014';
      l_stmt_processing  :='Insert into xx_prev_dem_details_gtt (NDNR Case) ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO xx_prev_dem_details_gtt xpddg
        (
          amount_due_remaining ,
          dmd_due_date ,
          customer_trx_id ,
          new_customer_trx_id ,
          irt_id ,
          dmd_identified_date ,
          irt_type ,
          irt_return_type ,
          dmd_status
        )
      SELECT DISTINCT
        -- NULL
        0 dmd_identify_amount -- -- Distinct added to avoid sch type join.
        ,                        -- 0 added for 220 logic
        TO_DATE (rcta.attribute3) dmd_due_date ,
        rcta.customer_trx_id ,
        j.customer_trx_id ,
        rcta.interface_header_attribute1 ,
        TO_DATE (rcta.attribute3) ,
        'NDNR' ,
        NULL ,
        NULL
      FROM ra_customer_trx_all rcta
      WHERE j.id_number        = rcta.attribute5
      AND j.irt_ay              = rcta.attribute4
      AND rcta.attribute11 NOT IN
        ( SELECT irt_id FROM xx_prev_dem_details_gtt
        );
      ----------------------220 --------
      write_debug ( g_debug_flag ,'rowcount for NDNDR IN GTT: ' || sql%rowcount ) ;
	  dbms_output.put_line('rowcount for NDNDR IN GTT: '|| sql%rowcount ) ;
      write_debug ( g_debug_flag ,'j.customer_trx_id : ' || j.customer_trx_id ) ;
      ----------------------------220-------------------------------------
      FOR l_rec_prev_dmds IN
      (SELECT amount_due_remaining ,
        dmd_due_date ,
        customer_trx_id ,
        dmd_identified_date ,
        state_code ,
        irt_type ,
        irt_return_type ,
        dmd_status ,
        dmd_service_date
      FROM xx_prev_dem_details_gtt xpddg
      WHERE xpddg.new_customer_trx_id = j.customer_trx_id
      ORDER BY xpddg.dmd_due_date
      )
      LOOP
        IF l_rec_prev_dmds.dmd_due_date       IS NULL THEN
          l_calc_status                             := NULL;
          l_orig_dem_due_date                       := NULL;
          l_dte_service_date                        := NULL;
          IF l_rec_prev_dmds.dmd_service_date IS NULL THEN
            l_dte_service_date                      := l_rec_prev_dmds.dmd_identified_date + 5;
          ELSE
            l_dte_service_date := l_rec_prev_dmds.dmd_service_date;
          END IF; -- IF l_rec_prev_dmds.dmd_service_date IS NULL
          BEGIN
            l_chr_exe_location := 'DPP_0014';
            l_stmt_processing  := 'Insert into xx_prev_dem_details_gtt (NDNR Case) ';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_calc_status    := PKG_COMMON_APIS_V2.get_next_working_day_func (( l_dte_service_date + 30) ,l_rec_prev_dmds.state_code , l_orig_dem_due_date ,out_err_msg );
            IF l_calc_status <> 0 THEN
              write_debug( g_debug_flag , 'Error in Holiday Calendar api for getting next working day ' || out_err_msg || SQLERRM);
              p_out_chr_errbuff := out_err_msg;
              RAISE custom_exception;
            END IF; -- IF l_calc_status <> 0
          EXCEPTION
          WHEN OTHERS THEN
            write_debug( g_debug_flag , 'Error calling PKG_COMMON_APIS_V2.get_next_working_day_func: ' || SQLERRM );
            l_orig_dem_due_date := (l_dte_service_date) + 30;
          END;
          IF l_rec_prev_dmds.dmd_status = 'RR DEM CANCEL' THEN
            l_chr_exe_location               := 'DPP_0015';
            l_stmt_processing                := 'Updating prev dem headers with due dates';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
			dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
            --updating prev dem headers with due dates
            UPDATE xx_dmd_headers
            SET dmd_due_date   = l_orig_dem_due_date,
              dmd_service_date = l_dte_service_date,
              --last_update_date    =g_dte_sys_date -- Added for AO Portal
              -- automation prem
              last_update_date = sysdate --Changed from g_dte_sys_date to sysdate
              -- for CR_HWSW_0340
            WHERE customer_trx_id = l_rec_prev_dmds.customer_trx_id
            AND dmd_due_date  IS NULL;
          END IF; --IF l_rec_prev_dmds.dmd_status = 'RR DEM CANCEL'
          l_chr_exe_location := 'DPP_0016';
          l_stmt_processing  :='updating prev dem GTT with due dates';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
          UPDATE xx_prev_dem_details_gtt
          SET dmd_due_date   = l_orig_dem_due_date,
            dmd_service_date = l_dte_service_date
          WHERE customer_trx_id = l_rec_prev_dmds.customer_trx_id
          AND dmd_due_date  IS NULL;
          --For ref dem cases, due dates would be either thr for all RR DEM
          -- CANCEL or for none.
        END IF; -- IF l_rec_prev_dmds.dmd_due_date IS NULL
      END LOOP; -- TO update dmd_due_date if null
      l_num_seq_num      := 0;
      l_chr_exe_location := 'DPP_0017';
      l_stmt_processing  := 'fetching cut off date from xx_prev_dem_details_gtt ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT MAX (dmd_due_date)
      INTO l_dte_cut_off_date
      FROM xx_prev_dem_details_gtt
      WHERE new_customer_trx_id = j.customer_trx_id
      AND irt_type             IN ('REFD', 'NDNR');
      /************** ASSIGNING SEQ **********************/
      IF l_dte_cut_off_date IS NULL THEN
        --updating seq numbers in GTT (cut-off null)
        l_chr_exe_location := 'DPP_0018';
        l_stmt_processing  := 'updating seq numbers in xx_prev_dem_details_gtt (cut-off null)';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        UPDATE xx_prev_dem_details_gtt m
        SET seq_number =
          (SELECT p
          FROM
            (SELECT DENSE_RANK () OVER (ORDER BY dmd_due_date, ROWID) p,
              ROWID
            FROM xx_prev_dem_details_gtt
            WHERE new_customer_trx_id = j.customer_trx_id
            ) n
          WHERE m.ROWID = n.ROWID
          );
      ELSE
        --updating seq numbers in GTT
        l_chr_exe_location := 'DPP_0019';
        l_stmt_processing  :='updating seq numbers in xx_prev_dem_details_gtt' ;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        UPDATE xx_prev_dem_details_gtt m
        SET seq_number =
          (SELECT p
          FROM
            (SELECT DENSE_RANK () OVER (ORDER BY dmd_due_date, ROWID) p,
              ROWID
              --if dem due dates are same rowid would be used
            FROM xx_prev_dem_details_gtt
            WHERE new_customer_trx_id = j.customer_trx_id
              --AND dmd_due_date       > l_dte_cut_off_date ------220
            ) n
          WHERE m.ROWID = n.ROWID
          );
      END IF; -- IF l_dte_cut_off_date IS NULL
      l_num_counter := 0;
      /***************** MAIN LOOP********************/
      FOR L_REC_PREV_DMDS IN
      (SELECT amount_due_remaining ,
        dmd_due_date --dem_due_date will be same fr RR
        ,
        customer_trx_id ,
        dmd_service_date ,
        dmd_identified_date ,
        dmd_status
      FROM xx_prev_dem_details_gtt xpddg
      WHERE xpddg.new_customer_trx_id = j.customer_trx_id
      AND seq_number                 IS NOT NULL
        --and irt_type not in ('REFD','NDNR')-- ensures cut-off records--220
        --- commented for 220 logic
      ORDER BY dmd_due_date
      )
      LOOP
        l_num_final_odd_amt  := 0;
        l_final_dem_due_date := NULL;
        l_num_max_prev_amt   := 0;
        l_num_existing_amt   := 0;
        l_num_counter        := l_num_counter + 1;
        -- min(latest rect dem amt, max(all past dem))
        --fetching MAX prev dem amts
        l_chr_exe_location := 'DPP_0020';
        l_stmt_processing  :='fetching MAX prev dem amts';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        SELECT MAX (amount_due_remaining)
        INTO l_num_max_prev_amt
        FROM xx_prev_dem_details_gtt
        WHERE seq_number <= l_num_counter
        AND seq_number   IS NOT NULL;
        write_debug( g_debug_flag ,'l_num_max_prev_amt: ' || l_num_max_prev_amt ) ;
        /******************** FORMULA **********************/
        -- evaluating MIN formula
        l_chr_exe_location := 'DPP_0021';
        l_stmt_processing  :='evaluating MIN formula';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        SELECT LEAST (j.avl_refd_adjust_amount, l_num_max_prev_amt)
        INTO l_num_final_odd_amt
        FROM DUAL;
        write_debug( g_debug_flag ,'Formula Amount: ' || l_num_final_odd_amt );
        --inserting into xx_tot_overdue_details
        l_chr_exe_location := 'DPP_0022';
        l_stmt_processing  :='Insert into xx_tot_overdue_details';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        INSERT
        INTO xx_tot_overdue_details
          (
            overdue_dem_amt ,
            dem_due_date ,
            dem_order_date ,
            dem_service_date ,
            customer_trx_id ,
            created_by ,
            creation_date ,
            last_update_login ,
            last_updated_by ,
            request_id ,
            irt_id ,
            rectified_customer_trx_id ,
            dmd_status ,
            major_head ,
            irt_schedule_type ,
            return_flag
          )
          VALUES
          (
            l_num_final_odd_amt ,
            l_rec_prev_dmds.dmd_due_date ,
            l_rec_prev_dmds.dmd_identified_date ,
            l_rec_prev_dmds.dmd_service_date ,
            l_rec_prev_dmds.customer_trx_id ,
            g_num_user_id,
            g_dte_sys_date ,
            g_num_user_id ,
            g_num_user_id ,
            g_num_request_id ,
            j.irt_id ,
            j.customer_trx_id ,
            l_rec_prev_dmds.dmd_status ,
            j.major_head ,
            j.irt_schedule_type ,
            j.cust_trx_type_name
          );
        write_debug ( g_debug_flag ,'rowcount: ' || sql%rowcount ) ;
		dbms_output.put_line('rowcount: ' || sql%rowcount ) ;
        write_debug ( g_debug_flag ,'dem_service_date: ' || l_rec_prev_dmds.dmd_service_date ) ;
        l_final_dem_due_date := l_rec_prev_dmds.dmd_due_date;
        write_debug ( g_debug_flag ,'l_num_final_odd_amt: ' || l_num_final_odd_amt ) ;
        write_debug ( g_debug_flag ,'l_final_dem_due_date: '|| l_final_dem_due_date ) ;
        write_debug ( g_debug_flag ,'l_num_counter: ' || l_num_counter ) ;
        -- Chk for prov and update int calc flag
      END LOOP; --FOR l_rec_prev_dmds IN
    END LOOP;   --FOR j IN (SELECT customer_trx_id, dmd_original_amount,
    -- irt_ay,
    -- After rounding off dmd_identify_amt can become 0 , provided
    -- dmd_identify amt is 1,2,3 or 4 (will get rounded off to nearest 0)
    -- These dmds were not getting closed in further programs, and hence its
    -- corresponding excss collcn was not getn refded.
    -- bcoz of the chk of open dmds while refding.
    --updating ra_customer_trx_all inv as CLOSED
    l_chr_exe_location := 'DPP_0023';
    l_stmt_processing  :='updating ra_cust_trx inv as CLOSED';
    write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing ) ;
    UPDATE ra_customer_trx_all rcta
    SET rcta.attribute9                    = 'PCM CLOSED',
      last_update_date                     = g_dte_sys_date,
      last_updated_by                      = g_num_user_id
    WHERE rcta.interface_header_attribute1 = p_in_irt_id
    AND EXISTS
      (SELECT 1
      FROM xx_dmd_headers xdh
      WHERE xdh.dmd_status         IN ('DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED')
      AND xdh.avl_refd_adjust_amount = 0
      AND xdh.dmd_identify_amount   = 0
      AND xdh.customer_trx_id          = rcta.customer_trx_id
      );
    --updating avl/dem_identify = 0 dmds as CLOSED:
    l_chr_exe_location := 'DPP_0024';
    l_stmt_processing  :='updating avl/dem_identify = 0 dmds as CLOSED';
    WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
    FND_FILE.PUT_LINE(FND_FILE.LOG,'number of dmds updated in ra: '||sql%rowcount);
	dbms_output.put_line('number of dmds updated in ra: '||sql%rowcount);
    UPDATE xx_dmd_headers
    SET dmd_status = 'CLOSED',
      -- last_update_date             = g_dte_sys_date,
      last_update_date = sysdate, --Changed from g_dte_sys_date to sysdate for
      -- CR_HWSW_0340
      last_updated_by              = g_num_user_id
    WHERE avl_refd_adjust_amount = 0
    AND dmd_identify_amount     = 0
    AND dmd_status             IN ('DMD IDENTIFIED', 'FAS DMD HOLD IDENTIFIED')
    AND irt_id                     = p_in_irt_id;
    l_chr_exe_location            := 'DPP_0025';
    L_STMT_PROCESSING             :='updating dmd_status in xx_dmd_headers';
    FND_FILE.PUT_LINE(FND_FILE.LOG,'number of dmds updated in dmd headers: '||sql%rowcount);
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_dmd_headers
    SET dmd_status = 'THRESHOLD DMD IDENTIFIED',
      -- Added by Sudha on 19-DEC-2017 for HF#170821 sec_code population for threshold dmds
      SEC_CODE =
      (SELECT "x_section_txt" FROM "process_store"."irt_process_control_mstr"@psql_process_fas WHERE IRT_ID = p_in_irt_id
      )
      -- Added by Sudha on 19-DEC-2017 for HF#170821 sec_code population for threshold dmds
    WHERE dmd_identify_amount <= 100
    AND dmd_status            IN ('DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED' )
    AND irt_id                    = p_in_irt_id
    AND irt_id NOT               IN
      (SELECT irt_id
      FROM xx_IRT_FAS_PRCSNG_HOLD
      WHERE release_flag IS NOT NULL
      AND hold_flag       = 'IRT CLAIM HOLD'
      AND irt_id          = p_in_irt_id
      );
    l_chr_exe_location := 'DPP_0026';
    l_stmt_processing  :='Updating dmd_status in xx_dmd_headers';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_dmd_headers
    SET dmd_status = 'THRESHOLD DMD IDENTIFIED HOLD',
      -- Added by Sudha on 19-DEC-2017 for HF#170821 sec_code population for threshold dmds
      SEC_CODE =
      (SELECT "x_section_txt" FROM "process_store"."irt_process_control_mstr"@psql_process_fas WHERE IRT_ID = p_in_irt_id
      )
      -- Added by Sudha on 19-DEC-2017 for HF#170821 sec_code population for threshold dmds
    WHERE dmd_identify_amount <= 100
    AND dmd_status            IN ('DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED' )
    AND irt_id                   IN
      (SELECT irt_id
      FROM xx_IRT_FAS_PRCSNG_HOLD
      WHERE release_flag IS NOT NULL
      AND hold_flag       = 'IRT CLAIM HOLD'
      AND irt_id          = p_in_irt_id
      );
    l_chr_exe_location := 'DPP_0027';
    l_stmt_processing  :='updating dmd_status in xx_dmd_headers';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE ra_customer_trx_all
    SET attribute9                  = 'THRESHOLD DMD IDENTIFIED'
    WHERE attribute9                = 'DMD IDENTIFIED'
    AND interface_header_attribute1 = p_in_irt_id
    AND customer_trx_id            IN
      (SELECT customer_trx_id
      FROM xx_dmd_headers
      WHERE dmd_status IN('THRESHOLD DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED HOLD')
      AND irt_id           = p_in_irt_id
      );
    WRITE_DEBUG( G_DEBUG_FLAG , '*** Identify Dmd for Custom Dmd Table population - ENDS ***');
  EXCEPTION
  WHEN custom_exception THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' ||l_stmt_processing ||'-' ||p_out_chr_errbuff ;
    write_msg( g_write_logfile ,p_out_chr_errbuff );
	dbms_output.put_line(p_out_chr_errbuff);
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - ' || l_chr_proc_name || '-' ||l_chr_errbuff );
      END IF;
    END IF;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := ' Unexpected Error in procedure ' || l_chr_proc_name || '-' || L_CHR_EXE_LOCATION ||'-' || L_STMT_PROCESSING ||'-' ||SUBSTR(SQLERRM,1 ,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
	dbms_output.put_line(p_out_chr_errbuff);
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name || '-' || l_chr_errbuff );
      END IF;
    END IF;
  END dmd_populate_proc;
---********************************* End of Procedure / Function **************
-- *********************-----------
-- New procedure added for CR_HWSW_102
  PROCEDURE excess_400_multiple_rect(
      p_out_chr_errbuff OUT VARCHAR2,
      P_OUT_CHR_RETCODE OUT NUMBER,
      P_IN_CURRENT_IRT_ID  IN VARCHAR2,
      p_in_id_number      IN VARCHAR2,
      p_in_cash_receipt_id IN NUMBER,
      p_in_excess_amount   IN NUMBER,
      p_out_excess_amount OUT NUMBER,
      p_out_ref_400_date OUT DATE,
      p_out_prev_400_int OUT NUMBER,
      p_out_ret_type OUT NUMBER )
  AS
    /****************************************************************************
    ***********
    * Type : Procedure
    * Name : excess_400_multiple_rect
    * Input Parameters : p_in_irt_id, p_in_id_num,p_in_cash_receipt_id,
    p_in_excess_amount
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * p_out_excess_amount
    * p_out_ref_400_date
    * p_out_prev_400_int
    * p_out_ret_type
    * Purpose : For receipt by receipt calculation of refd out of 400
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 20-May-2013
    * Last Reviewed By : Infosys
    * Last Reviewed Date :
    *****************************************************************************
    ***********
    * Modified Date Modified By Version Modification Type Modification Details *
    * ------------- ------------ -------- - -----------------
    -------------------------- *
    * 20-May-2013 Infosys 1.0 O Baseline. *
    *****************************************************************************
    ***********/
    l_chr_proc_name      VARCHAR2 (50) := 'excess_400_multiple_rect_proc';
    v_prev_refd_exists NUMBER        := 0;
    v_max_excess_amt     NUMBER        := 0;
    custom_excp          EXCEPTION;
  BEGIN
    BEGIN
      -- check if there was refd out of the given cash_receipt_id in previous
      -- rectifications
      SELECT 1
      INTO v_prev_refd_exists
      FROM DUAL
      WHERE EXISTS
        (SELECT 1
        FROM xx_refd_lines xrl,
          xx_refd_headers xrh
        WHERE xrl.cash_receipt_id = p_in_cash_receipt_id
        AND xrh.irt_id           <> P_IN_CURRENT_IRT_ID
        AND xrh.reference_id      = xrl.reference_id
        );
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      raise custom_excp;
    WHEN OTHERS THEN
      write_debug( g_debug_flag , 'Error while checking previous rectification details: '||sqlerrm );
      raise custom_excp;
    END;
    BEGIN
      -- fetch the maximum excess_receipt_amount for which the 244 interest was
      -- computed previously
      -- for the given cash_receipt_id
      SELECT MAX(xrl.excess_receipt_amount)
      INTO v_max_excess_amt
      FROM xx_refd_lines xrl,
        xx_refd_headers xrh
      WHERE xrl.cash_receipt_id = p_in_cash_receipt_id
      AND xrh.irt_id           <> P_IN_CURRENT_IRT_ID
      AND xrh.reference_id      = xrl.reference_id;
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag , 'Error while fetching max(excess_receipt_amount) from previous rectification for cash_receipt_id: ' ||p_in_cash_receipt_id||' Error: '||sqlerrm );
      raise custom_excp;
    END;
    IF p_in_excess_amount - v_max_excess_amt >= 0 THEN
      -- increase in refd case. Therefore interest needs to be computed only on
      -- the differential amount
      p_out_excess_amount := p_in_excess_amount - v_max_excess_amt;
      p_out_ret_type      := 0;
      p_out_ref_400_date  := TRUNC(sysdate); --null ,sysdate added for cr 230 for
      -- increase in refds
      BEGIN
        -- fetch the previously computed 244 interest
        SELECT MAX(xrl.int_amount_400)
        INTO p_out_prev_400_int
        FROM xx_refd_lines xrl
        WHERE xrl.cash_receipt_id     = p_in_cash_receipt_id
        AND xrl.excess_receipt_amount = v_max_excess_amt;
      EXCEPTION
      WHEN no_data_found THEN
        p_out_prev_400_int := 0;
      WHEN OTHERS THEN
        write_debug( g_debug_flag , 'Error while fetching int_amount_400 from previous rectification for cash_receipt_id: ' ||p_in_cash_receipt_id||' Error: '||sqlerrm );
      END;
    ELSE
      BEGIN
        -- decrease in refd case therefore
        -- fetch the minimum date for which the interest has to be computed (on
        -- p_in_excess_amount)
        SELECT MIN(xrh.ref_400_int_to_date)
        INTO p_out_ref_400_date
        FROM xx_refd_lines xrl,
          xx_refd_headers xrh
        WHERE xrl.cash_receipt_id = p_in_cash_receipt_id
        AND xrh.irt_id           <> P_IN_CURRENT_IRT_ID
        AND xrh.reference_id      = xrl.reference_id;
        p_out_ret_type           := 1;
        p_out_excess_amount      := p_in_excess_amount;
        p_out_prev_400_int       := 0;
      EXCEPTION
      WHEN OTHERS THEN
        p_out_ref_400_date := NULL;
        write_debug( g_debug_flag , 'Error while fetching min(ref_400_int_to_date) from previous rectification for cash_receipt_id: ' ||p_in_cash_receipt_id||' Error: '||sqlerrm );
      END;
    END IF;
    p_out_chr_retcode := 0;
    p_out_chr_errbuff := 'SUCCESS';
    write_debug( g_debug_flag , 'p_out_chr_errbuff from procedure excess_400_multiple_rect: '|| p_out_chr_errbuff );
    write_debug( g_debug_flag , 'p_out_chr_retcode from procedure excess_400_multiple_rect: '|| p_out_chr_retcode );
    write_debug( g_debug_flag , 'p_out_excess_amount from procedure excess_400_multiple_rect: '|| p_out_excess_amount );
    write_debug( g_debug_flag , 'p_out_ref_400_date from procedure excess_400_multiple_rect: '|| p_out_ref_400_date );
    write_debug( g_debug_flag , 'p_out_prev_400_int from procedure excess_400_multiple_rect: '|| p_out_prev_400_int );
  EXCEPTION
  WHEN custom_excp THEN
    p_out_chr_retcode   := 0;
    p_out_ret_type      := 3;
    p_out_chr_errbuff   := 'Receipt id not found in previous rectification';
    p_out_excess_amount := NULL;
    p_out_ref_400_date  := NULL;
    p_out_prev_400_int  := NULL;
  WHEN OTHERS THEN
    p_out_chr_retcode   := 2;
    p_out_ret_type      := 4;
    p_out_chr_errbuff   := 'Error while calling procedure excess_400_multiple_rect' ;
    p_out_excess_amount := NULL;
    p_out_ref_400_date  := NULL;
    p_out_prev_400_int  := NULL;
    write_debug( g_debug_flag , 'Error while calling procedure excess_400_multiple_rect: '||SQLERRM );
  END EXCESS_400_MULTIPLE_RECT;
  PROCEDURE ro_skip_check_proc(
      p_out_chr_errbuff OUT NOCOPY VARCHAR2,
      p_out_chr_retcode OUT NOCOPY VARCHAR2,
      p_skip_ro_status OUT NUMBER,
      p_relaxation_flag OUT NUMBER, --added for HF_175742 on 11-Apr-2018
      p_in_id_number IN VARCHAR2,
      p_in_irt_id     IN VARCHAR2,
      P_IN_IRT_AY     IN VARCHAR2 )
  AS
    /****************************************************************************
    ***********
    * Type : Procedure
    * Name : ro_skip_check_proc
    * Input Parameters : p_in_id_number,p_in_irt_id,P_IN_IRT_AY
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * p_out_excess_amount
    * p_skip_ro_status
    * Purpose : For determining RO Adjust cases and skip the adjustment part
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 31-Mar-2017
    * Last Reviewed By : Infosys
    * Last Reviewed Date :
    *****************************************************************************
    ***********
    * Modified Date Modified By Version Modification Type Modification Details *
    * ------------- ------------ -------- - -----------------
    -------------------------- *
    * 31-Mar-2017 Infosys 1.0 O Baseline. *
    *****************************************************************************
    ***********/
    v_count            NUMBER := 0;
    v_count1           NUMBER := 0;
    l_final_rb_cnt     NUMBER := 0;
    l_roll_bk_cnt      NUMBER := 0;
    v_tot_refd_amt   NUMBER := 0;
    v_avl_dmd_amt   NUMBER := 0;
    V_CNF_DMND_ASSESSE NUMBER := 0;
    V_CNF_DMND_VALUE   NUMBER := 0;
    L_IBA_FLAG        VARCHAR2(1);---added for blocking cr 611
    v_cnt              NUMBER :=-1; --Hotfix_168036-- Added on 28 Nov 2017
    v_cnt_thr_dmnd     NUMBER :=-1; --Hotfix_168036 --Added on 15-Dec-2017
    --v_relaxation_flag  NUMBER :=0;  --Hotfix_168036  --Added on 28-Dec-2017
  BEGIN
    p_skip_ro_status := 0; -- adjust
    p_relaxation_flag:=0;  --added for HF_175742 on 11-Apr-2018
    BEGIN
      SELECT COUNT(1)
      INTO v_count
      FROM xx_dmd_headers DMD ,
        xx_refd_headers HEADER
      WHERE dmd_status IN ('DMD','THRESHOLD DMD','INT DMD') --
        -- dmd_service_date condition
      AND DMD.avl_refd_adjust_amount > 0
      AND DMD.MAJOR_HEAD              <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      AND HEADER.ID_NUMBER               = DMD.ID_NUMBER
      AND Header.Id_Number               = P_in_Id_Number
        --AND TO_NUMBER (HEADER.irt_ay) > TO_NUMBER (DMD.irt_ay)--changed to
        -- adjust subsequent year dmd to prior refd.
      AND HEADER.refd_status                                                                                                    = 'PCM APPROVED'
      AND HEADER.irt_id                                                                                                           = p_in_irt_id
      AND HEADER.approval_date                                                                                                   IS NOT NULL
      AND ( NVL (HEADER.total_refd_amount, 0) - NVL ( HEADER.refd_adjustment_amount, 0) - NVL (HEADER.net_refd_amount, 0) ) > 0
      AND NOT EXISTS
        (SELECT 1
        FROM xx_irt_fas_prcsng_hold XIFPH
        WHERE DMD.irt_id     = XIFPH.irt_id
        AND XIFPH.hold_flag    IN('IRT REFD HOLD', 'IRTCLAIM HOLD')
        AND XIFPH.release_flag IS NULL
        );
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Error while fetching count for RO adjust:'|| sqlerrm );
    END;
    write_debug( g_debug_flag ,'v_count in ro_status_chk_proc:'||v_count );
    IF v_count         >= 1 THEN
      v_tot_refd_amt :=0 ;
      v_avl_dmd_amt :=0 ;
      BEGIN
        SELECT SUM(NVL(total_refd_amount,0))
        INTO v_tot_refd_amt
        FROM xx_refd_headers
        WHERE id_number = p_in_id_number
        AND irt_id       = p_in_irt_id;
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag , 'Error while fetching total_refd_amount from xx_refd_headers:'|| sqlerrm );
      END;
      write_debug( g_debug_flag ,'v_tot_refd_amt in ro_status_chk_proc:'|| v_tot_refd_amt );
      BEGIN
        SELECT SUM(avl_refd_adjust_amount)
        INTO v_avl_dmd_amt
        FROM xx_dmd_headers
        WHERE id_number             = p_in_id_number
        AND avl_refd_adjust_amount > 0
        AND dmd_status           IN ('DMD','INT DMD','THRESHOLD DMD')
        AND MAJOR_HEAD              <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag , 'Error while fetching avl_refd_adjust_amount from xx_dmd_headers:' ||sqlerrm );
		dbms_output.put_line('Error while fetching avl_refd_adjust_amount from xx_dmd_headers:' ||sqlerrm );
      END;
      BEGIN
        write_debug( g_debug_flag , '************************************************' );
        write_debug( g_debug_flag ,'INSIDE THE BEGIN BLOCK' );
        write_debug( g_debug_flag , '************************************************' );
        SELECT COUNT(1),
          SUM(AVL_REFD_ADJUST_AMOUNT)
        INTO V_CNF_DMND_ASSESSE,
          V_CNF_DMND_VALUE
        FROM xx_DMD_HEADERS
        WHERE ID_NUMBER        =p_in_id_number
        AND NVL(ATTRIBUTE6,'X') ='Y'
        AND MAJOR_HEAD         <> '0032'                    --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
        AND dmd_status      IN ('DMD','INT DMD') ; --#CR-644
        write_debug( g_debug_flag ,'V_CNF_DMND_ASSESSE:='||V_CNF_DMND_ASSESSE );
        write_debug( g_debug_flag ,'V_CNF_DMND_VALUE:='||V_CNF_DMND_VALUE );
        SELECT COUNT(1)
        INTO v_cnt_thr_dmnd
        FROM xx_dmd_headers
        WHERE dmd_status  IN ('THRESHOLD DMD')
        AND MAJOR_HEAD       <> '0032'                                                                                    --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
        AND id_number        = p_in_id_number;                                                                          -- Added by Neha on 168036 for Threshold Dmd Adjustment issues - 26-DEC-2017
        IF ((v_tot_refd_amt>=1 AND v_tot_refd_amt<=5000) OR ( v_avl_dmd_amt>=1 AND v_avl_dmd_amt<=5000 ) ) THEN --modified condition for hotfix#165114
          write_debug( g_debug_flag , 'Relaxaction Case');
          p_relaxation_flag :=1; --Hotfix_168036 Added on 28-Dec-2017
          -----Hotfix_168036---------Relaxation Case below 5000--Added on 28 Nov 2017----------
          SELECT COUNT(1)
          INTO v_cnt
          FROM xx_dmd_headers
          WHERE dmd_status IN ('DMD','INT DMD') --Hotfix_168036 Added on 28 Nov 2017
          AND id_number       = p_in_id_number
          AND MAJOR_HEAD      <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
            --AND (NVL(attribute1,'X') IN ('Y','R')
            --OR NVL(attribute6,'X')   IN ('Y','R')); --commented for HF_187662
          AND NVL(attribute6,'X') IN ('Y','R'); --added for HF_187662
          write_debug( g_debug_flag , 'Relaxaction Case - v_cnt : '|| v_cnt);
          ---Checking if any record exists for THRESHOLD Dmd-----Hotfix_168036 --Added on 18-Dec-2017
          SELECT COUNT(1)
          INTO v_cnt_thr_dmnd
          FROM xx_dmd_headers
          WHERE dmd_status IN ('THRESHOLD DMD')
          AND MAJOR_HEAD      <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          AND id_number       = p_in_id_number;
          write_debug( g_debug_flag , 'Relaxaction Case - v_cnt : '|| v_cnt_thr_dmnd);
          --------------------Hotfix_168036-----------------------------
          --v_cnt will give if there is AO Confirmations present
          IF ((v_cnt          > 0 ) OR (v_cnt_thr_dmnd >0)) THEN
            p_skip_ro_status := 0; -- adjust and release --Hotfix_168036 -Modified on 18-Dec-2017
            write_debug( g_debug_flag , 'p_skip_ro_status got  : '|| p_skip_ro_status);
          ELSE
            p_skip_ro_status :=2; ---Hotfix_168036  Not adjusting, only release -----------
            write_debug( g_debug_flag , 'p_skip_ro_status got  : '|| p_skip_ro_status);
            ------------End of Hotfix_168036----Added on 28 Nov 2017----------------
          END IF;
          UPDATE xx_AR_TRANS_STG xats
          SET RELAX_FLAG           ='RELAX'
          WHERE transaction_number = P_IN_IRT_ID;
          UPDATE xxcus.xx_REFD_HEADERS
          SET ATTRIBUTE15='RO_RELAX'
            --ATTRIBUTE14='FAS'
          WHERE IRT_ID =P_IN_IRT_ID;
          write_debug( g_debug_flag , 'Attribute s are updated  : ');
        ELSE
          IF (( V_CNF_DMND_ASSESSE>0 AND V_CNF_DMND_VALUE>V_TOT_REFD_AMT ) ) THEN
            write_debug( g_debug_flag , 'Confirmed Dmd amount is more than refd amount and eligible for Adjust' );
            p_skip_ro_status := 0;-- adjust
            --add here
            UPDATE xxcus.xx_REFD_HEADERS
            SET ATTRIBUTE15='CONFIRMED'
              --ATTRIBUTE14='FAS'
            WHERE IRT_ID =P_IN_IRT_ID;
            BEGIN
              UPDATE xxcus.irt_notice_us_245
              SET ro_adjust = 'Y'
              WHERE irt_id  = P_IN_IRT_ID;
            EXCEPTION
            WHEN OTHERS THEN
              write_debug( g_debug_flag ,'error while updating ro_adjust flag'|| SQLERRM );
            END;
          ELSE -- pending for confirmation
            BEGIN
              FOR REC IN
              (SELECT  *
              FROM xx_DMD_HEADERS
              WHERE ID_NUMBER            =P_IN_ID_NUMBER
              AND DMD_STATUS          IN ('DMD','INT DMD') --- #CR-644
              AND avl_refd_adjust_amount>100
              AND MAJOR_HEAD             <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
              )
              LOOP
                SELECT
                  CASE
                    WHEN ATTRIBUTE1 ='N'
                    AND ATTRIBUTE2  ='26'
                    AND ATTRIBUTE6 IS NULL
                    THEN 0
                    WHEN ATTRIBUTE1 ='N'
                    AND ATTRIBUTE6 IS NULL
                    THEN 1
                    WHEN ATTRIBUTE1 IS NULL
                    AND ATTRIBUTE6   ='N'
                    THEN 1
                    WHEN ATTRIBUTE1 IS NULL
                    AND ATTRIBUTE6  IS NULL
                    THEN 1
                    WHEN ATTRIBUTE1 IN ('S','F')
                    THEN 1--added till S and F is sorted out.--17-jan-2016
                    WHEN ATTRIBUTE6 IS NULL
                    THEN 1 -- added for CR_602. Even if AO aggress, have to wait
                      -- for Assesse's response
                    ELSE 0
                  END
                INTO l_roll_bk_cnt
                FROM xx_DMD_HEADERS
                WHERE ID_NUMBER   =REC.ID_NUMBER
                AND customer_Trx_id=rec.customer_Trx_id
                AND MAJOR_HEAD    <> '0032'                   --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
                AND DMD_STATUS                IN ('DMD','INT DMD'); -- #CR-644
                l_final_rb_cnt    :=l_final_rb_cnt+l_roll_bk_cnt;
              END LOOP;
              --added for refd blocking cr 611
              BEGIN
                SELECT NVL(APPROVAL_FLAG,'X')
                INTO L_IBA_FLAG
                FROM irt_stdcmp.IBA_REFD_RETURNS
                WHERE irt_id =p_in_irt_id;--added for refd blocking cr 611
              EXCEPTION
              WHEN OTHERS THEN
                L_IBA_FLAG:='X';
              END;
              --added for refd blocking cr 611 ends
              IF L_FINAL_RB_CNT > 0 OR L_IBA_FLAG ='B' THEN--added flag for
                -- blocking cr 611
                FND_FILE.PUT_LINE(FND_FILE.log, 'Few records yet to confirm where net refd amount is >0');
                p_skip_ro_status :=2;
                write_debug( g_debug_flag , 'Customer/AO Partial Confirmation Records Exists');
              ELSE
                p_skip_ro_status:=0;
              END IF;
            EXCEPTION
            WHEN OTHERS THEN
              write_debug( g_debug_flag ,'Error while checking p_skip_ro_status') ;
              p_out_chr_errbuff :='Error while checking p_skip_ro_status';
              p_out_chr_retcode := 2;
            END;
          END IF;-- V_CNF_DMND_ASSESSE>0
        END IF; ---<=5000
        write_debug( g_debug_flag ,'p_skip_ro_status is'||p_skip_ro_status);
        --IF (p_skip_ro_status=2) then --Hotfix_168036 --Commented on 18-Dec-2017
        --IF ((p_skip_ro_status=2) and ((v_cnt =0) or (v_cnt_thr_dmnd =0))) then  --Hotfix_168036 Added on 18-Dec-2017 Commented on 28-Dec-2017
        IF ( p_skip_ro_status=2 AND p_relaxation_flag <> 1 ) THEN --Hotfix_168036 Added on 28-Dec-2017
          write_debug( g_debug_flag ,'Adjustment case but not adjusted');
          BEGIN
            SELECT COUNT(1)
            INTO v_count
            FROM xxcus.xx_rfnd_adj_after_acnt
            WHERE transaction_number=p_in_irt_id;
            IF (v_count             =0) AND NVL(L_IBA_FLAG,'X') <>'B'THEN--added
              -- flag for blocking cr 611
              --changes start for hotfix#171907
              --INSERT INTO xxcus.xx_rfnd_adj_after_acnt
              --SELECT * FROM xx_AR_TRANS_STG WHERE TRANSACTION_NUMBER=P_IN_IRT_ID;
              INSERT
              INTO xxcus.xx_rfnd_adj_after_acnt (TRANSACTION_SOURCE,
                    TRANSACTION_NUMBER,
                    TRANSACTION_TYPE,
                    LEGAL_ENTITY,
                    INVOICE_DATE,
                    GL_DATE,
                    TRANSACTION_CURRENCY,
                    MAJOR_HEAD,
                    MINOR_HEAD,                   
                    TS_SECTION_CODE,
                    ASSESSMENT_YEAR,
                    BILL_TO_CUSTOMER_NUMBER,
                    PAYMENT_TERM,
                    LINE_NUMBER,
                    DESCRIPTION,
                    QUANTITY,
                    LINE_AMOUNT,
                    UNIT_SELLING_PRICE,
                    COMMENTS,
                    REFERENCE,
                    STATUS_CODE,
                    ERROR_MESSAGE,
                    CM_ERROR_MESSAGE,
                    PROCESS_FLAG,
                    CREATED_BY,
                    CREATION_DATE,
                    LAST_UPDATED_BY,
                    LAST_UPDATE_DATE,
                    LAST_UPDATE_LOGIN,
                    REQUEST_ID,
                    PROGRAM_APPLICATION_ID,
                    PROGRAM_ID,
                    PROGRAM_UPDATE_DATE,
                    ATTRIBUTE1,
                    ATTRIBUTE2,
                    ATTRIBUTE3,
                    ATTRIBUTE4,
                    ATTRIBUTE5,
                    ORIG_INVOICE_NUMBER,
                    BANK_ACCOUNT,
                    MICR_CODE,
                    IRT_SCHEDULE_TYPE,
                    DR_MEMO_LINE_ID,
                    DR_MEMO_DESCRIPTION,
                    DR_SET_OF_BOOKS_ID,
                    DR_CUST_ACCOUNT_ID,
                    DR_CUST_ACCT_SITE_ID,
                    DR_CUST_TRX_TYPE_ID,
                    DR_CUST_TRX_TYPE_NAME,
                    DR_BATCH_SOURCE_NAME,
                    DR_BATCH_SOURCE_ID,
                    DR_TERM_NAME,
                    DR_TERM_ID,
                    DR_INTERFACE_LINE_CONTEXT,
                    DR_LINE_TYPE,
                    DR_CURRENCY_CODE,
                    DR_CONVERSION_RATE,
                    DR_CONVERSION_TYPE,
                    DR_ORG_ID,
                    DR_UOM_CODE,
                    AMOUNT_INCLUDES_XX_FLAG,
                    DUE_DATE,
                    ORIG_IRT_RETURN_DATE,
                    DAYS_DELAY_ASSESEE,
                    IRT_APPROVAL_DATE,
                    XX_COMPUTED,
                    MATCHED_CLAIMS_AMT,
                    REFD_COMPUTED_AMT,
                    RECEIPT_STATUS,
                    RELAX_FLAG,
                    DAYS,
                    ATTRIBUTE6,
                    ATTRIBUTE7,
                    ATTRIBUTE8,
                    ATTRIBUTE9,
                    ATTRIBUTE10
                    )
                (SELECT TRANSACTION_SOURCE,
                    TRANSACTION_NUMBER,
                    TRANSACTION_TYPE,
                    LEGAL_ENTITY,
                    INVOICE_DATE,
                    GL_DATE,
                    TRANSACTION_CURRENCY,
                    MAJOR_HEAD,
                    MINOR_HEAD,
                    TS_SECTION_CODE,
                    ASSESSMENT_YEAR,
                    BILL_TO_CUSTOMER_NUMBER,
                    PAYMENT_TERM,
                    LINE_NUMBER,
                    DESCRIPTION,
                    QUANTITY,
                    LINE_AMOUNT,
                    UNIT_SELLING_PRICE,
                    COMMENTS,
                    REFERENCE,
                    NULL,
                    NULL,
                    CM_ERROR_MESSAGE,
                    PROCESS_FLAG,
                    CREATED_BY,
                    CREATION_DATE,
                    LAST_UPDATED_BY,
                    LAST_UPDATE_DATE,
                    LAST_UPDATE_LOGIN,
                    NULL,
                    PROGRAM_APPLICATION_ID,
                    PROGRAM_ID,
                    PROGRAM_UPDATE_DATE,
                    ATTRIBUTE1,
                    ATTRIBUTE2,
                    ATTRIBUTE3,
                    ATTRIBUTE4,
                    ATTRIBUTE5,
                    ORIG_INVOICE_NUMBER,
                    BANK_ACCOUNT,
                    MICR_CODE,
                    IRT_SCHEDULE_TYPE,
                    DR_MEMO_LINE_ID,
                    DR_MEMO_DESCRIPTION,
                    DR_SET_OF_BOOKS_ID,
                    DR_CUST_ACCOUNT_ID,
                    DR_CUST_ACCT_SITE_ID,
                    DR_CUST_TRX_TYPE_ID,
                    DR_CUST_TRX_TYPE_NAME,
                    DR_BATCH_SOURCE_NAME,
                    DR_BATCH_SOURCE_ID,
                    DR_TERM_NAME,
                    DR_TERM_ID,
                    DR_INTERFACE_LINE_CONTEXT,
                    DR_LINE_TYPE,
                    DR_CURRENCY_CODE,
                    DR_CONVERSION_RATE,
                    DR_CONVERSION_TYPE,
                    DR_ORG_ID,
                    DR_UOM_CODE,
                    AMOUNT_INCLUDES_XX_FLAG,
                    DUE_DATE,
                    ORIG_IRT_RETURN_DATE,
                    DAYS_DELAY_ASSESEE,
                    IRT_APPROVAL_DATE,
                    XX_COMPUTED,
                    MATCHED_CLAIMS_AMT,
                    REFD_COMPUTED_AMT,
                    RECEIPT_STATUS,
                    ATTRIBUTE6,
                    ATTRIBUTE7,
                    ATTRIBUTE8,
                    ATTRIBUTE9,
                    ATTRIBUTE10,
                    RELAX_FLAG,
                    DAYS
                  FROM xx_Ar_Trans_Stg
                  WHERE Transaction_Number=P_In_Irt_Id
                );
              --changes end  for hotfix#171907
              write_debug ( g_debug_flag , 'recs inserted into xx_rfnd_adj_after_acnt is'||sql%rowcount ) ;
            elsif v_count = 0 AND L_IBA_FLAG = 'B' THEN --added flag for
              -- blocking cr 611;
              BEGIN              
                INSERT
                INTO xxcus.xx_rfnd_adj_after_acnt
				(TRANSACTION_SOURCE,
                    TRANSACTION_NUMBER,
                    TRANSACTION_TYPE,
                    LEGAL_ENTITY,
                    INVOICE_DATE,
                    GL_DATE,
                    TRANSACTION_CURRENCY,
                    MAJOR_HEAD,
                    MINOR_HEAD,                   
                    TS_SECTION_CODE,
                    ASSESSMENT_YEAR,
                    BILL_TO_CUSTOMER_NUMBER,
                    PAYMENT_TERM,
                    LINE_NUMBER,
                    DESCRIPTION,
                    QUANTITY,
                    LINE_AMOUNT,
                    UNIT_SELLING_PRICE,
                    COMMENTS,
                    REFERENCE,
                    STATUS_CODE,
                    ERROR_MESSAGE,
                    CM_ERROR_MESSAGE,
                    PROCESS_FLAG,
                    CREATED_BY,
                    CREATION_DATE,
                    LAST_UPDATED_BY,
                    LAST_UPDATE_DATE,
                    LAST_UPDATE_LOGIN,
                    REQUEST_ID,
                    PROGRAM_APPLICATION_ID,
                    PROGRAM_ID,
                    PROGRAM_UPDATE_DATE,
                    ATTRIBUTE1,
                    ATTRIBUTE2,
                    ATTRIBUTE3,
                    ATTRIBUTE4,
                    ATTRIBUTE5,
                    ORIG_INVOICE_NUMBER,
                    BANK_ACCOUNT,
                    MICR_CODE,
                    IRT_SCHEDULE_TYPE,
                    DR_MEMO_LINE_ID,
                    DR_MEMO_DESCRIPTION,
                    DR_SET_OF_BOOKS_ID,
                    DR_CUST_ACCOUNT_ID,
                    DR_CUST_ACCT_SITE_ID,
                    DR_CUST_TRX_TYPE_ID,
                    DR_CUST_TRX_TYPE_NAME,
                    DR_BATCH_SOURCE_NAME,
                    DR_BATCH_SOURCE_ID,
                    DR_TERM_NAME,
                    DR_TERM_ID,
                    DR_INTERFACE_LINE_CONTEXT,
                    DR_LINE_TYPE,
                    DR_CURRENCY_CODE,
                    DR_CONVERSION_RATE,
                    DR_CONVERSION_TYPE,
                    DR_ORG_ID,
                    DR_UOM_CODE,
                    AMOUNT_INCLUDES_XX_FLAG,
                    DUE_DATE,
                    ORIG_IRT_RETURN_DATE,
                    DAYS_DELAY_ASSESEE,
                    IRT_APPROVAL_DATE,
                    XX_COMPUTED,
                    MATCHED_CLAIMS_AMT,
                    REFD_COMPUTED_AMT,
                    RECEIPT_STATUS,
                    RELAX_FLAG,
                    DAYS,
                    ATTRIBUTE6,
                    ATTRIBUTE7,
                    ATTRIBUTE8,
                    ATTRIBUTE9,
                    ATTRIBUTE10
                    )
                  (SELECT TRANSACTION_SOURCE,
                      TRANSACTION_NUMBER,
                      TRANSACTION_TYPE,
                      LEGAL_ENTITY,
                      INVOICE_DATE,
                      GL_DATE,
                      TRANSACTION_CURRENCY,
                      MAJOR_HEAD,
                      MINOR_HEAD,
                      TS_SECTION_CODE,
                      ASSESSMENT_YEAR,
                      BILL_TO_CUSTOMER_NUMBER,
                      PAYMENT_TERM,
                      LINE_NUMBER,
                      DESCRIPTION,
                      QUANTITY,
                      LINE_AMOUNT,
                      UNIT_SELLING_PRICE,
                      COMMENTS,
                      REFERENCE,
                      NULL,
                      NULL,
                      CM_ERROR_MESSAGE,
                      PROCESS_FLAG,
                      CREATED_BY,
                      CREATION_DATE,
                      LAST_UPDATED_BY,
                      LAST_UPDATE_DATE,
                      LAST_UPDATE_LOGIN,
                      NULL,
                      PROGRAM_APPLICATION_ID,
                      PROGRAM_ID,
                      PROGRAM_UPDATE_DATE,
                      ATTRIBUTE1,
                      ATTRIBUTE2,
                      ATTRIBUTE3,
                      ATTRIBUTE4,
                      ATTRIBUTE5,
                      ORIG_INVOICE_NUMBER,
                      BANK_ACCOUNT,
                      MICR_CODE,
                      IRT_SCHEDULE_TYPE,
                      DR_MEMO_LINE_ID,
                      DR_MEMO_DESCRIPTION,
                      DR_SET_OF_BOOKS_ID,
                      DR_CUST_ACCOUNT_ID,
                      DR_CUST_ACCT_SITE_ID,
                      DR_CUST_TRX_TYPE_ID,
                      DR_CUST_TRX_TYPE_NAME,
                      DR_BATCH_SOURCE_NAME,
                      DR_BATCH_SOURCE_ID,
                      DR_TERM_NAME,
                      DR_TERM_ID,
                      DR_INTERFACE_LINE_CONTEXT,
                      DR_LINE_TYPE,
                      DR_CURRENCY_CODE,
                      DR_CONVERSION_RATE,
                      DR_CONVERSION_TYPE,
                      DR_ORG_ID,
                      DR_UOM_CODE,
                      AMOUNT_INCLUDES_XX_FLAG,
                      DUE_DATE,
                      ORIG_IRT_RETURN_DATE,
                      DAYS_DELAY_ASSESEE,
                      IRT_APPROVAL_DATE,
                      XX_COMPUTED,
                      MATCHED_CLAIMS_AMT,
                      REFD_COMPUTED_AMT,
                      RECEIPT_STATUS,
                      ATTRIBUTE6,
                      ATTRIBUTE7,
                      ATTRIBUTE8,
                      ATTRIBUTE9,
                      ATTRIBUTE10,
                      RELAX_FLAG,
                      DAYS
                    FROM xx_Ar_Trans_Stg
                    WHERE Transaction_Number=P_In_Irt_Id
                  );
                --changes end  for hotfix#171907
                UPDATE xxcus.xx_rfnd_adj_after_acnt
                SET status_code         ='ERROR',
                  ERROR_MESSAGE         ='BLOCKED BY IBA'
                WHERE TRANSACTION_NUMBER=P_IN_IRT_ID;
              END;
            END IF;
            SELECT COUNT(1)
            INTO v_count1
            FROM xxcus.xx_irt_RO_accounting_notice
            WHERE irt_id =p_in_irt_id;
            IF (v_count1 =0) THEN
              INSERT
              INTO xxcus.xx_irt_RO_accounting_notice
                (
                  irt_id,
                  creation_date ,
                  fas_udpt_date,
                  --added for cr 602 starts
                  ETL_RD_FLG,
                  REVISED_FLAG,
                  ID_CD,
                  ASSMENT_YEAR
                  --added for cr 602 ends
                )
                VALUES
                (
                  p_in_irt_id,
                  sysdate,
                  sysdate,
                  --added for cr 602 starts
                  'N',
                  'N',
                  ( SELECT DISTINCT bill_to_customer_number
                  FROM xx_ar_trans_stg
                  WHERE transaction_number=p_in_irt_id
                  ) ,
                  ( SELECT DISTINCT assessment_year
                  FROM xx_ar_trans_stg
                  WHERE transaction_number=p_in_irt_id
                  )
                  --added for cr 602 ends
                );
              write_debug ( g_debug_flag ,'recs inserted into xx_rfnd_adj_after_acnt is'|| sql%rowcount ) ;
            END IF;
          EXCEPTION
          WHEN OTHERS THEN
            p_out_chr_retcode := 2;
            p_out_chr_errbuff := 'Error while insert into xx_rfnd_adj_after_acnt';
            write_debug ( g_debug_flag ,'Error while insert into xx_rfnd_adj_after_acnt ' ||sqlerrm ) ;
          END;
        END IF;
      EXCEPTION
      WHEN OTHERS THEN
        p_out_chr_retcode := 2;
        p_out_chr_errbuff := 'Error while insert into xx_rfnd_adj_after_acnt';
        write_debug ( g_debug_flag ,'Error while insert into xx_rfnd_adj_after_acnt '|| sqlerrm ) ;
      END;
    END IF; ---v_count>=1
  EXCEPTION
  WHEN OTHERS THEN
    p_out_chr_retcode := 2;
    p_out_chr_errbuff := 'Error while calling ro_skip_check_proc';
    write_debug ( g_debug_flag ,'Error while calling ro_skip_check_proc: '||sqlerrm ) ;
  END ro_skip_check_proc;
----*****************************New procedure added for CR_HWSW_102 End of
-- Procedure / Function *****************
-- New procedure added for CR_HWSW_0226
  PROCEDURE ro_status_check_proc
    (
      p_out_chr_errbuff OUT NOCOPY VARCHAR2,
      p_out_chr_retcode OUT NOCOPY VARCHAR2,
      p_out_ro_status OUT NUMBER,
      p_in_id_number IN VARCHAR2,
      p_in_irt_id     IN VARCHAR2,
      P_IN_IRT_AY     IN VARCHAR2
    )
  AS
    /****************************************************************************
    ***********
    * Type : Procedure
    * Name : ro_status_check_proc
    * Input Parameters : p_in_id_number,p_in_irt_id,P_IN_IRT_AY
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * p_out_excess_amount
    * p_out_ro_status
    * Purpose : For determining RO Adjust cases and preventing the same for
    refd less than 5000
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 30-Sep-2013
    * Last Reviewed By : Infosys
    * Last Reviewed Date :
    *****************************************************************************
    ***********
    * Modified Date Modified By Version Modification Type Modification Details *
    * ------------- ------------ -------- - -----------------
    -------------------------- *
    * 30-Sep-2013 Infosys 1.0 O Baseline. *
    *****************************************************************************
    ***********/
    v_count             NUMBER := 0;
    v_int_count         NUMBER := 0;
    v_dtl_count         NUMBER := 0;
    v_stg_count         NUMBER := 0;
    v_vrfd_flag_count   NUMBER := 0;
    v_tot_refd_amt    NUMBER;
    v_avl_dmd_amt    NUMBER;
    v_dmd_count         NUMBER;
    L_CONFIRMED_REC     NUMBER := 0; --ADDED AS A PART OF AO PORTAL VERIFICATION
    L_REJECTED_REC      NUMBER := 0; --ADDED AS A PART OF AO PORTAL VERIFICATION
    L_PENDING_REC_COUNT NUMBER := 0; --ADDED AS A PART OF AO PORTAL VERIFICATION
    L_NOT_ACTED_REC     NUMBER :=0;
    /*ADDED AS PART OF CR#583*/
    V_CNF_DMND_ASSESSE    NUMBER           :=0;
    V_CNF_DMND_AO         NUMBER           :=0;
    V_CNF_DMND_AO_PARTIAL NUMBER           :=0;
    V_CNF_DMND_VALUE      NUMBER           :=0;
    L_STATUS_CHK1         NUMBER           :=0;
    L_STATUS_CHK2         NUMBER           :=0;
    L_STATUS_CHK3         NUMBER           :=0;
    V_DAYS                NUMBER           :=0;
    V_RELAX_FLAG          VARCHAR2 ( 100 ) :='';
    /*ADDED AS PART OF CR#583*/
  BEGIN
    p_out_ro_status := 0;
    --Commented as a Part of CR_HWSW_0505 - Starts here
    --AO PORTAL CHANGES STARTS HERE - 17-DEC-2014 ADDED BY RAJESH - STRATS HERE
    --Commented as a Part of CR_HWSW_0558 - On 27-Jul-2016 Starts Here

    --Commented as a Part of CR_HWSW_0558 - On 27-Jul-2016 Ends Here
    --Commented as a CR_HWSW_0505 - Ends Here
    BEGIN
      -- to check if there is any prior year or subsequent year open dmd
      -- which has refd in the current processing
      SELECT COUNT(1)
      INTO v_count
      FROM xx_dmd_headers DMD ,
        xx_refd_headers HEADER
      WHERE dmd_status IN ('DMD','THRESHOLD DMD','INT DMD') --
        -- dmd_service_date condition
        -- removed for hotfix: 38679
      AND DMD.avl_refd_adjust_amount > 0
      AND DMD.MAJOR_HEAD              <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      AND HEADER.ID_NUMBER               = DMD.ID_NUMBER
      AND Header.Id_Number               = P_in_Id_Number
        --AND TO_NUMBER (HEADER.irt_ay) > TO_NUMBER (DMD.irt_ay)--changed to
        -- adjust subsequent year dmd to prior refd.
      AND HEADER.refd_status                                                                                                    = 'PCM APPROVED'
      AND HEADER.irt_id                                                                                                           = p_in_irt_id
      AND HEADER.approval_date                                                                                                   IS NOT NULL
      AND ( NVL (HEADER.total_refd_amount, 0) - NVL ( HEADER.refd_adjustment_amount, 0) - NVL (HEADER.net_refd_amount, 0) ) > 0
      AND NOT EXISTS
        (SELECT 1
        FROM xx_irt_fas_prcsng_hold XIFPH
        WHERE DMD.irt_id     = XIFPH.irt_id
        AND XIFPH.hold_flag    IN('IRT REFD HOLD', 'IRTCLAIM HOLD')
        AND XIFPH.release_flag IS NULL
        );
    EXCEPTION
    WHEN OTHERS THEN
      write_debug( g_debug_flag ,'Error while fetching count for RO adjust:'|| sqlerrm );
    END;
    write_debug( g_debug_flag ,'v_count in ro_status_chk_proc:'||v_count );
    IF v_count >= 1 THEN
      BEGIN
        /* commented below for hot fix #38385
        SELECT NVL(total_refd_amount,0)
        INTO v_tot_refd_amt
        FROM xx_refd_headers
        WHERE id_number = p_in_id_number
        AND irt_id = p_in_irt_id;
        */
        v_tot_refd_amt :=0 ; --added as a part of Hotfix#59466
        v_avl_dmd_amt :=0 ; --added as a part of Hotfix#59466
        /* Added sum keyword for hot fix #38385*/
        SELECT SUM(NVL(total_refd_amount,0))
        INTO v_tot_refd_amt
        FROM xx_refd_headers
        WHERE id_number = p_in_id_number
        AND irt_id       = p_in_irt_id;
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag , 'Error while fetching total_refd_amount from xx_refd_headers:'|| sqlerrm );
      END;
      write_debug( g_debug_flag ,'v_tot_refd_amt in ro_status_chk_proc:'|| v_tot_refd_amt );
      BEGIN --CR 226 on 18-10-2013
        SELECT SUM(avl_refd_adjust_amount)
        INTO v_avl_dmd_amt
        FROM xx_dmd_headers
        WHERE id_number             = p_in_id_number
        AND avl_refd_adjust_amount > 0
        AND MAJOR_HEAD              <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
        AND dmd_status           IN ('DMD','INT DMD','THRESHOLD DMD') ;
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag , 'Error while fetching avl_refd_adjust_amount from xx_dmd_headers:' ||sqlerrm );
      END; --CR 226 on 18-10-2013
      -- RO adjustment to be prevented only if v_tot_refd_amt >= 5000 AND
      -- v_avl_dmd_amt >= 5000
      -- p_out_ro_status is kept as 2 for such cases
      V_DMD_COUNT := 0;
      BEGIN
        SELECT COUNT(1)
        INTO V_DMD_COUNT
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xxcus.IRT_NOTICE_US_245
          WHERE IRT_ID   =P_IN_IRT_ID
          AND ETL_RD_FLAG='Y'
          );
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag ,'error while fetching v_dmd_count '||SQLERRM ) ;
      END;
      write_debug( g_debug_flag ,'V_DMD_COUNT in ro_status_chk_proc:'|| V_DMD_COUNT );
      IF ((V_TOT_REFD_AMT>=1 AND V_TOT_REFD_AMT <= 5000) OR ( V_AVL_DMD_AMT>=1 AND V_AVL_DMD_AMT <= 5000 ) ) --CR 226 on 18-10-2013   --modified condition for hotfix#165114
        --   AND v_dmd_count     > 0-- Added by RAJESH and Commented Due to
        -- HOTFIX#XYZ
        THEN
        UPDATE xx_AR_TRANS_STG xats
        SET RELAX_FLAG           ='RELAX'
        WHERE TRANSACTION_NUMBER = P_IN_IRT_ID; -- changes added for CR_608
        write_debug( g_debug_flag ,'rows updatedf='||sql%rowcount);
        write_debug( g_debug_flag , 'inside IF v_tot_refd_amt <= 5000 AND V_DMD_COUNT > 0 in ro_status_chk_proc:' );
        --p_out_ro_status := 2; COMMENTED AS PART OF CR#583
        --condition added for CR_HWSW_0226 to prevent RO adjustment
        -- for cases which has refd less than 5000
        --START OF CHANGES FOR CR#583--
        UPDATE xxcus.xx_REFD_HEADERS
        SET ATTRIBUTE15='RO_RELAX'
          --ATTRIBUTE14='FAS'
        WHERE IRT_ID =P_IN_IRT_ID; -- changes added for CR_608
        SELECT DISTINCT NVL(DAYS,0),
          NVL(RELAX_FLAG,'X')
        INTO V_DAYS,
          V_RELAX_FLAG
        FROM xxcus.xx_AR_TRANS_STG
        WHERE TRANSACTION_NUMBER=P_IN_IRT_ID;
        IF(V_DAYS               >30) THEN
          p_out_ro_status      := 2;
          write_debug( g_debug_flag , 'inside IF v_tot_refd_amt <= 5000 AND V_DMD_COUNT > 0 in ro_status_chk_proc:' );
        ELSE
          p_out_ro_status :=1;
        END IF;
        BEGIN
          write_debug( g_debug_flag , '************************************************' );
          write_debug( g_debug_flag ,'INSIDE THE BEGIN BLOCK' );
          write_debug( g_debug_flag , '************************************************' );
          SELECT COUNT(1),
            SUM(AVL_REFD_ADJUST_AMOUNT)
          INTO V_CNF_DMND_ASSESSE,
            V_CNF_DMND_VALUE
          FROM xx_DMD_HEADERS
          WHERE ID_NUMBER        =p_in_id_number
          AND NVL(ATTRIBUTE6,'X') ='Y'
          AND dmd_status      IN ('DMD')
          AND MAJOR_HEAD         <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          write_debug( g_debug_flag ,'V_CNF_DMND_ASSESSE:='||V_CNF_DMND_ASSESSE ) ;
          write_debug( g_debug_flag ,'V_CNF_DMND_VALUE:='||V_CNF_DMND_VALUE );
          SELECT COUNT(1)
          INTO L_STATUS_CHK1
          FROM xx_dmd_headers XDH
          WHERE XDH.ID_NUMBER         = P_IN_ID_NUMBER
          AND DMD_STATUS           IN ('DMD')
          AND AVL_REFD_ADJUST_AMOUNT > 100
          AND NVL(attribute6,'X')     <>'Y'
          AND XDH.MAJOR_HEAD          <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          write_debug( g_debug_flag ,'L_STATUS_CHK1:='||L_STATUS_CHK1 );
          IF ((L_STATUS_CHK1 =0)OR ( V_CNF_DMND_ASSESSE>0 AND V_CNF_DMND_VALUE>V_TOT_REFD_AMT ) ) THEN
            write_debug( g_debug_flag , 'ANY ONE OF THE DMD IS CONFIRMED BY ASSESSE SO NOT ELIGIBLE FOR RELAXATION' );
            P_OUT_RO_STATUS := 3;
            --add here
            UPDATE xxcus.xx_REFD_HEADERS
            SET ATTRIBUTE15='CONFIRMED'
              --ATTRIBUTE14='FAS'
            WHERE IRT_ID =P_IN_IRT_ID;
            /*   UPDATE xxcus.xx_AR_TRANS_STG
            SET RELAX_FLAG          ='DMD CONFIRMED'
            WHERE TRANSACTION_NUMBER=P_IN_IRT_ID;*/
            --Commented as part of CR#583 phase 2.
          END IF;
          /*ASSESSE PART CHANGES ARE DONE*/
          /*AO PART STARTS HERE*/
          SELECT NVL(SUM(AVL_REFD_ADJUST_AMOUNT),0),
            COUNT(1)
          INTO V_CNF_DMND_AO_PARTIAL,
            V_CNF_DMND_AO
          FROM xx_DMD_HEADERS
          WHERE ID_NUMBER        =p_in_id_number
          AND NVL(ATTRIBUTE1,'X') ='Y'
          AND dmd_status      IN ('DMD')
          AND MAJOR_HEAD         <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          write_debug( g_debug_flag ,'V_CNF_DMND_AO_PARTIAL:='|| V_CNF_DMND_AO_PARTIAL );
          write_debug( g_debug_flag ,'V_CNF_DMND_AO:='||V_CNF_DMND_AO );
          SELECT COUNT(1)
          INTO L_STATUS_CHK2
          FROM xx_dmd_headers XDH
          WHERE XDH.ID_NUMBER         = P_IN_ID_NUMBER
          AND DMD_STATUS           IN ('DMD')
          AND AVL_REFD_ADJUST_AMOUNT > 100
          AND NVL(attribute6,'X')      ='Y'
          AND XDH.MAJOR_HEAD          <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          ---HERE DOUBT IS THERE PLEASE CLARIFY WHENEVER FREE
          /* SELECT COUNT(1)
          INTO L_STATUS_CHK3
          FROM xx_dmd_headers XDH
          WHERE XDH.ID_NUMBER         = P_IN_ID_NUMBER
          AND DMD_STATUS           IN ('DMD')
          AND AVL_REFD_ADJUST_AMOUNT > 100
          AND NVL(attribute1,'X')     <>'Y'
          AND attribute6              IS NULL;*/
          --commented in CR#583 phase 2 as not required.
          write_debug( g_debug_flag ,'L_STATUS_CHK2:='||L_STATUS_CHK2 );
          write_debug( g_debug_flag ,'V_DAYS:='||V_DAYS );
          write_debug( g_debug_flag ,'V_RELAX_FLAG:='||V_RELAX_FLAG );
          --  IF(V_DAYS                  >30 AND V_RELAX_FLAG='RELAX')--COMMENTED
          -- FOR AO_RELAXATION cr608
          IF(V_RELAX_FLAG            ='RELAX') THEN
            IF((V_CNF_DMND_AO_PARTIAL>V_TOT_REFD_AMT) OR L_STATUS_CHK2>0 OR V_CNF_DMND_AO >0) THEN
              WRITE_DEBUG( G_DEBUG_FLAG , 'ANY ONE OF THE DMD IS CONFIRMED BY AO SO NOT ELIGIBLE FOR RELAXATION AND 30 DAYS ARE OVER' );
              P_OUT_RO_STATUS := 3;
              UPDATE xxcus.xx_REFD_HEADERS
              SET ATTRIBUTE15='CONFIRMED'
              WHERE IRT_ID   =P_IN_IRT_ID;
            END IF;
          END IF;
          --ADD HERE
        EXCEPTION
        WHEN OTHERS THEN
          write_debug( g_debug_flag ,'EXCEPTION'||sqlerrm);
        END;
        ------------END OF CHANGES FOR CR#0583------------  -
        BEGIN
          UPDATE xxcus.irt_notice_us_245
          SET ro_adjust = 'Y'
          WHERE irt_id  = P_IN_IRT_ID;
        EXCEPTION
        WHEN OTHERS THEN
          write_debug( g_debug_flag ,'error while updating ro_adjust flag'|| SQLERRM );
        END;
        write_debug( g_debug_flag ,'v_tot_refd_amt: '||v_tot_refd_amt );
        write_debug( g_debug_flag ,'v_avl_dmd_amt: '||v_avl_dmd_amt );
        write_debug( g_debug_flag ,'v_dmd_count: '||v_dmd_count );
        write_debug( g_debug_flag ,'p_out_ro_status in ro_status_chk_proc:'|| p_out_ro_status );
      END IF;
    ELSE
      P_OUT_RO_STATUS := 0;
      write_debug( g_debug_flag , 'inside else p_out_ro_status in ro_status_chk_proc:'||p_out_ro_status );
    END IF;
    write_debug( g_debug_flag , 'value of p_out_ro_status from ro_status_check_proc: '||p_out_ro_status );
    P_OUT_CHR_RETCODE := 0;
    --end if; --Commented as a Part of CR_HWSW_0558 - On 27-Jul-2016
    --END IF; --Commented as a Part of CR_HWSW_0558 - On 27-Jul-2016
  EXCEPTION
  WHEN OTHERS THEN
    p_out_chr_retcode := 2;
    p_out_chr_errbuff := 'Error while calling ro_status_check_proc';
    write_debug( g_debug_flag ,'Error while calling ro_status_check_proc: '|| sqlerrm );
  END;
----*****************************New procedure added for CR_HWSW_0226 End of
-- Procedure / Function *****************
  PROCEDURE excess_400_proc(
      p_out_chr_errbuff OUT VARCHAR2,
      P_OUT_CHR_RETCODE OUT NUMBER,
      p_skip_ro_status_1 OUT NUMBER,  --added for HF_176638 on 16-May-2018
      p_relaxation_flag_1 OUT NUMBER, --added for HF_176638 on 16-May-2018
      p_in_irt_id  IN VARCHAR2,
      p_in_id_num IN VARCHAR2 )
  AS
    /****************************************************************************
    ****************************************
    * Type : Procedure
    * Name : EXCESS_400_PROC
    * Input Parameters : p_in_irt_id
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * Purpose : Procedure to process excess 400 collections
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 01-Feb-2012
    * Last Reviewed By :
    * Last Reviewed Date :
    *****************************************************************************
    *********************************** */
    l_customer_trx_date    DATE;
    l_num_recipt_sts_count NUMBER;
    l_num_ref_line_count   NUMBER;
    l_uniq_ref_id          NUMBER;
    l_cust_trx_id          NUMBER;
    l_interest_amount      NUMBER;
    l_line_int_amount      NUMBER;
    l_head_int_amount      NUMBER;
    l_refd_amount        NUMBER;
    l_roundoff_amount      NUMBER;
    l_writeoff_amount      NUMBER;
    l_apply_amount         NUMBER;
    l_num_line_int_count   NUMBER;
    l_num_head_int_count   NUMBER;
    l_num_line_rrd_count   NUMBER;
    l_num_head_rrd_count   NUMBER;
    l_ref_header_exists    VARCHAR2 (1);
    l_status               VARCHAR2 (1);
    l_chr_int_retcode      VARCHAR2 (10);
    l_chr_writeoff_retcode VARCHAR2 (10);
    l_chr_rrd_retcode      VARCHAR2 (10);
    l_chr_exe_location     VARCHAR2 (10);
    l_stmt_processing      VARCHAR2 (250);
    l_chr_retcode          VARCHAR2 (20);
    l_chr_errbuff          VARCHAR2 (100);
    l_chr_writeoff_errbuff VARCHAR2 (5000);
    l_chr_int_errbuff      VARCHAR2 (5000);
    l_chr_rrd_errbuff      VARCHAR2 (5000);
    v_count                NUMBER;                       --added for CR_HWSW_102
    v_irt_ay "process_store"."irt_process_control_mstr"."assessment_year"@psql_process_fas%TYPE; --added for CR_HWSW_102
    l_chr_proc_name       VARCHAR2 (50) := 'excess_400_proc';
    v_irt_id              VARCHAR2(250); --added for CR_HWSW_102
    v_id_num             VARCHAR2(250); --added for CR_HWSW_102
    custom_exception      EXCEPTION;
    p_out_excess_amount   NUMBER; --added for CR_HWSW_102
    P_OUT_REF_400_DATE    DATE;   --added for CR_HWSW_102
    p_out_prev_400_int    NUMBER; --added for CR_HWSW_102
    p_out_ret_type        NUMBER; --added for CR_HWSW_102
    v_rrd_exists          NUMBER; --added for CR_HWSW_102
    v_test_avl_amount     NUMBER;
    p_out_ro_status       NUMBER; --added for CR_HWSW_0226
    V_REF_400_INT_TO_DATE DATE;   --Added for CR_230
    V_FILING_DT           DATE;   --Added as a Part of Delay Interest Calculation -
    -- 11-JUN-2016
    p_skip_ro_status NUMBER;                                        --added for cr 602
    L_1192B_FLAG IRT_PERSONAL_INFO.REFD_244A_INT_1192B_FLAG%TYPE; --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha
  TYPE tbl_cash_receipt_id
IS
  TABLE OF ar_cash_receipts_all.cash_receipt_id%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_receipt_status
IS
  TABLE OF ar_cash_receipts_all.attribute15%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_reference_id
IS
  TABLE OF xx_refd_headers.reference_id%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_irt_id
IS
  TABLE OF xx_refd_headers.irt_id%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_customer_trx_id
IS
  TABLE OF xx_refd_headers.customer_trx_id%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_id_number
IS
  TABLE OF xx_refd_headers.id_number%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_irt_ay
IS
  TABLE OF xx_refd_headers.irt_ay%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_major_head
IS
  TABLE OF xx_refd_headers.major_head%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_schedule_type
IS
  TABLE OF xx_refd_headers.irt_schedule_type%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_ref_400_identified_amt
IS
  TABLE OF xx_refd_headers.ref_400_identify_amt%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_ref_400_total_amt
IS
  TABLE OF xx_refd_headers.total_400_ref_amt%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_approval_date
IS
  TABLE OF xx_refd_headers.approval_date%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_total_xx_computed
IS
  TABLE OF xx_refd_headers.total_xx_computed%TYPE INDEX BY BINARY_INTEGER ;
TYPE tbl_irt_returns_due_date
IS
  TABLE OF xx_refd_headers.irt_returns_due_date%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_customer_trx_date
IS
  TABLE OF xx_refd_headers.customer_trx_date%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_minor_head
IS
  TABLE OF ar_cash_receipts_all.attribute2%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_ref_crossadj_amt
IS
  TABLE OF xx_refd_lines.refd_crossadjust_amount%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_excess_400rec_amt
IS
  TABLE OF xx_refd_lines.excess_receipt_amount%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_ref_adj_amt
IS
  TABLE OF xx_refd_lines.refd_adjustment_amount%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_ref_roundoff_amt
IS
  TABLE OF xx_refd_lines.refd_roundoff_amount%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_net_ref_amt
IS
  TABLE OF xx_refd_lines.net_refd_amount%TYPE INDEX BY BINARY_INTEGER;
TYPE tbl_receipt_date
IS
  TABLE OF ar_cash_receipts_all.receipt_date%TYPE INDEX BY BINARY_INTEGER;
TYPE g_cash_receipts_rec
IS
  RECORD
  (
    cash_receipt_id tbl_cash_receipt_id,
    receipt_status tbl_receipt_status,
    excess_400rec_amt tbl_excess_400rec_amt );
TYPE g_refd_header_rec
IS
  RECORD
  (
    reference_id tbl_reference_id,
    irt_id tbl_irt_id,
    customer_trx_id tbl_customer_trx_id,
    id_number tbl_id_number,
    irt_ay tbl_irt_ay,
    major_head tbl_major_head,
    schedule_type tbl_schedule_type,
    ref_400_identified_amt tbl_ref_400_identified_amt,
    ref_400_total_amt tbl_ref_400_total_amt,
    approval_date tbl_approval_date,
    total_xx_computed tbl_total_xx_computed,
    irt_returns_due_date tbl_irt_returns_due_date,
    customer_trx_date tbl_customer_trx_date );
TYPE g_refd_header_upd_rec
IS
  RECORD
  (
    id_number tbl_id_number,
    asst_year tbl_irt_ay,
    major_head tbl_major_head,
    schedule_type tbl_schedule_type,
    ref_400_identified_amt tbl_ref_400_identified_amt,
    ref_400_total_amt tbl_ref_400_total_amt,
    ref_400_int_date tbl_approval_date );
TYPE g_refd_lines_rec
IS
  RECORD
  (
    reference_id tbl_reference_id,
    cash_receipt_id tbl_cash_receipt_id,
    minor_head tbl_minor_head,
    receipt_ay tbl_irt_ay,
    excess_400rec_amt tbl_excess_400rec_amt,
    ref_roundoff_amt tbl_ref_roundoff_amt,
    ref_adj_amt tbl_ref_adj_amt,
    net_ref_amt tbl_net_ref_amt,
    ref_crossadj_amt tbl_ref_crossadj_amt,
    receipt_date tbl_receipt_date );
TYPE g_refd_lines_int_rec
IS
  RECORD
  (
    reference_id tbl_reference_id,
    interest_amt tbl_excess_400rec_amt,
    cash_receipt_id tbl_cash_receipt_id );
TYPE g_refd_line_rrd_rec
IS
  RECORD
  (
    reference_id tbl_reference_id,
    roundoff_amt tbl_excess_400rec_amt,
    cash_receipt_id tbl_cash_receipt_id );
TYPE g_refd_head_int_rec
IS
  RECORD
  (
    reference_id tbl_reference_id,
    interest_amt tbl_excess_400rec_amt,
    irt_id tbl_irt_id );
TYPE g_refd_head_rrd_rec
IS
  RECORD
  (
    reference_id tbl_reference_id,
    roundoff_amt tbl_excess_400rec_amt );
  g_cash_receipts_tbl g_cash_receipts_rec;
  g_refd_header_tbl g_refd_header_rec;
  g_refd_header_upd_tbl g_refd_header_upd_rec;
  g_refd_lines_tbl g_refd_lines_rec;
  g_refd_line_int_tbl g_refd_lines_int_rec;
  g_refd_head_int_tbl g_refd_head_int_rec;
  g_refd_head_rrd_tbl g_refd_head_rrd_rec;
  g_refd_line_rrd_tbl g_refd_line_rrd_rec;
  CURSOR cur_inv_trans ( p_id_num VARCHAR2)
  IS
    SELECT rcta.attribute5 id_number,
      rcta.attribute4 assmt_year,
      rcta.attribute11 irt_id,
      TO_DATE (rcta.attribute3,'DD-MON-RRRR') irt_approval_date,
      TO_DATE (rcta.attribute13,'DD-MON-RRRR') irt_due_date
    FROM ra_customer_trx_all rcta,
      ra_cust_trx_types_all rctta
    WHERE rcta.cust_trx_type_id = rctta.cust_trx_type_id
    AND rctta.attribute2       IN ('REVISED', 'RECTIFICATION', 'RR REFD RCVBL')
    AND rcta.attribute9         = 'PCM CLOSED'
    AND rcta.attribute5         = p_id_num  
    AND EXISTS
      (SELECT 1
      FROM ar_cash_receipts_all acr
      WHERE acr.attribute4                                      = rcta.attribute4
      AND acr.attribute5                                        = rcta.attribute5
      AND acr.attribute1                                       IN ('0020', '0021', '0026')
      AND acr.attribute2                                        = '400'
      AND acr.status                                            = 'UNAPP'
      AND acr.attribute15                                       ='MATCHED'
      AND acr.attribute12                                      IS NOT NULL
      AND NVL (TO_NUMBER (acr.global_attribute10), acr.amount ) > 0
      )
  GROUP BY rcta.attribute5,
    rcta.attribute4,
    rcta.attribute11,
    TO_DATE (rcta.attribute3, 'DD-MON-RRRR'),
    TO_DATE (rcta.attribute13, 'DD-MON-RRRR');
  CURSOR cur_excess_400collect_recpt ( in_id_number IN VARCHAR2, in_assmt_year IN VARCHAR2 )
  IS
    SELECT acr.cash_receipt_id,
      NVL (TO_NUMBER (acr.global_attribute10), acr.amount) amount,
      acr.pay_from_customer,
      acr.receipt_number,
      acr.receipt_date,
      acr.attribute4 assmt_year,
      NVL (TO_NUMBER (acr.global_attribute10), acr.amount ) claim_amount,
      acr.attribute5 customer_number,
      acr.attribute1 major_head,
      acr.attribute2 minor_head,
      acr.attribute15
    FROM ar_cash_receipts_all acr
    WHERE acr.attribute5                                     = in_id_number
    AND acr.attribute4                                       = in_assmt_year
    AND acr.attribute1                                      IN ('0020', '0021', '0026')
    AND NVL (TO_NUMBER (acr.global_attribute10), acr.amount) > 0
    AND acr.status                                           = 'UNAPP'
    AND acr.attribute2                                       = '400'
    AND acr.attribute15                                      ='MATCHED'
    AND acr.attribute12                                     IS NOT NULL
    AND NOT EXISTS
      (SELECT 1
      FROM xx_Dup_Chk_Inst_Gtt Xdg
      WHERE acr.cash_receipt_id = Xdg.cASH_RECEIPT_ID
      ) -- Global temp table added for CR_HWSW_102
  ORDER BY acr.attribute5,
    acr.attribute4,
    acr.attribute1;
  CURSOR cur_refd_head_int_cal
  IS
    SELECT xrh.reference_id,
      xrh.irt_id,
      xrh.customer_trx_id,
      xrh.id_number,
      xrh.irt_ay,
      xrh.major_head,
      xrh.irt_schedule_type,
      xrh.total_400_ref_amt,
      xrh.ref_400_int_amt,
      xrh.ref_400_identify_amt,
      xrh.total_xx_computed,
      xrh.customer_trx_date,
      xrh.ref_400_int_to_date
    FROM xx_refd_headers xrh
    WHERE xrh.refd_status              IN ('AWAITING APPROVAL')
    AND NVL (xrh.ref_400_identify_amt, 0) > 0
    AND NVL (xrh.ref_400_int_amt, 0)      = 0
    AND irt_id                            = p_in_irt_id;
  CURSOR cur_refd_line_int_cal (p_in_reference_id NUMBER)
  IS
    SELECT reference_id,
      receipt_date,
      excess_receipt_amount,
      cash_receipt_id
    FROM xx_refd_lines
    WHERE reference_id          = p_in_reference_id
    AND minor_head              = '400'
    AND NVL (int_amount_400, 0) = 0;
  CURSOR cur_refd_header_roundoff
  IS
    SELECT reference_id,
      irt_ay assmt_year,
      major_head,
      irt_id,
      NVL (total_400_ref_amt, 0) total_400_ref_amt,
      NVL (ref_400_int_amt, 0),
      approval_date
    FROM xx_refd_headers
    WHERE refd_status = 'PCM APPROVED'
    AND irt_id          = p_in_irt_id
    ORDER BY reference_id;
BEGIN
  l_chr_proc_name    := 'excess_400_proc';
  p_out_chr_retcode  := g_chr_success_code;
  p_out_chr_errbuff  := '';
  l_chr_exe_location := 'EX4_0001';
  l_stmt_processing  := ' Entering EXCESS 400 Proc ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  write_debug( g_debug_flag , '-----------------------------------------------------------------------');
  write_debug( g_debug_flag , '*** Refd of Excess Collection with Minor Head 400 - STARTS ***');
  write_debug( g_debug_flag , '-----------------------------------------------------------------------');
  p_out_chr_errbuff       := NULL;
  P_OUT_CHR_RETCODE       := 0;
  p_skip_ro_status_1      :=0; --added for HF_176638 on 16-May-2018
  p_relaxation_flag_1     :=0 ;--added for HF_176638 on 18-June-2018
  l_num_recipt_sts_count  := 0;
  l_num_ref_line_count    := 0;
  g_cash_receipts_tbl     := NULL;
  g_refd_header_tbl     := NULL;
  g_refd_lines_tbl      := NULL;
  g_refd_header_upd_tbl := NULL;
  g_refd_line_int_tbl   := NULL;
  g_refd_head_int_tbl   := NULL;
  g_refd_head_rrd_tbl   := NULL;
  g_refd_line_rrd_tbl   := NULL;
  v_id_num               := p_in_id_num;
  v_irt_id                := p_in_irt_id;
  BEGIN
    DELETE FROM xx_Dup_Chk_Inst_Gtt; -- for CR_HWSW_102
  EXCEPTION
  WHEN OTHERS THEN
    Write_Debug( G_Debug_Flag ,'ERROR: '||Sqlerrm );
  END;
FOR rec_inv_trans IN cur_inv_trans( p_in_id_num)
LOOP
  l_chr_exe_location := 'EX4_0002';
  l_stmt_processing  := ' Entering into FOR LOOP ' ;
  dbms_output.put_line( ' Entering into EXCESS 400 Proc');
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  write_debug( g_debug_flag ,'Start of processing for:' || rec_inv_trans.id_number || ',' || rec_inv_trans.assmt_year );
  FOR rec_excess_400collect_recpt IN cur_excess_400collect_recpt ( rec_inv_trans.id_number, rec_inv_trans.assmt_year )
  LOOP
    BEGIN
      INSERT
      INTO xx_Dup_Chk_Inst_Gtt VALUES
        (
          rec_excess_400collect_recpt.CASH_RECEIPT_ID
        ); -- for CR_HWSW_102
    EXCEPTION
    WHEN OTHERS THEN
      write_debug ( g_debug_flag ,'ERROR WHILE INSERTING INTO xx_Dup_Chk_Inst_Gtt '|| SQLERRM ) ;
    END;
    BEGIN
      l_chr_exe_location := 'EX4_0003';
      l_stmt_processing  := ' Retrivnig reference_id from xx_refd_headers' ;
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      l_uniq_ref_id       := NULL;
      l_ref_header_exists := 'N';
      SELECT reference_id,
        'Y'
      INTO l_uniq_ref_id,
        l_ref_header_exists
      FROM xx_refd_headers
      WHERE id_number             = rec_excess_400collect_recpt.customer_number
      AND irt_ay                   = rec_excess_400collect_recpt.assmt_year
      AND major_head               = rec_excess_400collect_recpt.major_head
      AND rr_ref_dem_trx_id       IS NULL
      AND cancelled_refd_amount IS NULL;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      l_uniq_ref_id       := NULL;
      l_ref_header_exists := 'N';
    END;
    write_debug( g_debug_flag ,'Header Exists:' || l_ref_header_exists );
    IF l_uniq_ref_id     IS NULL THEN
      l_chr_exe_location := 'EX4_0004';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT xx_refd_headers_seq.NEXTVAL INTO l_uniq_ref_id FROM DUAL;
    END IF; -- IF l_uniq_ref_id IS NULL
    write_debug( g_debug_flag ,'400 Receipt:' || rec_excess_400collect_recpt.cash_receipt_id || ',' || rec_excess_400collect_recpt.claim_amount );
    l_num_recipt_sts_count                                         := l_num_recipt_sts_count + 1;
    g_cash_receipts_tbl.cash_receipt_id (l_num_recipt_sts_count)   := rec_excess_400collect_recpt.cash_receipt_id;
    g_cash_receipts_tbl.receipt_status (l_num_recipt_sts_count)    := 'REFD IN PROCESS';
    g_cash_receipts_tbl.excess_400rec_amt (l_num_recipt_sts_count) := rec_excess_400collect_recpt.claim_amount;
    --line data for insert into pl/sql table
    l_chr_exe_location := 'EX4_0005';
    l_stmt_processing  := ' Line data insert' ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    l_num_ref_line_count                                        := l_num_ref_line_count + 1;
    g_refd_lines_tbl.reference_id (l_num_ref_line_count)      := l_uniq_ref_id;
    g_refd_lines_tbl.cash_receipt_id (l_num_ref_line_count)   := rec_excess_400collect_recpt.cash_receipt_id;
    g_refd_lines_tbl.receipt_ay (l_num_ref_line_count)        := rec_excess_400collect_recpt.assmt_year;
    g_refd_lines_tbl.minor_head (l_num_ref_line_count)        := rec_excess_400collect_recpt.minor_head;
    g_refd_lines_tbl.excess_400rec_amt (l_num_ref_line_count) := rec_excess_400collect_recpt.claim_amount;
    g_refd_lines_tbl.ref_roundoff_amt (l_num_ref_line_count)  := 0;
    g_refd_lines_tbl.ref_adj_amt (l_num_ref_line_count)       := 0;
    g_refd_lines_tbl.net_ref_amt (l_num_ref_line_count)       := 0;
    g_refd_lines_tbl.ref_crossadj_amt (l_num_ref_line_count)  := 0;
    g_refd_lines_tbl.receipt_date (l_num_ref_line_count)      := rec_excess_400collect_recpt.receipt_date;
    IF l_ref_header_exists                                       = 'N' THEN
      BEGIN
        l_chr_exe_location:= 'EX4_0006';
        l_stmt_processing := 'Retrivnig customer_trx_id and trx_date from ra_customer_trx_all' ;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
        --IRT data Fetch for 400 Refd table population for customer_trx_id
        SELECT rct.customer_trx_id,
          rct.trx_date
        INTO l_cust_trx_id,
          l_customer_trx_date
        FROM ra_customer_trx_all rct,
          ar_payment_schedules_all arp
        WHERE rct.customer_trx_id                                                                       = arp.customer_trx_id
        AND rct.attribute5                                                                              = rec_inv_trans.id_number
        AND rct.attribute4                                                                              = rec_inv_trans.assmt_year
        AND rct.attribute1                                                                              = rec_excess_400collect_recpt.major_head
        AND rct.attribute8                                                                             IS NULL
        AND rct.attribute9                                                                              = 'PCM CLOSED'
        AND DECODE (rec_excess_400collect_recpt.major_head, '0021', 'IT', '0020', 'IT', '0026', 'FBT' ) = rct.attribute7
        AND rct.attribute11                                                                             = rec_inv_trans.irt_id;
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_chr_exe_location := 'EX4_0007';
        l_stmt_processing  := ' Retrivnig customer_trx_id and trx_date from ra_customer_trx_all(NO_DATA_FOUND Case)' ;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
        --IRT dataFetch for 400 Refd table population for customer_trx_id
        -- for scedule type IT
        BEGIN -- Added Begin end block for CR - 661 for handling any excess payments for 115TD claims on 18-FEB-2019
          SELECT rct.customer_trx_id,
            rct.trx_date
          INTO l_cust_trx_id,
            l_customer_trx_date
          FROM ra_customer_trx_all rct,
            ar_payment_schedules_all arp
          WHERE rct.customer_trx_id = arp.customer_trx_id
          AND rct.attribute5        = rec_inv_trans.id_number
          AND rct.attribute4        = rec_inv_trans.assmt_year
          AND rct.attribute7        = 'IT'
          AND rct.attribute8       IS NULL
          AND rct.attribute9        = 'PCM CLOSED'
          AND rct.attribute11       = rec_inv_trans.irt_id;
        EXCEPTION
        WHEN OTHERS THEN
          write_debug( g_debug_flag ,'No rows found in RACT for closed invoices other than IT and FBT');
          p_out_chr_errbuff := 'No rows found in RACT for closed invoices other than IT and FBT';
          raise custom_exception;
        END; -- Added Begin end block for CR - 661 for handling any excess payments for 115TD claims on 18-FEB-2019
      END;
      write_debug( g_debug_flag , 'l_cust_trx_id:' || l_cust_trx_id );
      l_chr_exe_location := 'EX4_0008';
      l_stmt_processing  := ' Insert into xx_refd_headers' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO xx_refd_headers
        (
          reference_id,
          irt_id,
          customer_trx_id,
          id_number,
          irt_ay,
          major_head,
          irt_schedule_type,
          ref_400_identify_amt,
          total_refd_amount,
          total_400_ref_amt,
          refd_adjustment_amount,
          net_refd_amount,
          refd_interest_amount,
          ref_400_int_amt,
          refd_roundoff_amount,
          rounding_400_diff,
          refd_crossadjust_amount,
          refd_identified_date,
          refd_status,
          approval_date,
          ref_to_date,
          ref_400_int_to_date,
          approval_user,
          refd_banker_status,
          Customer_name,
          Customer_address,
          payment_mode,
          total_xx_computed,
          irt_returns_due_date,
          customer_trx_date,
          last_updated_by,
          last_update_date,
          last_update_login,
          created_by,
          creation_date,
          request_id,
          process_flag,
          vld_orgirt_date
        )
        VALUES
        (
          l_uniq_ref_id,
          rec_inv_trans.irt_id,
          l_cust_trx_id,
          rec_inv_trans.id_number,
          rec_inv_trans.assmt_year,
          rec_excess_400collect_recpt.major_head,
          DECODE (rec_excess_400collect_recpt.major_head, '0021', 'IT', '0020', 'IT', '0026', 'FBT' ),
          NVL (rec_excess_400collect_recpt.claim_amount, 0 ),
          0,
          NVL (rec_excess_400collect_recpt.claim_amount, 0 ),
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          rec_inv_trans.irt_approval_date,
          'AWAITING APPROVAL',
          rec_inv_trans.irt_approval_date,
          NULL,
          rec_inv_trans.irt_approval_date,
          NULL,
          NULL,
          NULL,
          NULL,
          NULL,
          NULL,
          rec_inv_trans.irt_due_date,
          l_customer_trx_date,
          g_num_user_id,
          g_dte_sys_date,
          g_num_login_id,
          g_num_user_id,
          g_dte_sys_date,
          g_num_request_id,
          'N',
          NULL
        );
      WRITE_DEBUG ( G_DEBUG_FLAG ,'COUNT IN REFD HDRS:'||SQL%ROWCOUNT||' amt:'|| NVL ( rec_excess_400collect_recpt.claim_amount, 0 ) ) ;
	  dbms_output.put_line('COUNT IN REFD HDRS:'||SQL%ROWCOUNT||' amt:'|| NVL ( rec_excess_400collect_recpt.claim_amount, 0 ));
    ELSE
      --Header Update
      l_chr_exe_location := 'EX4_0009';
      l_stmt_processing  := ' Updating xx_refd_headers' ;
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      UPDATE xx_refd_headers
      SET ref_400_identify_amt     = NVL (ref_400_identify_amt, 0) + rec_excess_400collect_recpt.claim_amount,
        total_400_ref_amt          = NVL (total_400_ref_amt, 0)    + rec_excess_400collect_recpt.claim_amount,
        ref_400_int_to_date        = rec_inv_trans.irt_approval_date,
        refd_status              = 'AWAITING APPROVAL',
        last_update_date           = g_dte_sys_date,
        last_updated_by            = g_num_user_id,
        last_update_login          = g_num_login_id,
        request_id                 = g_num_request_id
      WHERE id_number             = rec_inv_trans.id_number
      AND irt_ay                   = rec_inv_trans.assmt_year
      AND major_head               = rec_excess_400collect_recpt.major_head
      AND rr_ref_dem_trx_id       IS NULL
      AND cancelled_refd_amount IS NULL;
    END IF; --IF l_ref_header_exists = 'N'
  END LOOP; --FOR rec_excess_400collect_recpt IN
END LOOP;   --FOR rec_inv_trans IN cur_inv_trans
l_chr_exe_location := 'EX4_0010';
l_stmt_processing  := 'Updating receipt status in ar_cash_receipts_all table' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
FORALL i IN 1 .. l_num_recipt_sts_count
UPDATE ar_cash_receipts_all
SET attribute15       = g_cash_receipts_tbl.receipt_status (i),
  global_attribute10  = TO_NUMBER (NVL (global_attribute10, amount)) - g_cash_receipts_tbl.excess_400rec_amt (i),
  last_update_date    = g_dte_sys_date,
  last_update_login   = g_num_login_id,
  last_updated_by     = g_num_user_id,
  request_id          = g_num_request_id
WHERE cash_receipt_id = g_cash_receipts_tbl.cash_receipt_id (i);
write_debug( g_debug_flag , 'Number of records updated in ar_cash_receipts_all as REFD IN PROCESS:' || l_num_recipt_sts_count );
l_chr_exe_location := 'EX4_0011';
l_stmt_processing  := 'Insert into xx_refd_lines' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
FORALL i IN 1 .. l_num_ref_line_count
INSERT
INTO xx_refd_lines
  (
    reference_id,
    cash_receipt_id,
    receipt_ay,
    minor_head,
    excess_receipt_amount,
    refd_roundoff_amount,
    refd_adjustment_amount,
    net_refd_amount,
    refd_crossadjust_amount,
    rr_refdemadj_amount,
    receipt_date,
    int_amount_400,
    last_updated_by,
    last_update_date,
    last_update_login,
    created_by,
    creation_date
  )
  VALUES
  (
    g_refd_lines_tbl.reference_id (i),
    g_refd_lines_tbl.cash_receipt_id (i),
    g_refd_lines_tbl.receipt_ay (i),
    g_refd_lines_tbl.minor_head (i),
    g_refd_lines_tbl.excess_400rec_amt (i),
    0,
    0,
    0,
    0,
    0,
    g_refd_lines_tbl.receipt_date (i),
    0,
    g_num_user_id,
    g_dte_sys_date,
    g_num_login_id,
    g_num_user_id,
    g_dte_sys_date
  );
write_debug ( g_debug_flag , 'Number of records inserted into xx_REFD_LINES' || l_num_ref_line_count ) ;
--Interest Calculation
l_chr_exe_location := 'EX4_0012';
l_stmt_processing  := 'Interest Calculation Starts' ;
write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
l_num_line_int_count := 0;
l_num_head_int_count := 0;
BEGIN
  --fetch the assessment year of the irt_id (CR_HWSW_102)
  SELECT "assessment_year"
  INTO v_irt_ay
  FROM "process_store"."irt_process_control_mstr"@psql_process_fas
  WHERE "irt_id" = P_IN_IRT_ID;
  -- check if it is a multiple rectification case (CR_HWSW_102)
  SELECT COUNT(*)
  INTO v_count
  FROM "process_store"."irt_process_control_mstr"@psql_process_fas pcm
  WHERE "id_number"            = p_in_id_num
  AND "assessment_year"         = v_irt_ay
  AND "x_val_filing_status_cd"  = 'T'
  AND "process_status_code"       = 65;
EXCEPTION
WHEN OTHERS THEN
  write_debug ( g_debug_flag ,'Error while fetching data from pcm: ' || SQLERRM ) ;
END;
FOR rec_refd_head_int_cal IN cur_refd_head_int_cal
LOOP
  write_debug ( g_debug_flag ,'Starting Interest Calculation for Ref id' || rec_refd_head_int_cal.reference_id ) ;
  l_head_int_amount := 0;
  ---------------------------------------------------------------------------------------------
--Commented the L_1192B_FLAG fetch from irt_personal_info and assigned X as default case for POC. - Bhagya
-------------------------------------------------------------------------------------------------------------
  L_1192B_FLAG := 'X';    -- Assigning to X by default for ABC-2.0 POC

  FOR rec_refd_line_int_cal IN cur_refd_line_int_cal ( rec_refd_head_int_cal.reference_id )
  LOOP
    --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha -- starts
   /* SELECT NVL(UPPER(REFD_244A_INT_1192B_FLAG),'X')
    INTO L_1192B_FLAG
    FROM IRT_PERSONAL_INFO  --not changed. Get the corresponding postgres column. ABC 2.0
    WHERE IRT_ID=P_IN_IRT_ID;
	*/
    write_debug( g_debug_flag ,'L_1192B_FLAG: '||L_1192B_FLAG);
    IF L_1192B_FLAG      = 'N' THEN
      l_line_int_amount := 0;
      write_debug( g_debug_flag ,'Setting Refd interest line amount as zero for 119(2)(B)');
    ELSIF L_1192B_FLAG IN ('Y','X') THEN
      --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha -- ends
      write_debug ( g_debug_flag , 'Ref id -' || rec_refd_line_int_cal.reference_id || ' excces recpt amt ' ||( rec_refd_line_int_cal.excess_receipt_amount - MOD ( rec_refd_line_int_cal.excess_receipt_amount, 100 ) ) || ' Approval date ' || rec_refd_head_int_cal.ref_400_int_to_date || 'Receipt Date ' || rec_refd_line_int_cal.receipt_date ) ;
      l_line_int_amount  := 0;
      l_chr_exe_location := 'EX4_0013';
      l_stmt_processing  := '400 Refd Line Interest CALC' ;
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      IF v_count >= 1 THEN
        -- For CR_HWSW_102
        EXCESS_400_MULTIPLE_RECT ( P_OUT_CHR_ERRBUFF => P_OUT_CHR_ERRBUFF, P_OUT_CHR_RETCODE => P_OUT_CHR_RETCODE, P_IN_CURRENT_IRT_ID => P_IN_IRT_ID, P_IN_ID_NUMBER => P_IN_ID_NUM, P_IN_CASH_RECEIPT_ID => REC_REFD_LINE_INT_CAL.CASH_RECEIPT_ID , P_IN_EXCESS_AMOUNT => REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT, P_OUT_EXCESS_AMOUNT => P_OUT_EXCESS_AMOUNT, P_OUT_REF_400_DATE => P_OUT_REF_400_DATE , P_OUT_PREV_400_INT => P_OUT_PREV_400_INT, P_OUT_RET_TYPE => P_OUT_RET_TYPE );
        IF p_out_chr_retcode  = g_chr_failure_code THEN
          l_chr_exe_location := 'E400_001';
          l_stmt_processing  := 'Call to excess_400_multiple_rect failed from excess 400';
          raise custom_exception;
        END IF;
      END IF;
      --400 Refd Line Interest CALC
      --interest calc logic modified for (CR_HWSW_102) based on increase in
      -- refd/decrease in refd case
      -- added below line for CR_230 (244A ) on 21-may-2014 for both decrease
      -- and increase in refd cases
      SELECT "filing_dt"
      INTO V_FILING_DT
      FROM "process_store"."interest_on_refd"@psql_process_fas
      WHERE "irt_id"             =P_IN_IRT_ID;
      IF v_count              >= 1 THEN
        V_Ref_400_Int_To_Date := NVL(P_OUT_REF_400_DATE, rec_refd_head_int_cal.ref_400_int_to_date);
      ELSE
        V_Ref_400_Int_To_Date:=rec_refd_head_int_cal.ref_400_int_to_date;
      END IF;
      IF rec_refd_line_int_cal.receipt_date < rec_refd_head_int_cal.ref_400_int_to_date THEN
        IF v_count                            = 0 OR P_OUT_RET_TYPE = 3 -- first time rectification (For
          -- CR_HWSW_102)
          THEN
          --l_line_int_amount   := ( (
          -- REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT - MOD (
          -- REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT, 100 ) ) *
          -- MONTH_INTEREST_CALC (REC_REFD_LINE_INT_CAL.RECEIPT_DATE,
          -- V_REF_400_INT_TO_DATE, 'xx_REFD_INTEREST_RATE' ) ) / 100; --
          -- Commented as a Part of CR_HWSW_0552
          --Added as a Part of Delay Interest Calcualtion - Starts Here -- 11-
          -- JUN-2016
          IF V_FILING_DT       < REC_REFD_LINE_INT_CAL.RECEIPT_DATE THEN
            L_LINE_INT_AMOUNT := ( ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT - MOD ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT, 100 ) ) * MONTH_INTEREST_CALC (REC_REFD_LINE_INT_CAL.RECEIPT_DATE, V_REF_400_INT_TO_DATE, 'xx_REFD_INTEREST_RATE' ) ) / 100;
          ELSE
            L_LINE_INT_AMOUNT := ( ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT - MOD ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT, 100 ) ) * MONTH_INTEREST_CALC (V_FILING_DT, V_REF_400_INT_TO_DATE, 'xx_REFD_INTEREST_RATE' ) ) / 100;
          END IF;
          --Added as a Part of Delay Interest Calcualtion - Ends Here - 11-JUN-
          -- 2016
          IF l_line_int_amount < 0 THEN
            l_line_int_amount := 0;
          END IF;
        ELSIF P_OUT_RET_TYPE = 0 -- increase in refd (For CR_HWSW_102)
          THEN
          --l_line_int_amount   := ( (p_out_excess_amount - MOD (
          -- p_out_excess_amount, 100 ) ) * MONTH_INTEREST_CALC (
          -- REC_REFD_LINE_INT_CAL.RECEIPT_DATE,V_REF_400_INT_TO_DATE, '
          -- xx_REFD_INTEREST_RATE' ) ) / 100; --
          -- REC_REFD_HEAD_INT_CAL.REF_400_INT_TO_DATE
          --L_LINE_INT_AMOUNT   := L_LINE_INT_AMOUNT      + p_out_prev_400_int;
          --p_out_prev_400_int(interest paid out in previous rectification) is
          -- added back to interest amount
          IF V_FILING_DT       < REC_REFD_LINE_INT_CAL.RECEIPT_DATE THEN
            l_line_int_amount := ( (p_out_excess_amount - MOD ( p_out_excess_amount, 100 ) ) * MONTH_INTEREST_CALC ( REC_REFD_LINE_INT_CAL.RECEIPT_DATE,V_REF_400_INT_TO_DATE, 'xx_REFD_INTEREST_RATE' ) ) / 100; --
            -- REC_REFD_HEAD_INT_CAL.REF_400_INT_TO_DATE
            L_LINE_INT_AMOUNT := L_LINE_INT_AMOUNT + p_out_prev_400_int;
            --p_out_prev_400_int(interest paid out in previous rectification)
            -- is added back to interest amount
          ELSE
            l_line_int_amount := ( (p_out_excess_amount - MOD ( p_out_excess_amount, 100 ) ) * MONTH_INTEREST_CALC ( V_FILING_DT,V_REF_400_INT_TO_DATE, 'xx_REFD_INTEREST_RATE' ) ) / 100; --REC_REFD_HEAD_INT_CAL.REF_400_INT_TO_DATE
            L_LINE_INT_AMOUNT := L_LINE_INT_AMOUNT      + p_out_prev_400_int;
          END IF;
          IF L_LINE_INT_AMOUNT < 0 THEN
            L_LINE_INT_AMOUNT := 0;
          END IF;
        ELSIF P_OUT_RET_TYPE = 1 -- decrease in refd (For CR_HWSW_102)
          THEN
          -- l_line_int_amount   := ( (
          -- REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT - MOD (
          -- REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT, 100 ) ) *
          -- MONTH_INTEREST_CALC (REC_REFD_LINE_INT_CAL.RECEIPT_DATE,
          -- p_out_ref_400_date, 'xx_REFD_INTEREST_RATE' ) ) / 100;
          IF V_FILING_DT       < REC_REFD_LINE_INT_CAL.RECEIPT_DATE THEN
            l_line_int_amount := ( ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT - MOD ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT, 100 ) ) * MONTH_INTEREST_CALC (REC_REFD_LINE_INT_CAL.RECEIPT_DATE, p_out_ref_400_date, 'xx_REFD_INTEREST_RATE' ) ) / 100;
          ELSE
            l_line_int_amount := ( ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT - MOD ( REC_REFD_LINE_INT_CAL.EXCESS_RECEIPT_AMOUNT, 100 ) ) * MONTH_INTEREST_CALC (V_FILING_DT, p_out_ref_400_date, 'xx_REFD_INTEREST_RATE' ) ) / 100;
          END IF;
          IF L_LINE_INT_AMOUNT < 0 THEN
            L_LINE_INT_AMOUNT := 0;
          END IF;
        END IF; --IF v_count = 0 OR P_OUT_RET_TYPE = 3 OR P_OUT_RET_TYPE = 4
      END IF;   -- IF rec_refd_line_int_cal.receipt_date <
    END IF;     -- L_1192B_FLAG = 'N' --Added for 119(2)(b) CR#639 on 9-Mar-2018 by Sudha
    write_debug( g_debug_flag , 'Interest Calculated for Receipt:' || rec_refd_line_int_cal.cash_receipt_id || ' is ' || l_line_int_amount );
    l_num_line_int_count                                         := l_num_line_int_count + 1;
    g_refd_line_int_tbl.reference_id (l_num_line_int_count)    := rec_refd_line_int_cal.reference_id;
    g_refd_line_int_tbl.interest_amt (l_num_line_int_count)    := ROUND ( l_line_int_amount, 0);
    g_refd_line_int_tbl.cash_receipt_id (l_num_line_int_count) := rec_refd_line_int_cal.cash_receipt_id;
    l_head_int_amount                                            := l_head_int_amount + l_line_int_amount;
  END LOOP; --FOR rec_refd_line_int_cal IN
  l_num_head_int_count                                      := l_num_head_int_count + 1;
  g_refd_head_int_tbl.reference_id (l_num_head_int_count) := rec_refd_head_int_cal.reference_id;
  g_refd_head_int_tbl.interest_amt (l_num_head_int_count) := ROUND ( l_head_int_amount, 0);
  g_refd_head_int_tbl.irt_id (l_num_head_int_count)       := rec_refd_head_int_cal.irt_id;
END LOOP; --FOR rec_refd_head_int_cal IN cur_refd_head_int_cal
l_chr_exe_location := 'EX4_0014';
l_stmt_processing  := '400 Refd Interest Amount line update -POST INTEREST CALC' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
--400 Refd Interest Amount line update -POST INTEREST CALC
FORALL i IN 1 .. l_num_line_int_count
UPDATE xx_refd_lines
SET int_amount_400  = NVL (int_amount_400, 0) + g_refd_line_int_tbl.interest_amt (i)
WHERE reference_id  = g_refd_line_int_tbl.reference_id (i)
AND cash_receipt_id = g_refd_line_int_tbl.cash_receipt_id (i);
write_debug( g_debug_flag , 'Number of records updated in xx_refd_lines :' || l_num_line_int_count ) ;
l_chr_exe_location := 'EX4_0015';
l_stmt_processing  := '400 interest amount and Total Refd Amount update -POST INTEREST CALC' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
--400 interest amount and Total Refd Amount update -POST INTEREST CALC
FORALL i IN 1 .. l_num_head_int_count
UPDATE xx_refd_headers
SET ref_400_int_amt = NVL (g_refd_head_int_tbl.interest_amt (i), 0),
  total_400_ref_amt = ref_400_identify_amt + NVL ( g_refd_head_int_tbl.interest_amt (i), 0)
WHERE reference_id  = g_refd_head_int_tbl.reference_id (i);
write_debug( g_debug_flag ,'Number of records updated in xx_refd_hdr :' || l_num_head_int_count );
FOR i IN 1 .. l_num_head_int_count
LOOP
  l_interest_amount  := NULL;
  l_chr_exe_location := 'EX4_0016';
  l_stmt_processing  := 'Retriving ref_400_int_amt from xx_refd_headers ' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  SELECT NVL (ref_400_int_amt, 0)
  INTO l_interest_amount
  FROM xx_refd_headers
  WHERE reference_id    = g_refd_head_int_tbl.reference_id (i);
  IF l_interest_amount  > 0 THEN
    l_chr_int_errbuff  := NULL;
    l_chr_int_retcode  := NULL;
    l_chr_exe_location := 'EX4_0017';
    l_stmt_processing  := '400 interest receipt creation -POST INTEREST CALC ' ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    -- 400 interest receipt creation -POST INTEREST CALC
    interest_recpt_proc ( p_out_chr_errbuff => l_chr_int_errbuff, p_out_chr_retcode => l_chr_int_retcode, in_num_reference_id => g_refd_head_int_tbl.reference_id (i), in_num_receipt_amount => l_interest_amount, in_chr_flag => 'IRF4', in_chr_irt_id => g_refd_head_int_tbl.irt_id (i) );
    IF l_chr_int_retcode <> 0 THEN
      p_out_chr_errbuff  := '400 interest receipt creation -POST INTEREST CALC ' || '-' || l_chr_int_errbuff;
	  dbms_output.put_line('400 interest receipt creation -POST INTEREST CALC ' || '-' || l_chr_int_errbuff);
      RAISE custom_exception;
    END IF;
  END IF; -- IF l_interest_amount > 0
END LOOP; --FOR i IN 1 .. l_num_head_int_count
l_chr_exe_location := 'EX4_0018';
l_stmt_processing  := '400 Auto Approval' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
--400 Auto Approval
UPDATE xx_refd_headers
SET refd_status    = 'PCM APPROVED'
WHERE refd_status IN ('NEW', 'AWAITING APPROVAL')
AND request_id       = g_num_request_id;
--Rounding Off calculation
l_num_line_rrd_count := 0;
l_num_head_rrd_count := 0;
l_chr_exe_location   := 'EX4_0019';
l_stmt_processing    := 'Rounding Off calculation - Starts' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
FOR rec_refd_header_roundoff IN cur_refd_header_roundoff
LOOP
  write_debug( g_debug_flag , 'Reference Id : ' || rec_refd_header_roundoff.reference_id );
  l_refd_amount    := NULL;
  l_roundoff_amount  := NULL;
  l_status           := NULL;
  l_chr_exe_location := 'EX4_0020';
  l_stmt_processing  := ' Calling roundoff_calc function' ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  l_status := roundoff_calc (rec_refd_header_roundoff.total_400_ref_amt, l_refd_amount, l_roundoff_amount );
  write_debug( g_debug_flag ,'Refd Amount: ' || l_refd_amount );
  write_debug( g_debug_flag ,'Roundoff Amount : ' || l_roundoff_amount );
  write_debug( g_debug_flag , 'status : ' || l_status);
  IF l_status            = 0 THEN
    l_chr_rrd_errbuff   := NULL;
    l_chr_rrd_retcode   := NULL;
    l_writeoff_amount   := NULL;
    l_apply_amount      := NULL;
    IF l_roundoff_amount < 0 THEN
      l_writeoff_amount := -l_roundoff_amount;
      FOR k               IN
      (SELECT cash_receipt_id,
        ( excess_receipt_amount - refd_crossadjust_amount - refd_roundoff_amount )amount
      FROM xx_refd_lines
      WHERE reference_id = rec_refd_header_roundoff.reference_id
      AND minor_head                  IN ('400', 'IRF4')
      ORDER BY ( excess_receipt_amount - refd_crossadjust_amount - refd_roundoff_amount ) DESC
      )
      LOOP
        IF l_writeoff_amount <= k.amount THEN
          l_apply_amount     := l_writeoff_amount;
        ELSE
          l_apply_amount := k.amount;
        END IF; --IF l_writeoff_amount <= k.amount
        IF l_writeoff_amount <> 0 THEN
          l_chr_exe_location := 'EX4_0021';
          l_stmt_processing  := ' Calling xx_writeoff_proc procedure' ;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          writeoff_proc (p_out_chr_errbuff => l_chr_writeoff_errbuff, p_out_chr_retcode => l_chr_writeoff_retcode, in_num_cash_receipt_id => k.cash_receipt_id, in_num_writeoff_amount => l_apply_amount, in_chr_appl_flag => 'ROUNDING DIFF', in_chr_major_head => rec_refd_header_roundoff.major_head, in_chr_assmt_year => rec_refd_header_roundoff.assmt_year, in_dte_apply_date => g_dte_sys_date, p_in_irt_id => p_in_irt_id );
          IF l_chr_writeoff_retcode <> '0' THEN
            write_debug( g_debug_flag , 'Error in Writeoff for ROUNDING DIFF for 400 ' || '-' || l_chr_writeoff_errbuff || ' _ ' );
            p_out_chr_errbuff := p_out_chr_errbuff || 'Error in Writeoff for ROUNDING DIFF for 400 ' || '-' || l_chr_writeoff_errbuff || ' _ ';
            RAISE custom_exception;
          END IF; -- IF l_chr_writeoff_retcode <> '0'
          l_num_line_rrd_count                                         := l_num_line_rrd_count + 1;
          g_refd_line_rrd_tbl.reference_id (l_num_line_rrd_count)    := rec_refd_header_roundoff.reference_id;
          g_refd_line_rrd_tbl.cash_receipt_id (l_num_line_rrd_count) := k.cash_receipt_id;
          g_refd_line_rrd_tbl.roundoff_amt (l_num_line_rrd_count)    := -
          l_apply_amount;
        END IF; --IF l_writeoff_amount <> 0
        l_writeoff_amount := l_writeoff_amount - l_apply_amount;
        EXIT
      WHEN l_writeoff_amount = 0;
      END LOOP; --FOR k IN
    ELSIF l_roundoff_amount > 0 THEN
      write_debug( g_debug_flag ,rec_refd_header_roundoff.reference_id);
      write_debug( g_debug_flag , l_roundoff_amount);
      write_debug( g_debug_flag ,rec_refd_header_roundoff.irt_id );
      l_chr_exe_location := 'EX4_0022';
      l_stmt_processing  := ' Calling xx_interest_recpt_proc procedure' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      interest_recpt_proc (l_chr_rrd_errbuff, l_chr_rrd_retcode, rec_refd_header_roundoff.reference_id, l_roundoff_amount, 'RRD4', rec_refd_header_roundoff.irt_id );
      write_debug( g_debug_flag , l_chr_rrd_retcode);
      write_debug( g_debug_flag , l_chr_rrd_errbuff);
      IF l_chr_rrd_retcode <> '0' THEN
        p_out_chr_errbuff  := 'Error in receipt creation for 400 ROUNDING DIFF ' || '-' || l_chr_rrd_errbuff ;
        write_debug( g_debug_flag ,p_out_chr_errbuff);
        RAISE custom_exception;
      END IF; --IF l_chr_rrd_retcode <> '0'
    END IF;   -- IF l_roundoff_amount < 0
    l_num_head_rrd_count                                      := l_num_head_rrd_count + 1;
    g_refd_head_rrd_tbl.reference_id (l_num_head_rrd_count) := rec_refd_header_roundoff.reference_id;
    g_refd_head_rrd_tbl.roundoff_amt (l_num_head_rrd_count) := NVL ( l_roundoff_amount, 0);
  END IF; --IF l_status = 0
END LOOP; --FOR rec_refd_header_roundoff IN cur_refd_header_roundoff
l_chr_exe_location := 'EX4_0023';
l_stmt_processing  := ' Updating refd_roundoff_amount in xx_refd_lines ' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
FORALL i IN 1 .. l_num_line_rrd_count
UPDATE xx_refd_lines
SET refd_roundoff_amount = g_refd_line_rrd_tbl.roundoff_amt (i)
WHERE reference_id         = g_refd_line_rrd_tbl.reference_id (i)
AND cash_receipt_id        = g_refd_line_rrd_tbl.cash_receipt_id (i);
l_chr_exe_location        := 'EX4_0024';
l_stmt_processing         := ' Total 400 Refd Amount update in headers after roundoff CALC ' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
FORALL i IN 1 .. l_num_head_rrd_count
UPDATE xx_refd_headers
SET total_400_ref_amt = NVL(total_400_ref_amt,0) + NVL( g_refd_head_rrd_tbl.roundoff_amt (i),0),
  rounding_400_diff   = NVL(g_refd_head_rrd_tbl.roundoff_amt (i),0),
  net_refd_amount   = NVL(net_refd_amount,0) + NVL(total_400_ref_amt,0) + NVL(g_refd_head_rrd_tbl.roundoff_amt (i),0)
WHERE reference_id    = g_refd_head_rrd_tbl.reference_id (i);
l_chr_exe_location   := 'EX4_0025';
l_stmt_processing    := 'Updating refd status at the end of 400 refd prcessing ' ;
write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
--RRD Adjustment after interest calculation
--changes for CR_HWSW_102
UPDATE xx_refd_headers
SET total_refd_amount = NVL(total_refd_amount,0) + NVL(total_400_ref_amt,0)
  --NVL added for Hotfix #26407
WHERE irt_id = p_in_irt_id;
write_debug( g_debug_flag ,'Updating total_refd_amount: '||SQL%ROWCOUNT );
v_rrd_exists := 0;
BEGIN
  SELECT COUNT(1)
  INTO v_rrd_exists
  FROM ra_customer_trx_all rat
  WHERE attribute5 = p_in_id_num
  AND attribute9   = 'RR REF DEM'
  AND EXISTS
    (SELECT 1
    FROM xx_400_rrd_int xri
    WHERE xri.customer_trx_id = rat.customer_trx_id
    AND XRI.CNV_FLAG          ='Y'--ADDED AS PART OF HOTFIX#140734
    );
EXCEPTION
WHEN NO_DATA_FOUND THEN
  v_rrd_exists := 0;
WHEN OTHERS THEN
  write_debug( g_debug_flag ,'Error while querying ra_customer_trx_all: '|| SQLERRM );
END;
IF v_rrd_exists > 0 THEN
  Prior_refd_receipt_adjust ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => v_id_num, p_in_irt_id => v_irt_id, p_in_rrd_call => 'E400' );
  IF p_out_chr_retcode  = g_chr_failure_code THEN
    l_chr_exe_location := 'E400_01';
    l_stmt_processing  := ' Call to Prior refd receipt adjust Failed from excess 400';
    RAISE custom_exception;
  END IF;
  write_debug( g_debug_flag ,' Calling Dmd Populate proc from Excess 400' );
  dmd_populate_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_irt_id => v_irt_id, p_in_rrd_call => 'E400');
  IF p_out_chr_retcode  = g_chr_failure_code THEN
    l_chr_exe_location := 'E400_02';
    l_stmt_processing  := ' Call to Dmd Populate Proc failed from excess 400';
    raise custom_exception;
  END IF;
END IF;
-- changes made for hotfix: 40077
Write_Msg( G_Write_Logfile , ' Calling TS xx rate API from excess_400_proc' );
l_stmt_processing := 'Calling TS xx rate API from excess_400_proc';
ts_xx_rate ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_par => 'P' ,p_in_irt_id => v_irt_id );
IF p_out_chr_retcode  = g_chr_failure_code THEN
  l_chr_exe_location := 'E400_03';
  l_stmt_processing  :=' Call to TS xx rate API failed from excess 400';
  raise custom_exception;
END IF;
BEGIN
  UPDATE xx_refd_headers
  SET net_refd_amount        = NVL(net_refd_amount,0) - NVL(total_400_ref_amt,0)
  WHERE irt_id                 =v_irt_id
  AND NVL(total_400_ref_amt,0) > 0;
  write_Msg( G_Write_Logfile , 'no of rows updated: '||SQL%rowCOUNT);
EXCEPTION
WHEN OTHERS THEN
  Write_Msg( G_Write_Logfile , 'error: '||SQLERRM);
END;
--Below code is enabled as a part of Hotfix#59466  -- 20-OCT-2014 - To enable
-- RO - 5000 Rule - Starts Here
--Below code uncommented for Enabling 5000 Rule - Hotfix#99289 - Strats Here
--Below code commented for disabling 5000 Rule - Hotfix#113956 - Strats Here
--Below Uncommented as a Part of CR_HWSW_0558 - 27-Jul-2016 - Starts Here
write_msg( g_write_logfile , ' Calling RO Status Check API from excess_400_proc:');
l_stmt_processing := 'Calling RO Status Check API from excess_400_proc:';
p_out_ro_status   := 0;
p_skip_ro_status  :=0;                                                                                                                                                                                                                                          --added for HF_176638 on 11-Apr-2018
RO_SKIP_CHECK_PROC ( P_OUT_CHR_ERRBUFF => P_OUT_CHR_ERRBUFF, P_OUT_CHR_RETCODE => P_OUT_CHR_RETCODE, P_SKIP_RO_STATUS => P_SKIP_RO_STATUS, p_relaxation_flag => G_RELAX_FLAG ,P_IN_ID_NUMBER => v_id_num, P_IN_IRT_ID => v_irt_id, P_IN_IRT_AY => V_IRT_AY ); --added for HF_176638 on 11-Apr-2018
--RO_SKIP_CHECK_PROC ( P_OUT_CHR_ERRBUFF => P_OUT_CHR_ERRBUFF, P_OUT_CHR_RETCODE => P_OUT_CHR_RETCODE, P_SKIP_RO_STATUS => P_SKIP_RO_STATUS, P_IN_ID_NUMBER => v_id_num, P_IN_IRT_ID => v_irt_id, P_IN_IRT_AY => V_IRT_AY ); --commented HF_176638 on 11-Apr-2018
--ro_status_check_proc ( p_out_chr_errbuff => p_out_chr_errbuff,
-- p_out_chr_retcode => p_out_chr_retcode, p_out_ro_status => p_out_ro_status
-- , p_in_id_number => v_id_num, p_in_irt_id => v_irt_id, P_IN_IRT_AY =>
-- v_irt_ay);
--changes done for cr 602
IF p_out_chr_retcode  = g_chr_failure_code THEN
  l_chr_exe_location := 'E400_04';
  l_stmt_processing  :=' Call to ro_status_check_proc failed from excess 400' ;
  RAISE custom_exception;
END IF;
--added for HF_176638 on 11-Apr-2018----start----
IF (p_skip_ro_status=0) THEN
  p_out_ro_status  :=3; -- adjust
ELSE
  p_out_ro_status:=2; -- do notadjust
END IF;
--added for HF_176638 on 11-Apr-2018-----end----
-- p_out_ro_status1 := p_out_ro_status;
write_debug( g_debug_flag ,'p_skip_ro_status: '||p_skip_ro_status );
write_debug( g_debug_flag ,'p_out_ro_status: '||p_out_ro_status );
IF p_out_ro_status = 2 THEN
  BEGIN
    UPDATE xx_refd_headers head
    SET HEAD.NET_REFD_AMOUNT = NVL (HEAD.TOTAL_REFD_AMOUNT, 0) - NVL ( HEAD.REFD_ADJUSTMENT_AMOUNT, 0)
    WHERE head.irt_id          = p_in_irt_id;
    write_debug( g_debug_flag ,'No of rows updated in refd headers:'|| sql%rowcount);
  EXCEPTION
  WHEN OTHERS THEN
    write_debug( g_debug_flag ,'Error while updating refd headers table:' ||sqlerrm );
  END;
END IF;
p_relaxation_flag_1:=G_RELAX_FLAG;   ---added for HF_176638 on 18-June-2018
p_skip_ro_status_1 :=p_out_ro_status; --added for HF_176638 on 16-May-2018
--Code uncommented as a Part of Hotfix#99289  to enable 5000 Rule
IF p_out_ro_status <> 2 THEN --Incommented to enable 5000 Rule
  --Commented as a Part of Hotfix#113956 Ends Here
  -- For Enabling 5000 Check uncomment above portion and uncomment END IF
  -- @line No 12866
  write_debug( g_debug_flag ,'    Calling Refd adjust proc from Excess 400' );
  dbms_output.put_line('    Calling Refd adjust proc from Excess 400' );
  refd_adjust_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_number => v_id_num, p_in_irt_id => v_irt_id, p_in_rrd_call => 'E400' );
  IF p_out_chr_retcode  = g_chr_failure_code THEN
    l_chr_exe_location := 'E400_05';
    l_stmt_processing  :=' Call to Refd adjust proc failed from excess 400' ;
    raise custom_exception;
  END IF;
  write_debug( g_debug_flag ,'    Calling dmd intinv from Excess 400' );
  dbms_output.put_line('    Calling dmd intinv from Excess 400' );
  dmd_intinv ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => v_id_num, p_in_irt_id => v_irt_id );
  IF p_out_chr_retcode  = g_chr_failure_code THEN
    l_chr_exe_location := 'E400_06';
    l_stmt_processing  :=' Call to dmd intinv proc failed from excess 400' ;
    RAISE custom_exception;
  END IF;
  write_debug( g_debug_flag , '    Calling intdmd refnd adj proc from Excess 400' );
  intdmd_refnd_adj_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => v_id_num, p_in_irt_id => v_irt_id, p_in_rrd_call => 'E400' );
  IF p_out_chr_retcode  = g_chr_failure_code THEN
    l_chr_exe_location := 'E400_07';
    l_stmt_processing  :=' Call to Refd adjust proc failed from excess 400' ;
    RAISE custom_exception;
  END IF;
END IF; --unCommented as a Part of CR_HWSW_0558 - On 27-Jul-2016
--Below code is enabled as a part of Hotfix#59466  -- 20-OCT-2014 - To enable
-- RO - 5000 Rule - Ends here
--changes for CR_HWSW_102 ends here
--updating refd status at the end of 400 refd prcessing
UPDATE xx_refd_headers
SET refd_status = (
  CASE
    WHEN NVL (net_refd_amount, 0) = 0
    THEN 'APPROVED'
    WHEN NVL (net_refd_amount, 0) <= 100
    THEN 'THRESHOLD LIMIT IDENTIFIED'
    WHEN NVL (net_refd_amount, 0) > 100
    THEN 'TO PAY IDENTIFIED'
  END )
WHERE refd_status = 'PCM APPROVED'
  -- AND request_id = g_num_request_id
AND irt_id = p_in_irt_id;
EXCEPTION
WHEN custom_exception THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' ||l_stmt_processing || p_out_chr_errbuff ;
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - ' || l_chr_errbuff);
    END IF;
  END IF;
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff);
    END IF;
  END IF;
END excess_400_proc;
--******************************* End of Procedure / Function *****************
-- ************
PROCEDURE dmd_collect_proc(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_dmd_sts IN VARCHAR2 DEFAULT NULL,
    p_in_proc_type  IN VARCHAR2 DEFAULT 'R',
    p_in_irt_id     IN VARCHAR2 )
AS
  /****************************************************************************
  ****************************************
  * Type : Procedure
  * Name : DMD_COLLECT_PROC
  * Input Parameters : p_in_dmd_sts
  p_in_proc_type
  p_in_irt_id
  * Output Parameters : p_out_chr_errbuff
  * p_out_chr_retcode
  * Purpose : Procedure to apply identified receipts to prior assmet year
  dmds
  *
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 23-Jan-2012
  * Last Reviewed By :
  * Last Reviewed Date :
  *****************************************************************************
  *************************************
  * Modified Date Modified By Version Modification Type Modification Details
  * ------------- ------------ -------- -----------------
  -----------------------
  * 23-Jan-2012 Infosys 1.0 O Baseline. ***************************************
  **************************************************************************/
  l_calc_dmd_due_date     DATE;
  l_dmd_serv_date         DATE;
  l_max_to_month             DATE;
  l_adjust_amount            NUMBER;
  l_calc_status              NUMBER;
  l_msg_count                NUMBER;
  l_month_diff               NUMBER;
  l_msg_index_out            NUMBER;
  l_num_rule_count           NUMBER := 0;
  l_num_odd_exists           NUMBER := 0;
  l_num_int_apply_amt        NUMBER := 0;
  l_num_rev_apply_amt        NUMBER := 0;
  l_num_count                NUMBER := 0;
  l_inv_refd_adjust_amount NUMBER := 0;
  l_count                    NUMBER := 0;
  l_num_tot_apply_amt        NUMBER := 0;
  l_num_orig_apply_amt       NUMBER := 0;
  l_num_refd_adjusted_dem  NUMBER := 0;
  l_num_due_amount           NUMBER := 0;
  l_return_status            VARCHAR2 (1);
  l_chr_int_calc             VARCHAR2 (1);
  l_chr_exe_location         VARCHAR2 (10);
  l_chr_ood_retcode          VARCHAR2 (30);
  L_chr_errbuff              VARCHAR2 (3000);
  l_chr_proc_name            VARCHAR2 (50);
  l_chr_retcode              VARCHAR2 (20);
  l_stmt_processing          VARCHAR2 (250);
  l_chr_ood_errbuff          VARCHAR2 (500);
  out_err_msg                VARCHAR2 (2000);
  x_msg_data                 VARCHAR2 (2000);
  l_msg_data                 VARCHAR2 (5000);
  custom_exception           EXCEPTION;
  e_skip_exception           EXCEPTION;
  --------------- Dmd Attributes -------------
  l_inv_amt_due_remaining NUMBER := 0;
  l_num_avl_ref_adj_amt   NUMBER;
  l_num_dem_int_amt       NUMBER;
  l_chr_dem_int_status    VARCHAR2 (50);
  --------------- Receipt Attributes -------------
  l_400_amt_due_rem    NUMBER;
  l_num_final_odd_amt  NUMBER := 0;
  L_NUM_TEMP_AMT       NUMBER := 0;
  l_num_ro_avl_ref_adj NUMBER := 0;
  l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
  l_dte_cut_off_date   DATE := NULL;
  l_final_dem_due_date DATE := NULL;
  l_rrd_400_chk        VARCHAR2(10); -- FOR CR_HWSW_102
  LV_DMD_INT_AMT  xx_dmd_headers.Dmd_Interest_AMount%TYPE; --Added for CR_0761-Refd in Interim Status
  no_int_calc NUMBER;--CR_785
   DEM_INT_AMT     number;--CR_785
  l_dem_lin_count NUMBER ;--CR_785
    LV_Cal_DMD_INT_AMT  xx_dmd_headers.Dmd_Interest_AMount%TYPE; --Added for CR_0761-Refd in Interim Status
	  L_ORIG_CUST_TRX_ID number ;   --added for CR_HWSW_785 on 04-APR-2019
  l_orig_irt_id      VARCHAR2(150);--added for CR_HWSW_785 on 04-APR-2019
TYPE r_cur
IS
  REF
  CURSOR;
    get_400_details_dyn r_cur;
  TYPE l_400_rec_type
IS
  RECORD
  (
    receipt_number xx_400_collections_gtt.receipt_number%TYPE,
    amount_due_remaining xx_400_collections_gtt.amount_due_remaining%TYPE,
    cash_receipt_id xx_400_collections_gtt.cash_receipt_id%TYPE,
    payment_schedule_id xx_400_collections_gtt.payment_schedule_id%TYPE,
    receipt_date xx_400_collections_gtt.receipt_date%TYPE,
    assessment_year xx_400_collections_gtt.assessment_year%TYPE,
    minor_head xx_400_collections_gtt.minor_head%TYPE,
    rule4_flag xx_400_collections_gtt.rule4_flag%TYPE,
    attribute15 xx_400_collections_gtt.attribute15%TYPE,
    id_number xx_400_collections_gtt.id_number%TYPE,
    major_head xx_400_collections_gtt.major_head%TYPE,
    global_attribute8 xx_400_collections_gtt.global_attribute8%TYPE,
    global_attribute2 xx_400_collections_gtt.global_attribute2%TYPE );
TYPE l_400_tbl_type
IS
  TABLE OF l_400_rec_type INDEX BY BINARY_INTEGER;
  l_400_tbl_data l_400_tbl_type;
  l_num_ct1        NUMBER;
  l_chr_inv_status VARCHAR2 (30);
  l_chr_dem_status VARCHAR2 (30);
  CURSOR get_dmd_details
  IS
    SELECT customer_trx_id,
      trx_number,
      irt_ay,
      irt_id,
      id_number,
      avl_refd_adjust_amount,
      major_head,
      dmd_status,
      irt_schedule_type,
      dmd_service_date,
      irt_returns_due_date,
      customer_trx_date,
      payment_schedule_id,
      din,
      cust_type_rev_flag,
      dmd_interest_status,
      dmd_interest_amount,
      amount_due_remaining,
      irt_approval_date,
      state_code,
      attribute9,
      NVL (refd_adjusted_flag, 'N') refd_adjusted_flag
    FROM xx_dmd_details_gtt
    WHERE ( ( dmd_service_date IS NOT NULL
    AND dmd_status             IN ('DMD', 'DMD IDENTIFIED') )
    OR ( dmd_status            IN ('INT DMD', 'THRESHOLD DMD', 'THRESHOLD DMD IDENTIFIED') ) )
    AND amount_due_remaining       > 0
    ORDER BY cust_type_rev_flag, --order by changed for CR_HWSW_102
      irt_ay,
      id_number;
BEGIN
  p_out_chr_errbuff  := ' ';
  p_out_chr_retcode  := G_CHR_SUCCESS_CODE;
  l_chr_exe_location := 'DCP_01';
  l_stmt_processing  := 'Entering Dmd Collect Proc for processing any 400 records' ;
  l_chr_proc_name    := 'dmd_collect_proc' ;
  write_debug( g_debug_flag ,L_STMT_PROCESSING );
  write_debug( g_debug_flag , '*** Apply 400 Receipts To Dmd - STARTS ***' ) ;
  IF p_in_proc_type     = 'O' THEN
    l_chr_exe_location := 'DCP_02';
    l_stmt_processing  :='Insert into xx_400_collections_gtt ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    DELETE FROM xx_400_collections_gtt;
    INSERT
    INTO xx_400_collections_gtt
      (
        receipt_number ,
        amount_due_remaining ,
        cash_receipt_id ,
        payment_schedule_id ,
        receipt_date ,
        assessment_year ,
        minor_head ,
        rule4_flag ,
        attribute15 ,
        id_number ,
        major_head ,
        global_attribute8 ,
        global_attribute2
      )
    SELECT receipt_number ,
      amount_due_remaining,
      cash_receipt_id,
      NULL,
      receipt_date,
      assessment_year,
      minor_head,
      'Y',
      attribute15,
      id_number,
      major_head,
      NULL,
      GLOBAL_ATTRIBUTE2
    FROM xx_400_collections_mv
    WHERE major_head  <>'0032'; --major head added for hotfix 143278
  ELSIF p_in_proc_type = 'R'    --FOR 5 to 6 program
    THEN
    -- DELETE FROM xx_400_collections_gtt; --400 commented 8 JAN13
    FOR i IN
    ( SELECT DISTINCT xats.bill_to_customer_number id_number
    FROM xx_ar_trans_stg xats,
      ra_cust_trx_types_all rctt
    WHERE rctt.cust_trx_type_id = xats.dr_cust_trx_type_id
    AND xats.request_id         = g_num_request_id
    AND rctt.attribute2        IN ('REVISED', 'RECTIFICATION')
    AND transaction_number      = p_in_irt_id
    )
    LOOP
      l_chr_exe_location := 'DCP_03';
      l_stmt_processing  :='Insert into xx_400_collections_gtt ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      DELETE FROM xx_400_collections_gtt;
      INSERT
      INTO xx_400_collections_gtt
        (
          receipt_number ,
          amount_due_remaining ,
          cash_receipt_id ,
          payment_schedule_id ,
          receipt_date ,
          assessment_year ,
          minor_head ,
          rule4_flag ,
          attribute15 ,
          id_number ,
          major_head ,
          global_attribute8 ,
          global_attribute2
        )
        (SELECT arc.receipt_number ,
            NVL (ABS (arc.global_attribute10),arc.amount) ,
            arc.cash_receipt_id ,
            NULL ,
            arc.receipt_date ,
            arc.attribute4 ,
            arc.attribute2 ,
            'N' , --rule4_flag
            arc.attribute15 ,
            arc.attribute5 ,
            arc.attribute1 ,
            NULL global_attribute8 ,
            arc.global_attribute2
          FROM ar_cash_receipts_all arc
          WHERE NVL (arc.global_attribute10, arc.amount) <> 0
          AND arc.status                                  = 'UNAPP'
          AND arc.attribute2                              = '400'
          AND arc.attribute1                             IN ('0020', '0021', '0026' )
          AND arc.attribute5                              = i.id_number
          AND arc.attribute15                             ='MATCHED' --Added for Apply 400 Rule change
          AND ARC.ATTRIBUTE12                            IS NOT NULL --Added for Apply 400 Rule change
          AND NOT EXISTS
            (SELECT 1
            FROM xx_400_collections_gtt x4cg1
            WHERE x4cg1.cash_receipt_id=arc.cash_receipt_id
            )
        );
    END LOOP; --FOR i IN
  END IF;     -- IF p_in_proc_type = 'O'
  ---------- INSERT ELIGIBLE DMDS INTO GTT -------------------------------
  l_chr_exe_location := 'DCP_04';
  l_stmt_processing  :='Insert into xx_dmd_details_gtt ';
  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
  DELETE FROM xx_dmd_details_gtt;
  INSERT
  INTO xx_dmd_details_gtt
    (
      customer_trx_id,
      trx_number,
      irt_ay,
      id_number,
      avl_refd_adjust_amount,
      major_head,
      dmd_status,
      irt_schedule_type,
      irt_id,
      dmd_service_date,
      irt_returns_due_date,
      customer_trx_date,
      payment_schedule_id,
      din,
      dmd_interest_status,
      amount_due_remaining,
      irt_approval_date,
      dmd_identified_date,
      attribute9,
      dmd_interest_amount,
      dmd_due_date,
      cust_type_rev_flag
     -- state_code            --Commented out -ABC-2.0 POC - bhagya
    )
  SELECT DMD.customer_trx_id,
    DMD.trx_number,
    DMD.irt_ay,
    DMD.id_number,
    DMD.avl_refd_adjust_amount,
    DMD.major_head,
    DMD.dmd_status status,
    DMD.irt_schedule_type,
    DMD.irt_id,
    DMD.dmd_service_date,
    DMD.irt_returns_due_date,
    DMD.customer_trx_date,
    arp.payment_schedule_id,
    DMD.dmd_identification_number,
    DMD.dmd_interest_status,
    arp.amount_due_remaining,
    rcta.attribute3,
    DMD.dmd_identified_date,
    rcta.attribute9,
    DMD.dmd_interest_amount,
    DMD.dmd_due_date,
    DMD.cust_trx_type_name
   -- ipi."pi_address_state_cd"            --Commented out -ABC-2.0 POC - bhagya
  FROM xx_dmd_headers DMD,
    ar_payment_schedules_all arp,
    ra_customer_trx_all rcta
   -- "efile"."irt_personal_info"@psql_process_fas ipi         --Commented out -ABC-2.0 POC - bhagya
  WHERE DMD.customer_trx_id = arp.customer_trx_id
  AND DMD.CUSTOMER_TRX_ID   = RCTA.CUSTOMER_TRX_ID
    --and dmd.attribute15 not like '%PENALTY%' --- added for CR530
  AND ( p_in_dmd_sts          IS NULL
  AND ( dmd_status            IN ('DMD', 'THRESHOLD DMD')
  OR ( DMD.cust_trx_type_name IN ('REVISED', 'RECTIFICATION', 'RR REFD RCVBL')
  AND dmd_status              IN ('DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED') ) )
  OR p_in_dmd_sts              = 'INT DMD'
  AND dmd_status               = 'INT DMD' )
  --AND dmd.IRT_ID               = TO_CHAR (ipi."irt_id"(+)) --included outer join to include
    -- arrear dmd records also
  AND EXISTS
    (SELECT 1
    FROM xx_400_collections_gtt
    WHERE id_number = DMD.id_number
    );
  -- Only the RO's which would ideally get applied in rule0 should be tagged as
  -- RO, rest all should be
  -- considered as normal 400 collections for eg : the rectified dmd
  -- undergoin 400 apllcn with an RO of the cancelled dmd..
  -- since DIN for such RO will not match with the new rect dmd, rule 0 will
  -- not happen, so it flow in all other rule buckets and get closed
  -- so that it is refded.
  --updating 400 GT with RO tag
  l_chr_exe_location := 'DCP_05';
  l_stmt_processing  :='Updating 400 GT with RO tag ';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE xx_400_collections_gtt x4cg
  SET global_attribute8                                                          = DECODE (
    ( SELECT DISTINCT 1 FROM xx_dmd_details_gtt xddg WHERE xddg.id_number = x4cg.id_number
    AND xddg.irt_ay                                                              = x4cg.assessment_year
    AND SUBSTR (x4cg.global_attribute2, 1, 20)                                   = xddg.din
    AND ( is_numeric (x4cg.global_attribute2) )                                  = 1
    ) , 1, 'RO' , NULL );
  -- why tagging of RO is to be done differently in 'O' run?
  -- I have an RO collection, but i do not have the dmd corresponding to
  -- that, as the dmd underwent rect
  -- so that old RO should not be made normal 400 and applied with any other
  -- dmd if this RO needs to be refded, assesse shud file rect
  -- where this RO will move to other rule buckets and get applied to other
  -- dmds. if no dmds exists it will become excess 400 and will be
  --refded.
  -- Rule 4 takes care that 2008 dem doesnt get applied to 2009 RO since rule4
  -- runs only in 'R' case. But having this delete
  -- as an added check.
  --This additional deletion should be done only for 'O' so that it ones that
  -- are not tagged as RO will not flow into other rule buckets.
  IF p_in_proc_type = 'O' THEN
    DELETE
    FROM xx_400_collections_gtt x4cg
    WHERE ( is_numeric (x4cg.global_attribute2) ) = 1 --RO
    AND global_attribute8                        IS NULL;
  END IF; --IF p_in_proc_type = 'O'
  l_chr_exe_location := 'DCP_06';
  l_stmt_processing  := 'updating refd_adjust_flag in xx_dmd_details_gtt ';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  --updating refd_adjust_flag
  UPDATE xx_dmd_details_gtt xddg
  SET refd_adjusted_flag       = 'Y'
  WHERE avl_refd_adjust_amount < amount_due_remaining
  AND dmd_status             IN ('DMD', 'INT DMD', 'THRESHOLD DMD')
  AND EXISTS
    (SELECT 1
    FROM xx_400_collections_gtt x4cg
    WHERE x4cg.id_number    = xddg.id_number
    AND x4cg.assessment_year = xddg.irt_ay
    AND global_attribute8    = 'RO'
    );
  ---------------- DEFAULTING ----------------------
  --defaulting dmd service date
  l_chr_exe_location := 'DCP_07';
  l_stmt_processing  := 'updating dmd service date in xx_dmd_details_gtt ';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE xx_dmd_details_gtt xddg
  SET dmd_service_date    = dmd_identified_date + 5,
    request_id               = g_num_request_id
  WHERE dmd_service_date IS NULL
  AND dmd_status NOT     IN ('INT DMD', 'THRESHOLD DMD', 'THRESHOLD DMD IDENTIFIED')
  AND ( EXISTS
    (SELECT 1
    FROM xx_400_collections_gtt
    WHERE id_number       = xddg.id_number
    AND assessment_year    = xddg.irt_ay
    AND global_attribute8 IS NULL
    )
  OR EXISTS
    (SELECT 1
    FROM xx_400_collections_gtt
    WHERE id_number       = xddg.id_number
    AND rule4_flag         = 'Y'
    AND global_attribute8 IS NULL
    ) );
  /********************** DMD LOOP ********************/
  l_inv_amt_due_remaining := 0;
  l_chr_dem_int_status    := NULL;
  l_num_avl_ref_adj_amt   := 0;
  l_num_dem_int_amt       := 0;
  l_400_amt_due_rem       := 0;
  WHILE (l_num_rule_count <= 3) -- modified from 4 to 3 as rule 4 not
  -- applicable in R run
  --((4 - l_num_profile_rule) + 1)--If 4 is not to be hardcoded even that is to
  -- be added in profile
  LOOP
    IF l_num_rule_count = 1 THEN
      l_num_rule_count := fnd_profile.VALUE ('xx_APPCN_RULE_NO');
    END IF;
    write_debug( g_debug_flag ,'Rule count:' || l_num_rule_count);
    l_chr_exe_location := 'DCP_08';
    l_stmt_processing  :='Entering into LOOP ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    FOR cur_inv_rec IN get_dmd_details
    LOOP
      BEGIN
        l_chr_int_calc          := 'N';
        l_dmd_serv_date      := NULL;
        l_count                 := 0;
        l_num_orig_apply_amt    := 0;
        l_inv_amt_due_remaining := cur_inv_rec.amount_due_remaining;
        l_chr_dem_int_status    := cur_inv_rec.dmd_interest_status;
        l_num_avl_ref_adj_amt   := cur_inv_rec.avl_refd_adjust_amount;
        l_num_dem_int_amt       := cur_inv_rec.dmd_interest_amount;
        write_debug( g_debug_flag , ' IRT ID :' || cur_inv_rec.irt_id );
        write_debug( g_debug_flag , 'ID NUMBER :' || cur_inv_rec.id_number );
        write_debug( g_debug_flag ,' ASSMT YEAR :' || cur_inv_rec.irt_ay );
        write_debug( g_debug_flag , ' MAJOR HEAD :' || cur_inv_rec.major_head ) ;
        write_debug( g_debug_flag ,' DMD NOTE SERVICE DATE :' || cur_inv_rec.dmd_service_date );
        write_debug( g_debug_flag ,' Customer_trx_id :' || cur_inv_rec.customer_trx_id );
        --For CR_HWSW_102
        IF CUR_INV_REC.CUST_TYPE_REV_FLAG = 'RR REFD RCVBL' THEN
          l_rrd_400_chk                  := 'Y';
        END IF;
        IF l_inv_amt_due_remaining < l_num_avl_ref_adj_amt THEN
          p_out_chr_errbuff       := 'Error1: Invoice amount due remaining(' || l_inv_amt_due_remaining || ') is less than Available for Refd Adjustment(' || l_num_avl_ref_adj_amt || ')' || '. This is invalid scenario. Please check the data for dmd: ' || cur_inv_rec.trx_number ;
          write_msg( g_write_logfile , p_out_chr_errbuff);
          RAISE custom_exception;
        END IF; -- IF l_inv_amt_due_remaining < l_num_avl_ref_adj_amt
        -- Checking in beginning as well, as the EXIT at end exits and comes to
        -- next dmd ,
        -- but there is a possibility that the same dmd gets picked in the
        -- next rule.
        --RULE --> DMDS
        IF l_num_avl_ref_adj_amt = 0 AND NVL (cur_inv_rec.refd_adjusted_flag, 'N') <> 'Y' THEN
          write_debug(g_debug_flag, 'Exiting for this dmd as l_num_avl_ref_adj_amt is 0 at the begin' );
          RAISE e_skip_exception;
        END IF; -- IF l_num_avl_ref_adj_amt = 0
        l_num_refd_adjusted_dem   := 0;
        IF l_num_avl_ref_adj_amt     < l_inv_amt_due_remaining THEN
          l_num_refd_adjusted_dem := 1;
        END IF; -- IF l_num_avl_ref_adj_amt < l_inv_amt_due_remaining
        write_debug( g_debug_flag , 'cur_inv_rec.dmd_status:' || cur_inv_rec.dmd_status );
        IF l_num_rule_count = 2 THEN
          IF cur_inv_rec.dmd_status IN ('DMD', 'DMD IDENTIFIED') THEN
            l_calc_status := NULL;
            --PKG_COMMON_APIS_V2.get_next_working_day_func--comment**
            l_chr_exe_location := 'DCP_09';
            l_stmt_processing  := ' Calling PKG_COMMON_APIS_V2.get_next_working_day_func function';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            l_calc_status :=PKG_COMMON_APIS_V2.get_next_working_day_func ( (cur_inv_rec.dmd_service_date + 30 ), cur_inv_rec.state_code, l_calc_dmd_due_date, out_err_msg );
            write_debug( g_debug_flag , 'Calc due date to be updated: ' || l_calc_dmd_due_date );
            IF l_calc_status    <> 0 THEN
              p_out_chr_errbuff := 'Error in Holiday Calendar api for getting next working day ' || out_err_msg || SQLERRM ;
              write_msg( g_write_logfile , p_out_chr_errbuff );
              RAISE custom_exception;
            END IF; --IF l_calc_status <> 0
            l_chr_exe_location := 'DCP_10';
            l_stmt_processing  := 'Updating dmd_due_date and request_id in xx_dmd_details_gtt ' ;
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            UPDATE xx_dmd_details_gtt
            SET dmd_due_date  = l_calc_dmd_due_date,
              request_id         = g_num_request_id
            WHERE dmd_status IN ('DMD', 'DMD IDENTIFIED')
            AND customer_trx_id  = cur_inv_rec.customer_trx_id;
          END IF; -- IF cur_inv_rec.dmd_status IN ('DMD', 'DMD
          -- IDENTIFIED')
        END IF; -- IF l_num_rule_count = 2
        -- Reset the due_date variable to hold the due date of the curr dmd
        -- being processed.
        -- write_debug( g_debug_flag ,'l_calc_dmd_due_date :' ||'-'||
        -- l_calc_dmd_due_date );
        BEGIN
          l_chr_exe_location := 'DCP_11';
          l_stmt_processing  := 'Retriving dmd_due_date from xx_dmd_details_gtt ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          l_calc_dmd_due_date := NULL;
          SELECT dmd_due_date
          INTO l_calc_dmd_due_date
          FROM xx_dmd_details_gtt
          WHERE dmd_status IN ('DMD', 'DMD IDENTIFIED')
          AND customer_trx_id  = cur_inv_rec.customer_trx_id;
          write_debug( g_debug_flag , 'Updated Due date of current dmd: ' || l_calc_dmd_due_date );
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          NULL;
          -- in case of threshold dmd due date will not be upd no need as no
          -- int calc
        WHEN OTHERS THEN
          write_debug( g_debug_flag , 'Error while fetching current due date: ' || SQLERRM );
          RAISE custom_exception;
        END;
        /********************** RULE LOOP ********************/
        l_400_tbl_data.DELETE;
        l_400_amt_due_rem := 0;
        BEGIN
          IF l_num_rule_count   = 0 THEN
            l_chr_exe_location := 'DCP_12';
            l_stmt_processing  :='Rule0';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            OPEN get_400_details_dyn FOR SELECT receipt_number,
            amount_due_remaining,
            cash_receipt_id,
            payment_schedule_id,
            receipt_date,
            assessment_year,
            minor_head,
            rule4_flag,
            attribute15,
            id_number,
            major_head,
            global_attribute8,
            global_attribute2 FROM xx_400_collections_gtt WHERE id_number = cur_inv_rec.id_number AND assessment_year = cur_inv_rec.irt_ay AND global_attribute8 = 'RO' AND amount_due_remaining > 0 AND SUBSTR (global_attribute2, 1, 20) = cur_inv_rec.din AND cur_inv_rec.refd_adjusted_flag = 'Y' ORDER BY receipt_date,
            amount_due_remaining;
          ELSIF l_num_rule_count = 1 THEN
            l_chr_exe_location  := 'DCP_13';
            l_stmt_processing   :='Rule1';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            OPEN get_400_details_dyn FOR SELECT receipt_number,
            amount_due_remaining,
            cash_receipt_id,
            payment_schedule_id,
            receipt_date,
            assessment_year,
            minor_head,
            rule4_flag,
            attribute15,
            id_number,
            major_head,
            global_attribute8,
            global_attribute2 FROM xx_400_collections_gtt WHERE id_number = cur_inv_rec.id_number AND global_attribute9 = cur_inv_rec.din AND amount_due_remaining > 0 AND global_attribute8 IS NULL ORDER BY receipt_date,
            amount_due_remaining;
          ELSIF l_num_rule_count = 2 THEN
            l_chr_exe_location  := 'DCP_14';
            l_stmt_processing   :='Rule2';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            write_debug( g_debug_flag , cur_inv_rec.id_number );
            write_debug( g_debug_flag , cur_inv_rec.irt_ay);
            write_debug( g_debug_flag , cur_inv_rec.major_head );
            OPEN get_400_details_dyn FOR SELECT receipt_number,
            amount_due_remaining,
            cash_receipt_id,
            payment_schedule_id,
            receipt_date,
            assessment_year,
            minor_head,
            rule4_flag,
            attribute15,
            id_number,
            major_head,
            global_attribute8,
            global_attribute2 FROM xx_400_collections_gtt WHERE id_number = cur_inv_rec.id_number AND assessment_year = cur_inv_rec.irt_ay AND major_head = cur_inv_rec.major_head AND amount_due_remaining > 0 AND global_attribute8 IS NULL ORDER BY receipt_date,
            amount_due_remaining;
          ELSIF l_num_rule_count = 3 THEN
            l_chr_exe_location  := 'DCP_15';
            l_stmt_processing   :='Rule3';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            OPEN get_400_details_dyn FOR SELECT receipt_number,
            amount_due_remaining,
            cash_receipt_id,
            payment_schedule_id,
            receipt_date,
            assessment_year,
            minor_head,
            rule4_flag,
            attribute15,
            id_number,
            major_head,
            global_attribute8,
            global_attribute2 FROM xx_400_collections_gtt WHERE id_number = cur_inv_rec.id_number AND assessment_year = cur_inv_rec.irt_ay AND amount_due_remaining > 0 AND global_attribute8 IS NULL ORDER BY receipt_date,
            amount_due_remaining;
          END IF; --IF l_num_rule_count = 0
          LOOP
            l_chr_exe_location := 'DCP_16';
            l_stmt_processing  :='Fetchnig from get_400_details_dyn';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            FETCH get_400_details_dyn BULK COLLECT INTO l_400_tbl_data;
            EXIT
          WHEN get_400_details_dyn%NOTFOUND;
          END LOOP;
          CLOSE get_400_details_dyn;
          write_debug( g_debug_flag , 'Bulk collected!:');
        EXCEPTION
        WHEN OTHERS THEN
          p_out_chr_errbuff := p_out_chr_errbuff || '-' || 'Error opening/bulk collecting from ref cursors.. ' || SQLERRM;
          write_msg( g_write_logfile , p_out_chr_errbuff );
          RAISE custom_exception;
        END;
        write_debug( g_debug_flag , 'No. Of receipts collected:' || l_400_tbl_data.COUNT );
        IF l_400_tbl_data.COUNT > 0 THEN
          l_chr_exe_location   := 'DCP_17';
          write_debug( g_debug_flag ,l_chr_exe_location );
          FOR i IN l_400_tbl_data.FIRST .. l_400_tbl_data.LAST
          LOOP
            write_debug( g_debug_flag , '1543');
            l_msg_count        := NULL;
            l_msg_data         := NULL;
            l_return_status    := NULL;
            l_month_diff       := 0;
            l_max_to_month     := NULL;
            l_400_amt_due_rem  := 0;
            l_400_amt_due_rem  := l_400_tbl_data (i).amount_due_remaining;
            l_chr_exe_location := 'DCP_18';
            l_stmt_processing  :='Checking int eligibilty for orig:';
            write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
            IF ( ( cur_inv_rec.dmd_status IN ('DMD', 'THRESHOLD DMD') AND cur_inv_rec.cust_type_rev_flag IS NULL ) OR cur_inv_rec.dmd_status LIKE '%INT DMD%' OR cur_inv_rec.dmd_status LIKE 'THRESHOLD DMD%' OR ( l_400_tbl_data (i).global_attribute8 = 'RO' -- Added as rule 0
                -- should enter this part
                AND cur_inv_rec.cust_type_rev_flag IN ('REVISED', 'RECTIFICATION', 'RR REFD RCVBL') ) ) THEN
              IF cur_inv_rec.dmd_status = 'DMD' THEN
				--added for partial dmd adjustment----CR_HWSW_0785 on 04-APR-2019
                    SELECT COUNT(1)
                    INTO no_int_calc
                    FROM xx_dmd_headers a
                    WHERE dmd_status='DMD ON STAY'
                    AND EXISTS
                      (SELECT 1
                      FROM xx_dmd_headers b
                      WHERE b.irt_id       = cur_inv_rec.irt_id
                      AND a.irt_id         = b.irt_id
                      AND B.CUSTOMER_TRX_ID= CUR_INV_REC.CUSTOMER_TRX_ID
                      AND b.attribute15    = TO_CHAR(a.customer_trx_id)
                      );
                    IF (no_int_calc  >0) THEN
                      l_chr_int_calc:='N';
                    END IF;
                    --added for partial dmd adjustment----CR_HWSW_0785 on 04-APR-2019


                IF l_chr_dem_int_status    = 'PROVISIONAL' AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) --RO
                  THEN
                  BEGIN
                    l_chr_exe_location := 'DCP_19';
                    l_stmt_processing  := 'Retriving dmd date from xx_dmd_lines ';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    SELECT TO_DATE ( '01-'
                      || TO_CHAR (ADD_MONTHS (MAX (int_calc_to_month), 1 ), 'MON-RRRR' ), 'DD-MON-RRRR' )
                    INTO l_dmd_serv_date
                    FROM xx_dmd_lines
                    WHERE customer_trx_id = cur_inv_rec.customer_trx_id
                    AND reversal_status  IS NULL;
                  EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                    l_dmd_serv_date := l_calc_dmd_due_date;
                  END;
                  l_chr_exe_location := 'DCP_20';
                  write_debug( g_debug_flag ,l_chr_exe_location);
                  l_month_diff     := MONTHS_BETWEEN (TO_DATE (TO_CHAR ( l_400_tbl_data (i).receipt_date, 'MON-YYYY' ), 'MON-YYYY' ), TO_DATE (TO_CHAR (l_dmd_serv_date, 'MON-YYYY' ), 'MON-YYYY' ) );
                  IF l_month_diff  >= 0 AND l_inv_amt_due_remaining <> 0 THEN
                    l_chr_int_calc := 'Y';
                  END IF; --IF l_month_diff >= 0
                ELSIF l_chr_dem_int_status                 IS NULL AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) THEN
                  IF TO_CHAR (l_calc_dmd_due_date, 'DD') = TO_CHAR (LAST_DAY (l_calc_dmd_due_date), 'DD' ) THEN
                    l_dmd_serv_date                     := l_calc_dmd_due_date + 1;
                  ELSE
                    l_dmd_serv_date := l_calc_dmd_due_date;
                  END IF;
                  IF l_400_tbl_data (i).receipt_date > l_dmd_serv_date AND l_inv_amt_due_remaining <> 0 THEN
                    l_chr_int_calc                  := 'Y';
                  END IF;
                END IF; -- IF l_chr_dem_int_status = 'PROVISIONAL'
                write_debug( g_debug_flag , 'receipt date:' || l_400_tbl_data ( i).receipt_date );
                write_debug( g_debug_flag , 'Dem service date:' || l_dmd_serv_date );
                write_debug( g_debug_flag , 'l_chr_int_calc:' || l_chr_int_calc );
                write_debug( g_debug_flag , 'l_num_avl_ref_adj_amt:' || l_num_avl_ref_adj_amt );
                write_debug( g_debug_flag , 'l_400_tbl_data (i).global_attribute8:' || l_400_tbl_data (i) .global_attribute8 );
                write_debug( g_debug_flag , 'l_chr_dem_int_status:' || l_chr_dem_int_status );
                /***************** INTEREST CALCULATION *********************/
                IF l_chr_int_calc = 'Y' AND l_num_avl_ref_adj_amt <> 0 AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) AND l_rrd_400_chk <> 'Y' --RO (l_rrd_400_chk variable added
                  -- for CR_HWSW_102)
                  and no_int_calc =0 THEN
                  l_chr_exe_location := 'DCP_21';
                  l_stmt_processing  :='Calling dmd_interest_calc function ' ;
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  l_adjust_amount := dmd_interest_calc (l_400_tbl_data (i) .receipt_date, l_dmd_serv_date, (l_num_avl_ref_adj_amt -
                  MOD (l_num_avl_ref_adj_amt, 100 ) ), cur_inv_rec.irt_ay );
                  l_chr_exe_location := 'DCP_22';
                  l_stmt_processing  :='Dmd Interest population';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  --Dmd Interest population
                  INSERT
                  INTO xx_dmd_lines
                    (
                      customer_trx_id,
                      dmd_interest_amount,
                      int_calc_to_month,
                      cash_receipt_id,
                      last_updated_by,
                      last_update_date,
                      last_update_login,
                      created_by,
                      creation_date,
                      sequence_id,
                      irt_id
                    )
                    VALUES
                    (
                      cur_inv_rec.customer_trx_id,
                      l_adjust_amount,
                      l_400_tbl_data (i).receipt_date,
                      l_400_tbl_data (i).cash_receipt_id,
                      g_num_user_id,
                      SYSDATE,
                      g_num_login_id,
                      g_num_user_id,
                      SYSDATE,
                      NULL,
                      CUR_INV_REC.IRT_ID
                    );
                  --cant insert in GTT as we just inserted in lines update GTT
                  l_chr_exe_location := 'DCP_23';
                  l_stmt_processing  := 'Dmd Interest status and amount update ';
                  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                   --Added for CR_0761-Refd In Interim Status--START--
                    select NVL(Dmd_Interest_AMount,0)
                    into LV_DMD_INT_AMT
                    from xx_dmd_details_gtt
                    WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                    and irt_id=cur_inv_rec.irt_id
                    AND NVL (dmd_interest_status,'-1') <> 'FINAL';                
                --Added for CR_0761-Refd In Interim Status--END--
                  --Dmd Interest status and amount update
                  UPDATE xx_dmd_details_gtt head
                  SET head.dmd_interest_status = 'PROVISIONAL',
                    request_id                    = g_num_request_id,
                    head.dmd_interest_amount   =
                    (SELECT NVL (SUM (dmd_interest_amount ), 0 )
                    FROM xx_dmd_lines
                    WHERE customer_trx_id = head.customer_trx_id
                    AND reversal_status  IS NULL
                    )
                  WHERE head.customer_trx_id                   = cur_inv_rec.customer_trx_id
                  AND NVL (head.dmd_interest_status, '-1') <> 'FINAL';
                  --Added for CR_0761-Refd In Interim Status--START--
                  select NVL(Dmd_Interest_AMount,0)
                  into LV_Cal_DMD_INT_AMT
                  from xx_dmd_details_gtt
                  WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                  and irt_id=cur_inv_rec.irt_id
                  AND NVL (dmd_interest_status,'-1') <> 'FINAL';                      
                  LV_DMD_INT_AMT:=LV_Cal_DMD_INT_AMT-LV_DMD_INT_AMT;

                --Added for CR_0761-Refd In Interim Status--END--
                  l_chr_dem_int_status                        := 'PROVISIONAL';

				 --added for CR_785 on 28-May-2019
				ELSIF(l_num_avl_ref_adj_amt <> 0 AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) AND l_rrd_400_chk <> 'Y' --RO (l_rrd_400_chk variable added
                  -- for CR_HWSW_102)
                  and no_int_calc >0) THEN
					l_chr_exe_location := 'DCP_21_PART';
                  l_stmt_processing  :='Calling dmd_interest_calc function ' ;
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  l_adjust_amount := dmd_interest_calc (l_400_tbl_data (i) .receipt_date, l_dmd_serv_date, (l_num_avl_ref_adj_amt -
                  MOD (l_num_avl_ref_adj_amt, 100 ) ), cur_inv_rec.irt_ay );
                  l_chr_exe_location := 'DCP_22';
                  l_stmt_processing  :='Dmd Interest population';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  --Dmd Interest population                 
                  --cant insert in GTT as we just inserted in lines update GTT
                  l_chr_exe_location := 'DCP_23_PART';
                  l_stmt_processing  := 'Dmd Interest status and amount update ';
                  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                   --Added for CR_0761-Refd In Interim Status--START--
                    select NVL(Dmd_Interest_AMount,0)
                    into LV_DMD_INT_AMT
                    from xx_dmd_details_gtt
                    WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                    and irt_id=cur_inv_rec.irt_id
                    AND NVL (dmd_interest_status,'-1') <> 'FINAL';                
                --Added for CR_0761-Refd In Interim Status--END--
                  --Dmd Interest status and amount update
                  UPDATE xx_dmd_details_gtt head
                  SET head.dmd_interest_status = 'PROVISIONAL',
                    request_id                    = g_num_request_id,
                    head.dmd_interest_amount   =
                    (SELECT NVL (SUM (dmd_interest_amount ), 0 )
                    FROM xx_dmd_lines
                    WHERE customer_trx_id = head.customer_trx_id
                    AND reversal_status  IS NULL
                    )
                  WHERE head.customer_trx_id                   = cur_inv_rec.customer_trx_id
                  AND NVL (head.dmd_interest_status, '-1') <> 'FINAL';
                  --Added for CR_0761-Refd In Interim Status--START--
                  select NVL(Dmd_Interest_AMount,0)
                  into LV_Cal_DMD_INT_AMT
                  from xx_dmd_details_gtt
                  WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                  and irt_id=cur_inv_rec.irt_id
                  AND NVL (dmd_interest_status,'-1') <> 'FINAL';                      
                  LV_DMD_INT_AMT:=LV_Cal_DMD_INT_AMT-LV_DMD_INT_AMT;

                --Added for CR_0761-Refd In Interim Status--END--
                  l_chr_dem_int_status                        := 'PROVISIONAL';

				   --added for CR_785 on 28-May-2019
                END IF; -- IF l_chr_int_calc = 'Y'
              END IF;   --IF cur_inv_rec.dmd_status= 'DMD'
              /******************* END OF INT CALC *******************/
              /*********************** APPLICATION ********************/
              write_debug( g_debug_flag , 'Application:' || SQLERRM );
              IF l_num_refd_adjusted_dem = 1 AND NVL ( cur_inv_rec.refd_adjusted_flag, 'N') <> 'Y' THEN
                IF (l_400_amt_due_rem      < l_num_avl_ref_adj_amt ) THEN
                  l_num_orig_apply_amt    := l_400_amt_due_rem;
                ELSE
                  l_num_orig_apply_amt := l_num_avl_ref_adj_amt;
                END IF;
              ELSE
                -- Avoiding to hit payment_schedules
                IF (l_400_amt_due_rem   < l_inv_amt_due_remaining ) THEN
                  l_num_orig_apply_amt := l_400_amt_due_rem;
                ELSE
                  l_num_orig_apply_amt := l_inv_amt_due_remaining;
                END IF;
              END IF;
              l_attribute_rec.attribute6 := 'RULE ' || l_num_rule_count;
              write_debug( g_debug_flag , 'RULE: ' || l_num_rule_count );
              write_debug( g_debug_flag , 'Applying inv: ' || cur_inv_rec.customer_trx_id || 'on receipt: ' || l_400_tbl_data ( i).cash_receipt_id || 'for amount:' || l_num_orig_apply_amt );
              write_debug( g_debug_flag , 'inv amt: ' || l_inv_amt_due_remaining );
              write_debug( g_debug_flag , 'Rcpt amt: ' || l_400_amt_due_rem );
              -- Call Apply API
              l_chr_exe_location := 'DCP_24';
              l_stmt_processing  :='Call Apply API';
              write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
              ar_receipt_api_pub.apply ( p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec.customer_trx_id, p_cash_receipt_id => l_400_tbl_data (i).cash_receipt_id, p_amount_applied => l_num_orig_apply_amt, p_attribute_rec => l_attribute_rec, p_apply_date => g_dte_sys_date, p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data );
              IF l_return_status = fnd_api.g_ret_sts_success THEN
                /**************** UPDATIONS **********************/
                l_inv_amt_due_remaining := l_inv_amt_due_remaining -
                l_num_orig_apply_amt;
                l_400_amt_due_rem     := l_400_amt_due_rem     - l_num_orig_apply_amt;
                l_num_avl_ref_adj_amt := l_num_avl_ref_adj_amt -
                l_num_orig_apply_amt;
                --RO
                write_debug( g_debug_flag , 'Amount due remaining receipt after applcn: ' || l_400_amt_due_rem );
                --updating xx_400_COLLECTIONS_GTT (ORIG)
                l_chr_exe_location := 'DCP_24_1';
                l_stmt_processing  := 'Updating xx_400_COLLECTIONS_GTT (ORIG)';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                UPDATE xx_400_collections_gtt
                SET global_attribute10     = l_400_amt_due_rem,
                  amount_due_remaining     = amount_due_remaining - l_num_orig_apply_amt,
                  request_id               = g_num_request_id,
                  attribute15              = (DECODE (l_400_amt_due_rem, 0, 'COLLECTED', attribute15 ) )
                WHERE cash_receipt_id      = l_400_tbl_data (i).cash_receipt_id;
                l_chr_inv_status          := NULL;
                l_chr_dem_status          := NULL;
                IF l_inv_amt_due_remaining = 0 THEN
                  IF cur_inv_rec.dmd_status IN ('DMD', 'THRESHOLD DMD' ) THEN
                    l_chr_inv_status := 'CLOSED';
                    l_chr_dem_status := 'CLOSED';
                  ELSIF cur_inv_rec.dmd_status IN ('DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED') THEN
                    l_chr_inv_status             := 'PCM CLOSED';
                    l_chr_dem_status             := 'CLOSED';
                  ELSIF cur_inv_rec.dmd_status = 'INT DMD' THEN
                    l_chr_inv_status             := 'INT CLOSED';
                    l_chr_dem_status             := 'INT CLOSED';
                  END IF; -- IF cur_inv_rec.dmd_status IN ('DMD', '
                  -- THRESHOLD DMD')
                ELSE -- IF l_inv_amt_due_remaining = 0
                  l_chr_inv_status := cur_inv_rec.attribute9;
                  l_chr_dem_status := cur_inv_rec.dmd_status;
                END IF; -- IF l_inv_amt_due_remaining = 0
                -- when inserted in dem headers ra_cust_trx --> dmd -->
                -- dmd identified
                --updating xx_DMD_DETAILS_GTT (ORIG)
                l_chr_exe_location := 'DCP_25';
                l_stmt_processing  :='updating xx_DMD_DETAILS_GTT (ORIG)' ;
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                UPDATE xx_dmd_details_gtt
                SET request_id         = g_num_request_id,
                  amount_due_remaining = amount_due_remaining - l_num_orig_apply_amt,
                  attribute9           = l_chr_inv_status,
                  dmd_status        = l_chr_dem_status
                WHERE customer_trx_id  = cur_inv_rec.customer_trx_id;
                 -----Added for CR_761-Refd In Interim Status--START-------
              INSERT
              INTO xxcus.xx_INTERIM_DEM_DTLS
                (
                    IRT_ID, 
                    ID_NUMBER ,
                    IRT_AY ,
                    CUSTOMER_TRX_ID ,
                    DMD_IDENTIFICATION_NUMBER ,
                    ADJUSTED_DMD_AMOUNT ,
                    PROV_INT_DMD_AMT ,
                    DMD_TYPE ,
                    IRT_SCHEDULE_TYPE ,
                    SEC_CODE ,
                    REF_NUM ,
                    REF_IRT_ID ,
                    Program_Name ,
                    REFERENCE_ID ,
                    LAST_UPDATE_DATE 
                )
                VALUES
                (
                  cur_inv_rec.IRT_ID ,
                  cur_inv_rec.id_number ,
                  cur_inv_rec.irt_ay ,
                  cur_inv_rec.CUSTOMER_TRX_ID ,
                  cur_inv_rec.DIN,
                  l_num_orig_apply_amt, 
                  LV_DMD_INT_AMT,
                  cur_inv_rec.dmd_status,
                  cur_inv_rec.irt_schedule_type ,
                  NULL,
                  NULL,      
                  p_in_irt_id,
                  '400 IRT ACCOUNTING',
                  l_400_tbl_data (i).cash_receipt_id,
                  SYSDATE

                );
                If(sql%ROWCOUNT>0) then
                 dbms_output.put_line('Record is inserted into table xx_INTERIM_DEM_DTLS 104'||sql%ROWCOUNT);
                 FND_FILE.put_line ( FND_FILE.LOG,'Record is inserted into table xx_INTERIM_DEM_DTLS 104'|| sql%ROWCOUNT) ;
                end If;
            -----Added for CR_761-Refd In Interim Status--END-------


				--added for partial dmd adjustment----CR_HWSW_0785 on 28-May-2019
                      IF(l_chr_inv_status='CLOSED') THEN
                        SELECT COUNT(1)
                        INTO no_int_calc
                        FROM xx_dmd_headers a
                        WHERE dmd_status='DMD ON STAY'
                        AND EXISTS
                          (SELECT 1
                          FROM xx_dmd_headers b
                          WHERE b.irt_id       = cur_inv_rec.irt_id
                          AND a.irt_id         = b.irt_id
                          AND B.CUSTOMER_TRX_ID= CUR_INV_REC.CUSTOMER_TRX_ID
                          AND to_number(b.attribute15)    = a.customer_trx_id

                          );
						FND_FILE.PUT_LINE(FND_FILE.log, 'no_int_calc: '||no_int_calc);
                        IF (no_int_calc >0) THEN

                          FND_FILE.PUT_LINE(FND_FILE.log, 'Dmd on Stay Case ');
                          --Getting the data of Original DMD
                          SELECT customer_trx_id,
                            irt_id
                          INTO l_orig_cust_trx_id,
                            l_orig_irt_id
                          FROM xx_DMD_HEADERS
                          WHERE CUSTOMER_TRX_ID IN
                            (SELECT ATTRIBUTE15
                            FROM xx_Dmd_headers
                            WHERE customer_trx_id=to_number(cur_inv_rec.customer_trx_id)
                            )
                          AND dmd_status='DMD ON STAY';

						  FND_FILE.PUT_LINE(FND_FILE.log, 'l_orig_cust_trx_id: '||l_orig_cust_trx_id);
						  FND_FILE.PUT_LINE(FND_FILE.log, 'l_orig_irt_id: '||l_orig_irt_id);
                          --Getting the data of Original DMD

                          SELECT NVL (SUM (dmd_interest_amount ), 0 )
                          INTO dem_int_amt
                          FROM xx_dmd_lines
                          WHERE customer_trx_id = cur_inv_rec.customer_trx_id
                          AND reversal_status  IS NULL;
						  FND_FILE.PUT_LINE(FND_FILE.log, 'dem_int_amt: '||dem_int_amt);

                          UPDATE xx_dmd_headers head
                          SET head.dmd_interest_status = 'PROVISIONAL',
                            --request_id                    = g_num_request_id,
                            head.dmd_interest_amount =
                            (SELECT NVL (SUM (dmd_interest_amount ), 0 )
                            FROM xx_dmd_lines
                            WHERE customer_trx_id = head.customer_trx_id
                            AND reversal_status  IS NULL
                            )+dem_int_amt
                            --Added in Ver 4.5
                          WHERE head.customer_trx_id                   = l_orig_cust_trx_id
                          AND NVL (head.dmd_interest_status, '-1') <> 'FINAL';
						  FND_FILE.PUT_LINE(FND_FILE.log, 'Update Success fo records : '||SQL%ROWCOUNT);

                          SELECT COUNT(1)
                          INTO l_dem_lin_count
                          FROM xx_dmd_lines
                          WHERE customer_Trx_id=l_orig_cust_trx_id;
						  FND_FILE.PUT_LINE(FND_FILE.log, 'l_dem_lin_count: '||l_dem_lin_count);
                          IF(l_dem_lin_count   =0) THEN
                            INSERT
                            INTO xx_dmd_lines
                              (
                                customer_trx_id,
                                dmd_interest_amount,
                                int_calc_to_month,
                                cash_receipt_id,
                                last_updated_by,
                                last_update_date,
                                last_update_login,
                                created_by,
                                creation_date,
                                sequence_id,
                                irt_id
                                --Added in Ver 4.5
                              )
                              VALUES
                              (
                                l_orig_cust_trx_id,
                                dem_int_amt,
                                l_400_tbl_data (i).receipt_date,
                                l_400_tbl_data (i).cash_receipt_id,
                                g_num_user_id,
                                SYSDATE,
                                g_num_login_id,
                                g_num_user_id,
                                SYSDATE,
                                NULL,
                                l_orig_irt_id
                                --Added in Ver 4.5
                              );
                            FND_FILE.PUT_LINE
                            (
                              FND_FILE.log, 'Insertion is successful for '||SQL%ROWCOUNT ||' records'
                            )
                            ;
                          ELSE
                            UPDATE xx_dmd_lines
                            SET dmd_interest_amount=dem_int_amt,
                              cash_receipt_id         =l_400_tbl_data (i).cash_receipt_id,
                              int_calc_to_month       =l_400_tbl_data (i).receipt_date,
                              last_updated_by         =g_num_user_id,
                              last_update_date        =SYSDATE,
                              last_update_login       =g_num_login_id
                            WHERE customer_trx_id     =l_orig_cust_trx_id;
                            FND_FILE.PUT_LINE(FND_FILE.log, 'Updation is successful for '||SQL%ROWCOUNT ||' records');
                          END IF;
                        END IF;
                      END IF;
                      --added for partial dmd adjustment----CR_HWSW_0785 on 28-May-2019

                write_debug( g_debug_flag , 'l_inv_amt_due_remaining-**:' || l_inv_amt_due_remaining );
                IF (l_400_tbl_data (i).global_attribute8 IS NULL ) THEN
                  l_chr_exe_location                     := 'DCP_26';
                  l_stmt_processing                      := 'updating xx_DMD_DETAILS_GTT (ORIG)';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  UPDATE xx_dmd_details_gtt
                  SET avl_refd_adjust_amount = avl_refd_adjust_amount - l_num_orig_apply_amt,
                    request_id                 = g_num_request_id
                  WHERE customer_trx_id        = cur_inv_rec.customer_trx_id;
                  /******* RO Issue for Avl for Ref Adj *****/
                ELSIF (L_400_TBL_DATA (I).GLOBAL_ATTRIBUTE8 = 'RO' ) THEN
                  l_chr_exe_location                       := 'DCP_27';
                  l_stmt_processing                        := 'Retriving avl_refd_adjust_amount from xx_dmd_details_gtt ' ;
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  SELECT avl_refd_adjust_amount
                  INTO l_num_ro_avl_ref_adj
                  FROM xx_dmd_details_gtt
                  WHERE customer_trx_id = cur_inv_rec.customer_trx_id;
                  write_debug( g_debug_flag , 'l_num_ro_avl_ref_adj -:' || l_num_ro_avl_ref_adj );
                  l_num_avl_ref_adj_amt := l_num_ro_avl_ref_adj;
                END IF; -- IF (l_400_tbl_data (i).global_attribute8 IS NULL
                /******* UPDATIONS DONE ***********************/
                write_debug( g_debug_flag , 'Status for apply Invoice amount ' || l_num_orig_apply_amt || ' to Receipt Number ' || l_400_tbl_data (i).cash_receipt_id || '-' || l_return_status );
              ELSE -- IF l_return_status = fnd_api.g_ret_sts_success
                write_debug( g_debug_flag , 'Status for apply adjustment amount' || l_num_orig_apply_amt || 'to Receipt Number' || l_400_tbl_data (i).cash_receipt_id || '-' || l_return_status );
                IF l_msg_count > 1 THEN
                  FOR i IN 1 .. l_msg_count
                  LOOP
                    fnd_msg_pub.get ( p_msg_index => -1, p_encoded => 'F', p_data => x_msg_data, p_msg_index_out => l_msg_index_out );
                    p_out_chr_errbuff := p_out_chr_errbuff || '-'||x_msg_data;
                    write_msg( g_write_logfile , 'Error in application ' || x_msg_data);
                  END LOOP; --FOR i IN 1 .. l_msg_count
                ELSE
                  p_out_chr_errbuff := l_msg_data;
                END IF; --IF l_msg_count > 1
                RAISE custom_exception;
              END IF; -- IF l_return_status = fnd_api.g_ret_sts_success
              /************************ REVISED/ RECTIFICATION ****************
              ********/
            ELSIF ( (cur_inv_rec.cust_type_rev_flag IN ('REVISED', 'RECTIFICATION', 'RR REFD RCVBL') ) --Added as rule 0 should
              -- not enter this part
              AND l_400_tbl_data (i).global_attribute8 IS NULL ) THEN
              BEGIN
                l_chr_exe_location := 'DCP_28';
                l_stmt_processing  :='checking ODD exists (Rev) ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                SELECT 1
                INTO l_num_odd_exists
                FROM DUAL
                WHERE EXISTS
                  (SELECT 1
                  FROM xx_overdue_dem_details odd
                  WHERE odd.reversal_status IS NULL
                  AND odd.customer_trx_id    = cur_inv_rec.customer_trx_id
                  );
              EXCEPTION
              WHEN NO_DATA_FOUND THEN
                l_num_odd_exists := 0;
              END;
              write_debug( g_debug_flag , 'odd exists y/n: ' || l_num_odd_exists );
              IF l_num_odd_exists   = 0 THEN
                l_chr_exe_location := 'DCP_30';
                write_debug( g_debug_flag ,l_chr_exe_location );
                l_num_final_odd_amt := 0;
                l_num_temp_amt      := 0;
                FOR l_rec_prev_dem IN
                (SELECT overdue_dem_amt,
                  dem_due_date,
                  customer_trx_id,
                  dmd_status
                FROM xx_tot_overdue_details
                WHERE rectified_customer_trx_id = cur_inv_rec.customer_trx_id
                AND reversal_status            IS NULL
                ORDER BY dem_due_date
                )
                LOOP
                  WRITE_DEBUG( G_DEBUG_FLAG , 'l_rec_prev_dem.overdue_dem_amt** ' || L_REC_PREV_DEM.OVERDUE_DEM_AMT );
                  WRITE_DEBUG( G_DEBUG_FLAG , 'l_rec_prev_dem.dem_due_date** ' || L_REC_PREV_DEM.DEM_DUE_DATE );
                  WRITE_DEBUG( G_DEBUG_FLAG , 'l_rec_prev_dem.customer_trx_id viii** ' || L_REC_PREV_DEM.customer_trx_id );
                  write_debug( g_debug_flag , 'l_num_temp_amt** ' || l_num_temp_amt );
                  write_debug( g_debug_flag , 'l_rec_prev_dem.dmd_status** ' || l_rec_prev_dem.dmd_status );
                  l_chr_exe_location := 'DCP_31';
                  write_debug( g_debug_flag ,l_chr_exe_location );
                  IF l_rec_prev_dem.overdue_dem_amt > l_num_temp_amt THEN
                    IF l_rec_prev_dem.dmd_status IN ('DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED') THEN
                      l_final_dem_due_date := l_calc_dmd_due_date;
                    ELSE
                      l_final_dem_due_date := l_rec_prev_dem.dem_due_date;
                    END IF; --IF l_rec_prev_dem.dmd_status IN
                    l_num_final_odd_amt := l_rec_prev_dem.overdue_dem_amt -
                    l_num_temp_amt;
                    write_debug( g_debug_flag , 'l_num_final_odd_amt** ' || l_num_final_odd_amt );
                    l_num_temp_amt := l_rec_prev_dem.overdue_dem_amt;
                    write_debug( g_debug_flag , 'l_num_temp_amt** ' || l_num_temp_amt );
                    /**** GET PREV DMD DETAILS *****/
                    l_chr_exe_location := 'DCP_32';
                    l_stmt_processing  :='calling INSERT_ODD_DETAILS_PROC';
                    write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                    --calling INSERT_ODD_DETAILS_PROC
                    insert_odd_details_proc (p_out_chr_errbuff => l_chr_ood_errbuff, p_out_chr_retcode => l_chr_ood_retcode, p_in_overdue_amt => l_num_final_odd_amt, -- Latest Amount
                    p_in_curr_overdue_amt => l_num_final_odd_amt, p_in_dem_due_date => l_final_dem_due_date,                                                          -- Orig Due Date
                    p_in_last_int_calc_dte => NULL, p_in_cust_trx_id => cur_inv_rec.customer_trx_id, p_in_irt_id => cur_inv_rec.irt_id );
                    IF l_chr_ood_retcode = g_chr_failure_code THEN
                      p_out_chr_errbuff := l_chr_ood_errbuff;
                      write_msg( g_write_logfile , l_chr_ood_errbuff);
                      RAISE custom_exception;
                    END IF; -- IF l_chr_ood_retcode = g_chr_failure_code
                  END IF;   --IF l_rec_prev_dem.overdue_dem_amt >
                  -- l_num_temp_amt
                END LOOP; -- FOR l_rec_prev_dem IN
              END IF;     -- IF l_num_odd_exists = 0
              l_num_count                := 0;
              l_num_rev_apply_amt        := 0;
              l_num_tot_apply_amt        := 0;
              l_inv_refd_adjust_amount := 0;
              l_count                    := 0;
              l_chr_exe_location         := 'DCP_33';
              write_debug( g_debug_flag ,l_chr_exe_location);
              FOR j IN
              (SELECT l_sequence_no,
                curr_overdue_amt,
                overdue_dem_amt,
                dem_due_date,
                int_calc_to_month
              FROM xx_overdue_dem_details
              WHERE curr_overdue_amt > 0
              AND reversal_status   IS NULL
              AND customer_trx_id    = cur_inv_rec.customer_trx_id
              ORDER BY l_sequence_no
              )
              LOOP
                l_num_count         := l_num_count + 1;
                l_num_int_apply_amt := 0;
                write_debug( g_debug_flag , 'l_sequence_no:' || j.l_sequence_no );
                write_debug( g_debug_flag , 'Amt due rem :' || l_400_amt_due_rem );
                -- If amt due lessens remove - l_num_rev_apply_amt--wont change
                -- as its fetched from cur
                IF (l_400_amt_due_rem > 0) THEN
                  write_debug( g_debug_flag , 'l_chr_int_calc:' || l_chr_int_calc );
                  write_debug( g_debug_flag , 'l_num_avl_ref_adj_amt' || l_num_avl_ref_adj_amt );
                  write_debug( g_debug_flag , 'cur_inv_rec.dmd_status' || cur_inv_rec.dmd_status );
                END IF; -- IF (l_400_amt_due_rem > 0)
                l_chr_int_calc := 'N';
                --------------------- DETERMINE IF IT IS OVERDUE :
                --------------
                IF j.int_calc_to_month IS NULL THEN
                  l_dmd_serv_date   := j.dem_due_date;
                ELSE
                  l_dmd_serv_date := TO_DATE ( '01-' || TO_CHAR (ADD_MONTHS (j.int_calc_to_month, 1 ), 'MON-RRRR' ), 'DD-MON-RRRR' );
                END IF;
                write_debug( g_debug_flag , 'l_chr_dem_int_status:' || l_chr_dem_int_status );
                write_debug( g_debug_flag , 'l_400_tbl_data(i).receipt_date:' || l_400_tbl_data (i).receipt_date );
                write_debug( g_debug_flag , 'l_dmd_serv_date:' || l_dmd_serv_date );
                l_chr_exe_location := 'DCP_34';
                write_debug( g_debug_flag ,l_chr_exe_location);
                IF l_chr_dem_int_status = 'PROVISIONAL' AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) THEN
                  l_month_diff         := MONTHS_BETWEEN (TO_DATE (TO_CHAR ( l_400_tbl_data (i).receipt_date, 'MON-YYYY' ), 'MON-YYYY' ), TO_DATE (TO_CHAR (l_dmd_serv_date, 'MON-YYYY' ), 'MON-YYYY' ) );
                  IF l_month_diff      >= 0 THEN
                    l_chr_int_calc     := 'Y';
                  END IF;
                ELSIF l_chr_dem_int_status IS NULL AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) --RO
                  THEN
                  IF TO_CHAR (l_dmd_serv_date, 'DD') = TO_CHAR (LAST_DAY ( l_dmd_serv_date), 'DD' ) THEN
                    l_dmd_serv_date                 := l_dmd_serv_date + 1;
                  ELSE
                    l_dmd_serv_date := l_dmd_serv_date;
                  END IF;
                  IF l_400_tbl_data (i).receipt_date > l_dmd_serv_date THEN
                    l_chr_int_calc                  := 'Y';
                  END IF;
                END IF; --IF l_chr_dem_int_status = 'PROVISIONAL'
                write_debug( g_debug_flag , 'l_chr_int_calc(R):' || l_chr_int_calc );
                write_debug( g_debug_flag , 'l_num_avl_ref_adj_amt' || l_num_avl_ref_adj_amt );
                write_debug( g_debug_flag , 'cur_inv_rec.dmd_status' || cur_inv_rec.dmd_status );
                write_debug( g_debug_flag , 'l_400_tbl_data (i).global_attribute8' || l_400_tbl_data (i) .global_attribute8 );
                write_debug( g_debug_flag , 'l_rrd_400_chk vishnu:' || l_rrd_400_chk );
                -----------------------------------------------------------------
                IF (l_chr_int_calc = 'Y') AND ( l_num_avl_ref_adj_amt <> 0 ) AND cur_inv_rec.dmd_status IN ('DMD IDENTIFIED', 'DMD') AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) AND NVL(l_rrd_400_chk,'N') <> 'Y' --RO (l_rrd_400_chk
                  -- variable added for CR_HWSW_102)
                 and no_int_calc=0 THEN
                  write_debug( g_debug_flag , 'l_400_tbl_data(i).receipt_date:' || l_400_tbl_data (i).receipt_date );
                  write_debug( g_debug_flag , 'j.curr_overdue_amt:' || j.curr_overdue_amt );
                  --calling dmd_interest_calc
                  l_chr_exe_location := 'DCP_35';
                  l_stmt_processing  :='Calling dmd_interest_calc';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  l_num_int_apply_amt := dmd_interest_calc (l_400_tbl_data ( i).receipt_date, l_dmd_serv_date, ( j.curr_overdue_amt -
                  MOD (j.curr_overdue_amt, 100) ), cur_inv_rec.irt_ay );
                  write_debug( g_debug_flag , 'l_num_int_apply_amt:' || l_num_int_apply_amt );
                  --Dmd Interest population
                  l_chr_exe_location := 'DCP_36';
                  l_stmt_processing  :='Insert into xx_dmd_lines ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  INSERT
                  INTO xx_dmd_lines
                    (
                      customer_trx_id,
                      dmd_interest_amount,
                      int_calc_to_month,
                      cash_receipt_id,
                      last_updated_by,
                      last_update_date,
                      last_update_login,
                      created_by,
                      creation_date,
                      sequence_id,
                      irt_id
                    )
                    VALUES
                    (
                      cur_inv_rec.customer_trx_id,
                      l_num_int_apply_amt,
                      l_400_tbl_data (i).receipt_date,
                      l_400_tbl_data (i).cash_receipt_id,
                      g_num_user_id,
                      SYSDATE,
                      g_num_login_id,
                      g_num_user_id,
                      SYSDATE,
                      j.l_sequence_no,
                      cur_inv_rec.irt_id
                    );
                  --Dmd Interest status and amount update
                  --Added for CR_0761-Refd In Interim Status--START--
                    select NVL(Dmd_Interest_AMount,0)
                    into LV_DMD_INT_AMT
                    from xx_dmd_details_gtt
                    WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                    and irt_id=cur_inv_rec.irt_id
                    AND NVL (dmd_interest_status,'-1') <> 'FINAL';                
                  --Added for CR_0761-Refd In Interim Status--END--
                  l_chr_exe_location := 'DCP_37';
                  l_stmt_processing  := 'Dmd Interest status and amount update ';
                  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                  UPDATE xx_dmd_details_gtt head
                  SET head.dmd_interest_status = 'PROVISIONAL',
                    request_id                    = g_num_request_id,
                    head.dmd_interest_amount   =
                    (SELECT NVL (SUM (dmd_interest_amount ), 0 )
                    FROM xx_dmd_lines
                    WHERE customer_trx_id = head.customer_trx_id
                    AND reversal_status  IS NULL
                    )
                  WHERE head.customer_trx_id                    = cur_inv_rec.customer_trx_id
                  AND NVL (head.dmd_interest_status, '-1' ) <> 'FINAL';
                   --Added for CR_0761-Refd In Interim Status--START--
                  select NVL(Dmd_Interest_AMount,0)
                  into LV_Cal_DMD_INT_AMT
                  from xx_dmd_details_gtt
                  WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                  and irt_id=cur_inv_rec.irt_id
                  AND NVL (dmd_interest_status,'-1') <> 'FINAL';    

                  LV_DMD_INT_AMT:=LV_Cal_DMD_INT_AMT-LV_DMD_INT_AMT;          
                --Added for CR_0761-Refd In Interim Status--END--
                  l_chr_dem_int_status                         := 'PROVISIONAL' ;
                  l_chr_exe_location                           := 'DCP_38';
                  l_stmt_processing                            := 'Updating date in xx_overdue_dem_details ';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  UPDATE xx_overdue_dem_details
                  SET int_calc_to_month = l_400_tbl_data (i).receipt_date,
                    request_id          = g_num_request_id,
                    last_update_date    = g_dte_sys_date,
                    last_updated_by     = g_num_user_id
                  WHERE customer_trx_id = cur_inv_rec.customer_trx_id
                  AND reversal_status  IS NULL
                  AND l_sequence_no     = j.l_sequence_no;

				 --added for CR_785 on 28-May-2019
				ELSIF(l_num_avl_ref_adj_amt <> 0 AND ( l_400_tbl_data (i).global_attribute8 IS NULL ) AND l_rrd_400_chk <> 'Y' --RO (l_rrd_400_chk variable added
                  -- for CR_HWSW_102)
                  and no_int_calc >0) THEN
					l_chr_exe_location := 'DCP_21_PART';
                  l_stmt_processing  :='Calling dmd_interest_calc function ' ;
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  l_adjust_amount := dmd_interest_calc (l_400_tbl_data (i) .receipt_date, l_dmd_serv_date, (l_num_avl_ref_adj_amt -
                  MOD (l_num_avl_ref_adj_amt, 100 ) ), cur_inv_rec.irt_ay );
                  l_chr_exe_location := 'DCP_22';
                  l_stmt_processing  :='Dmd Interest population';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  --Dmd Interest population                 
                  --cant insert in GTT as we just inserted in lines update GTT
                  l_chr_exe_location := 'DCP_23_PART';
                  l_stmt_processing  := 'Dmd Interest status and amount update ';
                  write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
                   --Added for CR_0761-Refd In Interim Status--START--
                    select NVL(Dmd_Interest_AMount,0)
                    into LV_DMD_INT_AMT
                    from xx_dmd_details_gtt
                    WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                    and irt_id=cur_inv_rec.irt_id
                    AND NVL (dmd_interest_status,'-1') <> 'FINAL';                
                --Added for CR_0761-Refd In Interim Status--END--
                  --Dmd Interest status and amount update
                  UPDATE xx_dmd_details_gtt head
                  SET head.dmd_interest_status = 'PROVISIONAL',
                    request_id                    = g_num_request_id,
                    head.dmd_interest_amount   =
                    (SELECT NVL (SUM (dmd_interest_amount ), 0 )
                    FROM xx_dmd_lines
                    WHERE customer_trx_id = head.customer_trx_id
                    AND reversal_status  IS NULL
                    )
                  WHERE head.customer_trx_id                   = cur_inv_rec.customer_trx_id
                  AND NVL (head.dmd_interest_status, '-1') <> 'FINAL';
                  --Added for CR_0761-Refd In Interim Status--START--
                  select NVL(Dmd_Interest_AMount,0)
                  into LV_Cal_DMD_INT_AMT
                  from xx_dmd_details_gtt
                  WHERE customer_trx_id                  = cur_inv_rec.customer_trx_id
                  and irt_id=cur_inv_rec.irt_id
                  AND NVL (dmd_interest_status,'-1') <> 'FINAL';                      
                  LV_DMD_INT_AMT:=LV_Cal_DMD_INT_AMT-LV_DMD_INT_AMT;

                --Added for CR_0761-Refd In Interim Status--END--
                  l_chr_dem_int_status                        := 'PROVISIONAL';

				   --added for CR_785 on 28-May-2019
                END IF; -- IF (l_chr_int_calc = 'Y')
                /************* END OF INT CALCULATION ****************/
                /*********************** APPLICATION ********************/
                -- Avoiding to hit payment_schedules
                IF (l_400_amt_due_rem  < j.curr_overdue_amt) THEN
                  l_num_rev_apply_amt := l_400_amt_due_rem;
                ELSE
                  l_num_rev_apply_amt := j.curr_overdue_amt;
                END IF; --IF (l_400_amt_due_rem < j.curr_overdue_amt)
                l_num_tot_apply_amt     := l_num_tot_apply_amt     + l_num_rev_apply_amt;
                l_inv_amt_due_remaining := l_inv_amt_due_remaining -
                l_num_rev_apply_amt;
                l_400_amt_due_rem     := l_400_amt_due_rem     - l_num_rev_apply_amt;
                l_num_avl_ref_adj_amt := l_num_avl_ref_adj_amt -
                l_num_rev_apply_amt;
                l_num_due_amount := l_num_due_amount - l_num_rev_apply_amt;
                write_debug( g_debug_flag , 'Amount due remaining receipt after applcn: ' || l_400_amt_due_rem );
                /**************** UPDATIONS **********************/
                --updating xx_400_COLLECTIONS_GTT (REV)
                l_chr_exe_location := 'DCP_39';
                l_stmt_processing  :='Updating xx_400_COLLECTIONS_GTT ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                UPDATE xx_400_collections_gtt
                SET global_attribute10 = l_400_amt_due_rem,
                  amount_due_remaining = amount_due_remaining - l_num_rev_apply_amt,
                  request_id           = g_num_request_id,
                  attribute15          = DECODE (l_400_amt_due_rem, 0, 'COLLECTED', attribute15 )
                WHERE cash_receipt_id  = l_400_tbl_data (i).cash_receipt_id;
                 -----Added for CR_761-Refd In Interim Status--START-------
              INSERT
              INTO xxcus.xx_INTERIM_DEM_DTLS
                (
                    IRT_ID, 
                    ID_NUMBER ,
                    IRT_AY ,
                    CUSTOMER_TRX_ID ,
                    DMD_IDENTIFICATION_NUMBER ,
                    ADJUSTED_DMD_AMOUNT ,
                    PROV_INT_DMD_AMT ,
                    DMD_TYPE ,
                    IRT_SCHEDULE_TYPE ,
                    SEC_CODE ,
                    REF_NUM ,
                    REF_IRT_ID ,
                    Program_Name ,
                    REFERENCE_ID ,
                    LAST_UPDATE_DATE 
                )
                VALUES
                (
                  cur_inv_rec.IRT_ID ,
                  cur_inv_rec.id_number ,
                  cur_inv_rec.irt_ay ,
                  cur_inv_rec.CUSTOMER_TRX_ID ,
                  cur_inv_rec.DIN,
                  l_num_rev_apply_amt, 
                  LV_DMD_INT_AMT,
                  cur_inv_rec.dmd_status,
                  cur_inv_rec.irt_schedule_type ,
                  NULL,
                  NULL,      
                  p_in_irt_id,
                  '400 IRT ACCOUNTING',
                  l_400_tbl_data (i).cash_receipt_id,
                  SYSDATE

                );
                If(sql%ROWCOUNT>0) then
                 dbms_output.put_line('Record is inserted into table xx_INTERIM_DEM_DTLS 104'||sql%ROWCOUNT);
                 FND_FILE.put_line ( FND_FILE.LOG,'Record is inserted into table xx_INTERIM_DEM_DTLS 104'|| sql%ROWCOUNT) ;
                end If;
            -----Added for CR_761-Refd In Interim Status--END-------



                l_chr_exe_location    := 'DCP_40';
                l_stmt_processing     :='Updating xx_OVERDUE_DEM_DETAILS ';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                UPDATE xx_overdue_dem_details
                SET curr_overdue_amt       = (curr_overdue_amt - l_num_rev_apply_amt ),
                  request_id               = g_num_request_id,
                  last_update_date         = g_dte_sys_date,
                  last_updated_by          = g_num_user_id
                WHERE customer_trx_id      = cur_inv_rec.customer_trx_id
                AND l_sequence_no          = j.l_sequence_no
                AND reversal_status       IS NULL;
                l_chr_inv_status          := NULL;
                l_chr_dem_status          := NULL;
                IF l_inv_amt_due_remaining = 0 THEN
                  IF cur_inv_rec.dmd_status IN ('DMD','THRESHOLD DMD') THEN
                    l_chr_inv_status := 'CLOSED';
                    l_chr_dem_status := 'CLOSED';
                  ELSIF cur_inv_rec.dmd_status IN ('DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED') THEN
                    l_chr_inv_status             := 'PCM CLOSED';
                    l_chr_dem_status             := 'CLOSED';
                  ELSIF cur_inv_rec.dmd_status = 'INT DMD' THEN
                    l_chr_inv_status             := 'INT CLOSED';
                    l_chr_dem_status             := 'INT CLOSED';
                  END IF;
                ELSE
                  l_chr_inv_status := cur_inv_rec.attribute9;
                  l_chr_dem_status := cur_inv_rec.dmd_status;
                END IF; --IF l_inv_amt_due_remaining = 0
                --updating xx_DMD_DETAILS_GTT (REV)
                l_chr_exe_location := 'DCP_41';
                l_stmt_processing  :='updating xx_DMD_DETAILS_GTT (REV)';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                UPDATE xx_dmd_details_gtt
                SET request_id                            = g_num_request_id,
                  amount_due_remaining                    = amount_due_remaining - l_num_rev_apply_amt,
                  attribute9                              = l_chr_inv_status,
                  dmd_status                           = l_chr_dem_status
                WHERE customer_trx_id                     = cur_inv_rec.customer_trx_id;
                IF (l_400_tbl_data (i).global_attribute8 IS NULL) THEN
                  --updating avl_refd_adjust_amt (REV)
                  l_chr_exe_location := 'DCP_42';
                  l_stmt_processing  :='updating avl_refd_adjust_amt (REV)';
                  write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                  UPDATE xx_dmd_details_gtt
                  SET avl_refd_adjust_amount = avl_refd_adjust_amount - l_num_rev_apply_amt,
                    request_id                 = g_num_request_id
                  WHERE customer_trx_id        = CUR_INV_REC.CUSTOMER_TRX_ID;
                END IF; --IF (l_400_tbl_data (i).global_attribute8 IS NULL)


				--added for partial dmd adjustment----CR_HWSW_0785 on 28-May-2019
                      IF(l_chr_inv_status='CLOSED') THEN
                        SELECT COUNT(1)
                        INTO no_int_calc
                        FROM xx_dmd_headers a
                        WHERE dmd_status='DMD ON STAY'
                        AND EXISTS
                          (SELECT 1
                          FROM xx_dmd_headers b
                          WHERE b.irt_id       = cur_inv_rec.irt_id
                          AND a.irt_id         = b.irt_id
                          AND B.CUSTOMER_TRX_ID= CUR_INV_REC.CUSTOMER_TRX_ID
                          AND to_number(b.attribute15)    = a.customer_trx_id

                          );
						FND_FILE.PUT_LINE(FND_FILE.log, 'no_int_calc: '||no_int_calc);
                        IF (no_int_calc >0) THEN

                          FND_FILE.PUT_LINE(FND_FILE.log, 'Dmd on Stay Case ');
                          --Getting the data of Original DMD
                          SELECT customer_trx_id,
                            irt_id
                          INTO l_orig_cust_trx_id,
                            l_orig_irt_id
                          FROM xx_DMD_HEADERS
                          WHERE CUSTOMER_TRX_ID IN
                            (SELECT ATTRIBUTE15
                            FROM xx_Dmd_headers
                            WHERE customer_trx_id=to_number(cur_inv_rec.customer_trx_id)
                            )
                          AND dmd_status='DMD ON STAY';

						  FND_FILE.PUT_LINE(FND_FILE.log, 'l_orig_cust_trx_id: '||l_orig_cust_trx_id);
						  FND_FILE.PUT_LINE(FND_FILE.log, 'l_orig_irt_id: '||l_orig_irt_id);
                          --Getting the data of Original DMD

                          SELECT NVL (SUM (dmd_interest_amount ), 0 )
                          INTO dem_int_amt
                          FROM xx_dmd_lines
                          WHERE customer_trx_id = cur_inv_rec.customer_trx_id
                          AND reversal_status  IS NULL;
						  FND_FILE.PUT_LINE(FND_FILE.log, 'dem_int_amt: '||dem_int_amt);

                          UPDATE xx_dmd_headers head
                          SET head.dmd_interest_status = 'PROVISIONAL',
                            --request_id                    = g_num_request_id,
                            head.dmd_interest_amount =
                            (SELECT NVL (SUM (dmd_interest_amount ), 0 )
                            FROM xx_dmd_lines
                            WHERE customer_trx_id = head.customer_trx_id
                            AND reversal_status  IS NULL
                            )+dem_int_amt
                            --Added in Ver 4.5
                          WHERE head.customer_trx_id                   = l_orig_cust_trx_id
                          AND NVL (head.dmd_interest_status, '-1') <> 'FINAL';
						  FND_FILE.PUT_LINE(FND_FILE.log, 'Update Success fo records : '||SQL%ROWCOUNT);

                          SELECT COUNT(1)
                          INTO l_dem_lin_count
                          FROM xx_dmd_lines
                          WHERE customer_Trx_id=l_orig_cust_trx_id;
						  FND_FILE.PUT_LINE(FND_FILE.log, 'l_dem_lin_count: '||l_dem_lin_count);
                          IF(l_dem_lin_count   =0) THEN
                            INSERT
                            INTO xx_dmd_lines
                              (
                                customer_trx_id,
                                dmd_interest_amount,
                                int_calc_to_month,
                                cash_receipt_id,
                                last_updated_by,
                                last_update_date,
                                last_update_login,
                                created_by,
                                creation_date,
                                sequence_id,
                                irt_id
                                --Added in Ver 4.5
                              )
                              VALUES
                              (
                                l_orig_cust_trx_id,
                                dem_int_amt,
                                l_400_tbl_data (i).receipt_date,
                                l_400_tbl_data (i).cash_receipt_id,
                                g_num_user_id,
                                SYSDATE,
                                g_num_login_id,
                                g_num_user_id,
                                SYSDATE,
                                NULL,
                                l_orig_irt_id
                                --Added in Ver 4.5
                              );
                            FND_FILE.PUT_LINE
                            (
                              FND_FILE.log, 'Insertion is successful for '||SQL%ROWCOUNT ||' records'
                            )
                            ;
                          ELSE
                            UPDATE xx_dmd_lines
                            SET dmd_interest_amount=dem_int_amt,
                              cash_receipt_id         =l_400_tbl_data (i).cash_receipt_id,
                              int_calc_to_month       =l_400_tbl_data (i).receipt_date,
                              last_updated_by         =g_num_user_id,
                              last_update_date        =SYSDATE,
                              last_update_login       =g_num_login_id
                            WHERE customer_trx_id     =l_orig_cust_trx_id;
                            FND_FILE.PUT_LINE(FND_FILE.log, 'Updation is successful for '||SQL%ROWCOUNT ||' records');
                          END IF;
                        END IF;
                      END IF;
                      --added for partial dmd adjustment----CR_HWSW_0785 on 28-May-2019
                ---------------------------------------------
                write_debug( g_debug_flag , 'Status for apply Invoice amount ' || l_num_rev_apply_amt || ' to Receipt Number ' || l_400_tbl_data (i).cash_receipt_id || '-' || l_return_status );
              END LOOP; --FOR j IN (SELECT l_sequence_no, curr_overdue_amt,
              IF l_num_tot_apply_amt        > 0 THEN
                l_attribute_rec.attribute6 := 'RULE ' || l_num_rule_count;
                write_debug( g_debug_flag , 'l_num_tot_apply_amt:' || l_num_tot_apply_amt );
                --calling Calling Application Api for 400 collecition knockoff
                l_chr_exe_location := 'DCP_43';
                l_stmt_processing  := 'calling Calling Application Api for 400 collecition knockoff';
                write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
                --ar_receipt_api_pub.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec.customer_trx_id, p_cash_receipt_id => l_400_tbl_data (i).cash_receipt_id, p_amount_applied => l_num_tot_apply_amt, p_attribute_rec => l_attribute_rec, p_apply_date => g_dte_sys_date, p_apply_gl_date => g_dte_sys_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data );  --Commented for Hotfix_199485 on 13-MAR-2019
                ar_receipt_api_pub.APPLY (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, p_customer_trx_id => cur_inv_rec.customer_trx_id, p_cash_receipt_id => l_400_tbl_data (i).cash_receipt_id, p_amount_applied => l_num_tot_apply_amt, p_attribute_rec => l_attribute_rec, p_apply_date => cur_inv_rec.irt_approval_date, p_apply_gl_date => cur_inv_rec.irt_approval_date, x_return_status => l_return_status, x_msg_count => l_msg_count, x_msg_data => l_msg_data ); --Added for Hotfix_199485 on 13-MAR-2019
                IF l_return_status <> fnd_api.g_ret_sts_success THEN
                  write_msg( g_write_logfile , 'Status for apply adjustment amount' || l_num_rev_apply_amt || 'to Receipt Number' || l_400_tbl_data (i).cash_receipt_id || '-' || l_return_status );
                  IF l_msg_count > 0 THEN
                    FOR i IN 1 .. l_msg_count
                    LOOP
                      fnd_msg_pub.get (p_msg_index => -1, p_encoded => 'F', p_data => x_msg_data, p_msg_index_out => l_msg_index_out );
                      write_msg( g_write_logfile , 'Error in application ' || x_msg_data );
                      p_out_chr_errbuff := p_out_chr_errbuff || '-' || x_msg_data ;
                    END LOOP;
                  END IF; -- IF l_msg_count > 0 THEN
                  RAISE custom_exception;
                END IF;-- IF l_return_status <> fnd_api.g_ret_sts_success THEN
              END IF;  --IF l_num_tot_apply_amt > 0
            END IF;    -- IF ( ( cur_inv_rec.dmd_status IN ('DMD', '
            -- THRESHOLD DMD')
            -- PERFORM UPDATIONS ON RECEIPTS,OTHERS
            write_debug( g_debug_flag , 'l_num_refd_adjusted_dem:' || l_num_refd_adjusted_dem );
            write_debug( g_debug_flag , 'l_num_avl_ref_adj_amt :' || l_num_avl_ref_adj_amt );
            write_debug( g_debug_flag , 'l_inv_amt_due_remaining :' || l_inv_amt_due_remaining );
            IF l_num_refd_adjusted_dem = 1 AND cur_inv_rec.refd_adjusted_flag <> 'Y' AND l_num_avl_ref_adj_amt = 0 THEN
              RAISE e_skip_exception;
            ELSIF l_inv_amt_due_remaining = 0 THEN
              EXIT;
            END IF;--IF l_num_refd_adjusted_dem = 1
          END LOOP;
        END IF;
        l_chr_exe_location := 'DCP_44';
        l_stmt_processing  := 'Retriving avl_refd_adjust_amount,amount_due_remaining from xx_dmd_details_gtt' ;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        SELECT avl_refd_adjust_amount,
          amount_due_remaining
        INTO l_inv_refd_adjust_amount,
          l_inv_amt_due_remaining
        FROM xx_dmd_details_gtt
        WHERE customer_trx_id      = cur_inv_rec.customer_trx_id;
        IF l_inv_amt_due_remaining < l_inv_refd_adjust_amount THEN
          p_out_chr_errbuff       := 'Error2:Invoice amount due remaining (' || l_inv_amt_due_remaining || ') is less than Available for Refd Adjustment(' || l_inv_refd_adjust_amount || ')' || '. This is invalid scenario. Please check the data for dmd: ' || cur_inv_rec.trx_number ;
          write_msg( g_write_logfile , p_out_chr_errbuff);
          RAISE custom_exception;
        END IF;
      EXCEPTION
      WHEN e_skip_exception THEN
        NULL;
      END;
    END LOOP;
    l_num_rule_count := l_num_rule_count + 1;
  END LOOP;
  /************************ UPDATING BASE TABLES ******************/
  write_debug( g_debug_flag ,'Updating Base tables.. ');
  --updating ar_cash_receipts_all
  l_chr_exe_location := 'DCP_45';
  l_stmt_processing  :='updating ar_cash_receipts_all';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE ar_cash_receipts_all acra
  SET
    (
      global_attribute10,
      attribute15,
      global_attribute8
    )
    =
    (SELECT global_attribute10,
      attribute15,
      global_attribute8
    FROM xx_400_collections_gtt x4cg
    WHERE x4cg.cash_receipt_id = acra.cash_receipt_id
    )
  WHERE EXISTS
    (SELECT 1
    FROM xx_400_collections_gtt x4cg
    WHERE x4cg.cash_receipt_id = acra.cash_receipt_id
    AND request_id            IS NOT NULL
    );
  write_debug( g_debug_flag , 'Number of records updated in ar_cash_receipts_all :' || SQL%ROWCOUNT );
  --updating ra_customer_trx_all
  l_chr_exe_location := 'DCP_46';
  l_stmt_processing  :='Updating ra_customer_trx_all';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE ra_customer_trx_all rcta
  SET attribute9 =
    (SELECT attribute9
    FROM xx_dmd_details_gtt xddg
    WHERE xddg.customer_trx_id = rcta.customer_trx_id
    )
  WHERE EXISTS
    (SELECT 1
    FROM xx_dmd_details_gtt xddg
    WHERE xddg.customer_trx_id = rcta.customer_trx_id
    AND request_id            IS NOT NULL
    );
  write_debug( g_debug_flag , 'Number of records updated in ra_customer_trx_all:' || SQL%ROWCOUNT );
  --updating xx_dmd_headers
  l_chr_exe_location := 'DCP_47';
  l_stmt_processing  :='Updating xx_DMD_HEADERS';
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  UPDATE xx_dmd_headers xdh
  SET
    (
      dmd_status,
      avl_refd_adjust_amount,
      dmd_service_date,
      dmd_due_date,
      dmd_interest_amount,
      dmd_interest_status
    )
    =
    (SELECT dmd_status,
      avl_refd_adjust_amount,
      dmd_service_date,
      dmd_due_date,
      dmd_interest_amount,
      dmd_interest_status
    FROM xx_dmd_details_gtt xddg
    WHERE xddg.customer_trx_id = xdh.customer_trx_id
    )
  WHERE EXISTS
    (SELECT 1
    FROM xx_dmd_details_gtt xddg
    WHERE xddg.customer_trx_id = xdh.customer_trx_id
    AND xddg.irt_id            =xdh.irt_id
    AND request_id            IS NOT NULL
    );
  write_debug( g_debug_flag , 'Number of records updated in xx_dmd_headers:' || SQL%ROWCOUNT );
  /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --START*/
  UPDATE xx_tot_overdue_details xtod
  SET overdue_dem_amt =
    (SELECT avl_refd_adjust_amount
    FROM xx_dmd_details_gtt xddg
    WHERE xddg.customer_trx_id = xtod.customer_trx_id
    AND dmd_status NOT LIKE '%CANCEL%' -- added for Hotfix_139914 to fix
      -- subquery returns multiple rows error
    )
  WHERE EXISTS
    (SELECT 1
    FROM xx_dmd_details_gtt xddg
    WHERE xddg.customer_trx_id = xtod.customer_trx_id
    AND xddg.irt_id            =xtod.irt_id
    AND request_id            IS NOT NULL
    );
  /*Added by Neha on 29-JUL-2016 for Hotfix # 110235 --END*/
  write_debug( g_debug_flag , 'Number of records updated in xx_tot_overdue_details:' || SQL%ROWCOUNT );
  write_debug( g_debug_flag , '*** Apply 400 Receipts to Dmd - ENDS ***' );
EXCEPTION
WHEN custom_exception THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || L_CHR_EXE_LOCATION ||'-' || L_STMT_PROCESSING ||'-' || p_out_chr_errbuff;
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,P_OUT_CHR_RETCODE => L_CHR_RETCODE ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name ||'-' || l_chr_errbuff);
    END IF;
  END IF;
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || L_CHR_EXE_LOCATION ||'-' || L_STMT_PROCESSING ||'-' ||SUBSTR(SQLERRM,1,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => p_out_chr_errbuff ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name ||'-' || l_chr_errbuff);
    END IF;
  END IF;
END dmd_collect_proc;
-------------------------------------------------
PROCEDURE intdmd_collect(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_proc_type IN VARCHAR2 DEFAULT 'R',
    p_in_irt_id    IN VARCHAR2 )
AS
  /****************************************************************************
  *
  * Type : Procedure
  * Name : INTDMD_COLLECT
  * Input Parameters : p_in_proc_type, p_in_irt_id
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : Procedure to apply identified receipts to prior assmet year
  dmds
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 19-Jan-2012
  * Last Reviewed By :
  * Last Reviewed Date :
  *****************************************************************************
  *****
  * Modified Date Modified By Version Modification Type Modification Details
  * ------------- ------------ -------- -----------------
  -------------------------
  * 19-Jan-2012 Infosys 1.0 O Baseline.
  *****************************************************************************
  *****/
  -- User defined exception
  l_exc_exit_error_proc EXCEPTION;
  l_chr_errbuff         VARCHAR2 (1000) := NULL;
  l_chr_retcode         VARCHAR2 (50)   := NULL;
  l_chr_proc_type       VARCHAR2 (10);
  l_proc_errbuff        VARCHAR2 (1000) := NULL;
  l_proc_retcode        VARCHAR2 (50)   := NULL;
BEGIN
  l_chr_proc_type := p_in_proc_type;
  dmd_collect_proc ( p_out_chr_errbuff => l_chr_errbuff, p_out_chr_retcode => l_chr_retcode, p_in_dmd_sts => 'INT DMD', p_in_proc_type => l_chr_proc_type, -- Modified to pass Parameter Value
  p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code OR l_chr_retcode = g_chr_warning_code THEN
    write_msg( g_write_logfile , 'Error while calling xx_dmd_collect_proc:');
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := l_chr_errbuff;
    RAISE l_exc_exit_error_proc;
  END IF;
  write_debug( g_debug_flag , '----------------------------------------------------------------');
  write_debug( g_debug_flag ,'*** Apply 400 Receipts to INT Dmd - ENDS ***') ;
  write_debug( g_debug_flag , '----------------------------------------------------------------');
EXCEPTION
WHEN l_exc_exit_error_proc THEN
  p_out_chr_retcode := g_chr_failure_code;
  write_msg( g_write_logfile ,'---------------------------------------------');
  write_msg( g_write_logfile , 'Exiting Program intdmd_collect : '|| p_out_chr_errbuff|| ' ');
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := ' INTDMD_COLLECT_PROC:'|| SUBSTR (SQLERRM, 1, 255);
  write_msg( g_write_logfile , 'End of Program intdmd_collect: '|| p_out_chr_errbuff);
END intdmd_collect;
-- ***************** End of Function / Procedure **********************--
PROCEDURE receipt_writeoff(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_irt_id IN VARCHAR2 )
AS
  /****************************************************************************
  **********
  * Type : Procedure
  * Name : RECEIPT_WRITEOFF
  * Input Parameters : p_in_irt_id
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : Procedure to apply identified receipts to prior assmet year
  dmds
  *
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 31-Mar-2009
  * Last Reviewed By :
  * Last Reviewed Date :
  *****************************************************************************
  **********
  * Modified Date Modified By Version Modification Type Modification Details *
  * ------------- ------------ -------- -----------------
  -------------------------- *
  * 31-Mar-2009 Infosys 1.0 O Baseline.
  *****************************************************************************
  **********/
  --
  -- User defined exception for Commit with Warning
  --
  l_chr_errbuff      VARCHAR2 (3000);
  l_chr_retcode      VARCHAR2 (50);
  l_chr_proc_name    VARCHAR2 (50);
  l_chr_exe_location VARCHAR2 (50);
  l_stmt_processing  VARCHAR2 (50);
  l_msg_data         VARCHAR2 (5000);
  l_return_status2   VARCHAR2 (1);
  l_attribute_rec ar_receipt_api_pub.attribute_rec_type;
  l_application_ref_type ar_receivable_applications.application_ref_type%TYPE;
  l_application_ref_id ar_receivable_applications.application_ref_id%TYPE;
  l_application_ref_num ar_receivable_applications.application_ref_num%TYPE;
  l_secondary_application_ref_id ar_receivable_applications.secondary_application_ref_id%TYPE;
  l_receivable_application_id ar_receivable_applications.receivable_application_id%TYPE;
  l_exc_exit_error_proc EXCEPTION;
  l_apply_amount        NUMBER;
  l_writeoff_amt        NUMBER;
  l_num_min             NUMBER;
  l_num_max             NUMBER;
  l_num_temp            NUMBER;
  l_msg_count           NUMBER;
  l_count               NUMBER;
  l_num_refd_seq_num  NUMBER;
  l_num_count           NUMBER;
  l_num_writeoff_count  NUMBER;
  --
  --Cursor Declaration
  --
  --
  CURSOR cur_refd_header (p_irt_id VARCHAR2)
  IS
    SELECT head.reference_id,
      head.irt_id,
      head.id_number customer_number,
      head.irt_ay assmt_year,
      head.major_head,
      head.refd_adjustment_amount,
      head.net_refd_amount
    FROM xx_refd_headers head
    WHERE head.refd_status            = 'TO PAY'
    AND NVL (head.net_refd_amount, 0) > 100
    AND head.irt_id                     = p_irt_id
      -- AND ROWNUM < 4001
    ORDER BY head.reference_id;
  CURSOR cur_refd_line (p_in_num_reference_id IN NUMBER)
  IS
    SELECT line.reference_id,
      line.cash_receipt_id,
      line.receipt_ay,
      line.receipt_date,
      ( line.excess_receipt_amount + NVL (line.refd_roundoff_amount, 0) - NVL (line.refd_crossadjust_amount, 0) - NVL (line.rr_refdemadj_amount, 0) ) amount,
      NVL(line.refd_adjustment_amount,0) refd_adjustment_amount,
      NVL (line.net_refd_amount, 0) net_refd_amount
    FROM xx_refd_lines line
    WHERE line.reference_id = p_in_num_reference_id
    ORDER BY line.reference_id,
      line.receipt_date,
      line.cash_receipt_id;
BEGIN -- main program
  p_out_chr_errbuff := '';
  p_out_chr_retcode := g_chr_success_code;
  write_debug( g_debug_flag , '------------------------------------------------------------------');
  write_debug( g_debug_flag , '*** Receipt Write off for Net Refd/Refd Adjustment Program - STARTS ***' );
  write_debug( g_debug_flag , '------------------------------------------------------------------');

  SELECT num_refd_seq.nextval
  INTO l_num_refd_seq_num
  FROM dual;
  --End of code added in version 2.1
  l_num_min   := 0;
  l_num_max   := 0;
  l_num_temp  := 0;
  l_num_count := 0;
  --l_recpt_writeoff_count := 0;
  --l_recpt_writeoff_tbl.DELETE;
  FOR cur_refd_header_rec IN cur_refd_header(p_in_irt_id)
  LOOP
    l_apply_amount := NULL;
    l_apply_amount := cur_refd_header_rec.net_refd_amount;
    l_writeoff_amt :=0;
    -- l_num_refd_seq_num := l_num_refd_seq_num + 1;-- Commented as part of
    -- Recomendation 3 from ACS
    SELECT num_refd_seq.nextval
    INTO l_num_refd_seq_num
    FROM dual;
    FOR cur_refd_line_rec IN cur_refd_line ( cur_refd_header_rec.reference_id)
    LOOP
      EXIT
    WHEN l_apply_amount  = 0;
      IF l_apply_amount >= ( cur_refd_line_rec.amount -
        cur_refd_line_rec.refd_adjustment_amount ) THEN
        l_writeoff_amt :=( cur_refd_line_rec.amount -
        cur_refd_line_rec.refd_adjustment_amount);
      ELSE
        l_writeoff_amt := l_apply_amount;
      END IF;
      l_msg_data                 := NULL;
      l_msg_count                := NULL;
      l_attribute_rec.attribute4 := 'NET REFD';
      l_attribute_rec.attribute1 := cur_refd_header_rec.major_head;
      l_attribute_rec.attribute3 := cur_refd_header_rec.assmt_year;
      l_attribute_rec.attribute5 := l_num_refd_seq_num;
      ar_receipt_api_pub.activity_application (p_api_version => 1.0, p_init_msg_list => fnd_api.g_true, p_commit => fnd_api.g_false, p_validation_level => fnd_api.g_valid_level_full, x_return_status => l_return_status2, x_msg_count => l_msg_count, x_msg_data => l_msg_data, p_cash_receipt_id => cur_refd_line_rec.cash_receipt_id, p_amount_applied => l_writeoff_amt , p_applied_payment_schedule_id => g_payment_schedule_id, p_receivables_trx_id => g_receivables_trx_id, p_attribute_rec => l_attribute_rec, p_application_ref_type => l_application_ref_type, p_application_ref_id => l_application_ref_id, p_application_ref_num => l_application_ref_num, p_secondary_application_ref_id => l_secondary_application_ref_id, p_receivable_application_id => l_receivable_application_id );
      write_debug( g_debug_flag , 'Apply receipt writeoff for reference_id ' || cur_refd_line_rec.reference_id || ' receipt ID ' || cur_refd_line_rec.cash_receipt_id || ' for net refd amount ' || l_writeoff_amt || ' - ' || l_return_status2 );
	  dbms_output.put_line('Apply receipt writeoff for reference_id ' || cur_refd_line_rec.reference_id || ' receipt ID ' || cur_refd_line_rec.cash_receipt_id || ' for net refd amount ' || l_writeoff_amt || ' - ' || l_return_status2 );
      IF l_return_status2     = 'S' THEN
        l_num_writeoff_count := l_num_writeoff_count + 1;
        UPDATE xx_refd_lines line
        SET line.net_refd_amount = NVL (line.net_refd_amount, 0) + l_writeoff_amt
        WHERE line.reference_id    = cur_refd_line_rec.reference_id
        AND line.cash_receipt_id   = cur_refd_line_rec.cash_receipt_id;
      ELSIF l_msg_count            = 1 THEN
        write_msg( g_write_logfile ,'l_msg_data '|| RTRIM (LTRIM (l_msg_data)) || '****');
        p_out_chr_errbuff := l_msg_data ;
        RAISE l_exc_exit_error_proc;
      ELSIF l_msg_count > 1 THEN
        LOOP
          l_count       := l_count + 1;
          l_msg_data    :=fnd_msg_pub.get (fnd_msg_pub.g_next, fnd_api.g_false);
          IF l_msg_data IS NULL THEN
            EXIT;
          END IF;
          p_out_chr_errbuff := p_out_chr_errbuff|| '-' ||l_msg_data ;
        END LOOP;
        fnd_file.put_line (fnd_file.LOG,'Message ---' || p_out_chr_errbuff );
        RAISE l_exc_exit_error_proc;
      END IF;
      l_apply_amount := l_apply_amount - l_writeoff_amt;
    END LOOP; --Line Loop
    UPDATE xx_refd_headers head
    SET head.refd_status   = 'PAID'
    WHERE head.refd_status = 'TO PAY'
    AND head.reference_id    = cur_refd_header_rec.reference_id;
  END LOOP; --Header Loop

  write_debug( g_debug_flag , '------------------------------------------------------------------------------------------------' );
  write_debug( g_debug_flag , '*** Receipt Write off for Net Refd/Refd Adjustment Program - ENDS ***');
  write_debug( g_debug_flag , '------------------------------------------------------------------------------------------------' );
EXCEPTION
WHEN l_exc_exit_error_proc THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' ||l_stmt_processing ||'-' || p_out_chr_errbuff;
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - ' || l_chr_proc_name || '-' ||l_chr_errbuff );
    END IF;
  END IF;
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Unexpected Error in procedure ' || l_chr_proc_name || '-' || l_chr_exe_location ||'-' ||l_stmt_processing ||'-' || SUBSTR(sqlerrm,1 ,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name || '-' ||l_chr_errbuff );
    END IF;
  END IF;
END receipt_writeoff;
-----********************************* End of Procedure / Function ************
-- ******************---------------
PROCEDURE refd_payable(
    p_out_chr_errbuff OUT VARCHAR2 ,
    p_out_chr_retcode OUT VARCHAR2 ,
    p_in_irt_id IN VARCHAR2,
    p_in_req_id IN NUMBER
    /*Modified on 10-01-2012 , As per requirements */
  )
AS
  /****************************************************************************
  ***********
  * Type : Procedure
  * Name : REFD_PAYABLE
  * Input Parameters : None
  * Output Parameters : out_chr_errbuff
  * out_chr_retcode
  * Purpose : Procedure to apply invoice to receipts
  *
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 12-Jan-2012
  * Last Reviewed By : Infosys
  * Last Reviewed Date :
  *****************************************************************************
  ***********
  * Modified Date Modified By Version Modification Type Modification Details *
  * ------------- ------------ -------- - -----------------
  -------------------------- *
  * 12-Jan-2012 Infosys 1.0 O Baseline. *
  *****************************************************************************
  ***********/
  l_invoice_interface_id      NUMBER;
  l_invoice_line_interface_id VARCHAR2(50);
  l_legal_entity_id           NUMBER;
  l_orgid                     NUMBER;
  x_invoice_id                NUMBER;
  x_msg_count                 NUMBER;
  l_num_ref_count             NUMBER := 0;
  l_rfnd_pay_chk              NUMBER ;
  l_rfnd_stat                 VARCHAR2 (250);
  l_global_attribute20        VARCHAR2 (250);       --added for CR#611 on 30-Mar-18
  l_rfnd_stat1                VARCHAR2 (250):=NULL; --added for CR#611 on 30-Mar-18
  l_invoice_number            VARCHAR2 (50);
  x_return_status             VARCHAR2 (2000);
  x_msg_data                  VARCHAR2 (2000);
  l_chr_errbuff               VARCHAR2 (3000);
  l_chr_retcode               VARCHAR2 (50);
  l_chr_proc_name             VARCHAR2 (250);
  l_chr_exe_location          VARCHAR2 (250);
  L_STMT_PROCESSING           VARCHAR2 (250);
  L_FILING_MODE "process_store"."irt_process_control_mstr"."x_mode_of_filling_cd"@psql_process_fas%type;--added for
  -- hotfix#153321
  L_Source "process_store"."irt_process_control_mstr"."x_source_name"@psql_process_fas%TYPE; --added for hotfix#153321
  l_rejection_list ap_import_invoices_pkg.rejection_tab_type;
  l_exc_exit_error_proc EXCEPTION;
  v_approval_flag IRT_STDCMP.IBA_REFD_RETURNS.approval_flag%TYPE; -- Added for CR - 611 on 09-APR-2018
  -- Added for CR#729 - 241a - 22-Oct-2018 -- starts
  l_241a_flag  "process_store"."irt_process_control_mstr"."x_flag_241a"@psql_process_fas%TYPE;
  v_approval_x_flag_241a IRT_STDCMP.IBA_REFD_RETURNS.approval_flag%TYPE;
  l_241a_rec    VARCHAR2(1) := 'N';
  l_ao_blck_rec VARCHAR2(1) := 'N';
  -- Added for CR#729 - 241a - 22-Oct-2018 -- ends
TYPE tbl_reference_id
IS
  TABLE OF NUMBER INDEX BY BINARY_INTEGER;
  l_refd_tbl tbl_reference_id;
  CURSOR cur_refd_header( p_in_irt_id IN VARCHAR2)
  IS
    SELECT head.reference_id,
      head.id_number customer_number,
      head.irt_ay assmt_year,
      head.major_head major_head,
      head.irt_id irt_id,
      head.irt_schedule_type,
      head.refd_status,
      appl.refd_type,
      appl.refd_seq_number,
      appl.amount refd_amount
    FROM xx_REFD_HEADERS head,
      xx_REFDAPPLICATIONS_V1 appl
    WHERE head.refd_status IN ('PAID', 'THRESHOLD LIMIT')
    AND head.process_flag     = 'N'
    AND appl.reference_id     = head.reference_id
    AND head.irt_id           =p_in_irt_id
      /* Modification started for Dual Invoice Issue by Yogesh on 21-jun-2012
      include in new code 28-jun-11*/
      /*AND NOT EXISTS
      (SELECT 1
      FROM ap_invoices_all ap
      WHERE ap.attribute8=appl.refd_seq_number
      and ap.attribute3=head.id_number
      and ap.attribute4=head.irt_ay)
      */
      /* Modification ended for Dual Invoice Issue by Yogesh on 21-jun-2012
      include in new code 28-jun-11*/
    ORDER BY head.reference_id;
BEGIN -- main program
  p_out_chr_errbuff := ' In Start of Refd';
  p_out_chr_retcode := g_chr_success_code;
  l_chr_proc_name   := 'xx_refd_payable_proc';
  write_debug( g_debug_flag , '*** xx_REFD_PAYABLE_PROC module: Refd Payable Program - STARTS ***');
  Write_Debug( G_Debug_Flag , 'Program start time : ' || TO_CHAR (SYSDATE, 'DD-MON-YYYY hh24:mi:ss') );
  dbms_output.put_line(' In Start of Refd Payable procedure');

  dbms_output.put_line('Initialize Variables :'||g_num_user_id||':'||g_pay_resp_id||':'||g_pay_application_id);

  --FND_GLOBAL.APPS_INITIALIZE (g_num_user_id, g_pay_resp_id, g_pay_application_id );
 -- FND_GLOBAL.APPS_INITIALIZE (1092, 20639, 200 );

dbms_output.put_line('Initialize Variables.. :'||g_num_user_id||':'||g_pay_resp_id||':'||g_pay_application_id);

  FOR cur_refd_header_rec IN cur_refd_header(p_in_irt_id)
  LOOP

  dbms_output.put_line('Start cur_refd_header_rec ');
    l_invoice_interface_id      := 0;
    l_invoice_line_interface_id :=0;
    l_invoice_number            := 0;
    --Added for CR#729 - 241a - 22-Oct-2018 - starts
    BEGIN
      SELECT NVL("x_flag_241a",'X')
      INTO l_241a_flag
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE "irt_id"              =p_in_irt_id
      AND NVL("x_source_name",'X') <> 'IBA-WS';
    END;
    IF l_241a_flag = 'Y' THEN
      BEGIN
        SELECT NVL(approval_flag,'X')
        INTO v_approval_x_flag_241a
        FROM irt_stdcmp.IBA_refd_returns
        WHERE irt_id = p_in_irt_id;
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_approval_x_flag_241a := 'X';
        FND_FILE.PUT_LINE (FND_FILE.LOG, 'No approval_flag found for IRT_ID: '||p_in_irt_id);
        dbms_output.put_line('No approval_flag found for IRT_ID: '||p_in_irt_id);
      END;
      IF NVL(v_approval_x_flag_241a,'X') = 'H' THEN
        l_241a_rec                    := 'Y';
        FND_FILE.PUT_LINE (FND_FILE.LOG, 'Its a 241a record.');
        dbms_output.put_line('Its a 241a record.');
      END IF; --NVL(v_approval_x_flag_241a,'X') = 'H'
    ELSE      --Added for CR#729 - 241a - 22-Oct-2018 - ends
      /*added for hotfix#153321 starts
      added to temporarily stop IBA refds to be processed in refd outward*/
      BEGIN
        SELECT "x_mode_of_filling_cd",
          "x_source_name"
        INTO L_FILING_MODE ,
          L_SOURCE
        FROM "process_store"."irt_process_control_mstr"@psql_process_fas
        WHERE "irt_id" =P_IN_IRT_ID;
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| 'Unable to find X_MODE_OF_FILING_CD,SOURCE_NAME');
      END;
      /*added for hotfix#153321 ends
      added to temporarily stop IBA refds to be processed in refd outward*/
      IF L_SOURCE IN ('IBA-P', 'IBA-E') THEN
        BEGIN
          SELECT approval_flag
          INTO v_approval_flag
          FROM irt_stdcmp.IBA_refd_returns
          WHERE irt_id = P_IN_IRT_ID;
        EXCEPTION
        WHEN no_data_found THEN
          NULL;
        END;
        IF (NVL(v_approval_flag, 'X') = 'B') THEN -- Added for CR#729 - 241a - 22-Oct-2018 -- starts
          l_ao_blck_rec              := 'Y';
          FND_FILE.PUT_LINE (FND_FILE.LOG, 'Its a AO blcked refd record.');
          dbms_output.put_line('Its a AO blcked refd record.');
        END IF; -- Added for CR#729 - 241a - 22-Oct-2018 --ends
      END IF;
    END IF; --l_241a_flag = 'Y'
    IF cur_refd_header_rec.refd_type = 'NET REFD' AND cur_refd_header_rec.refd_status = 'PAID' AND cur_refd_header_rec.refd_amount > 100 THEN
      l_chr_exe_location                := 'RPP_0006';
      l_stmt_processing                 := 'Generating ap_invoices_interface_s Sequence id';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT ap_invoices_interface_s.NEXTVAL INTO l_invoice_interface_id FROM DUAL;
      l_chr_exe_location := 'RPP_0006';
      l_stmt_processing  := 'Generating ap_invoice_lines_interface_s Sequence id';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT ap_invoice_lines_interface_s.NEXTVAL
      INTO l_invoice_line_interface_id
      FROM DUAL;
      l_invoice_number   := l_invoice_interface_id;
      l_chr_exe_location := 'RPP_00007';
      l_stmt_processing  := 'Check before Inserting into ap_invoices_interface ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      --Added on 18-July -12 for invoice creation of refd whitelisting cases
      BEGIN
        l_rfnd_pay_chk := 0;
        l_rfnd_stat    :=NULL;
        SELECT 1
        INTO l_rfnd_pay_chk
        FROM DUAL
        WHERE 2 = 2
        AND EXISTS
          (SELECT 1
          FROM xx_irt_fas_prcsng_hold
          WHERE irt_id      = cur_refd_header_rec.irt_id
          AND hold_flag    IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
          AND release_flag IS NULL
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        NULL;
      WHEN OTHERS THEN
        p_out_chr_retcode := g_chr_failure_code;
        p_out_chr_errbuff := p_out_chr_retcode || 'Error in Fetching Data from xx_IRT_FAS_PRCSNG_HOLD ' || SQLERRM;
		dbms_output.put_line(p_out_chr_retcode || 'Error in Fetching Data from xx_IRT_FAS_PRCSNG_HOLD ' || SQLERRM);
        RAISE l_exc_exit_error_proc;
      END;
      ---------ADDED FOR CR#611 ON 30-MAR-18-------Start-----------
      --IF (l_rfnd_pay_chk   =0 AND L_FILING_MODE ='PC' AND (NVL(v_approval_flag, 'X') = 'B')) THEN
      IF (l_rfnd_pay_chk    =0 AND l_241a_rec = 'Y') THEN -- Added for CR#729 - 241a - 22-Oct-2018
        l_rfnd_stat        := '241A WITHHELD REFD CASES';
      ELSIF (l_rfnd_pay_chk =0 AND L_FILING_MODE ='PC' AND l_ao_blck_rec = 'Y') THEN
        l_rfnd_stat        := 'IBA REFD BLOCKED BY AO';
      ELSIF l_rfnd_pay_chk  = 0 THEN --Added in 2.0
        l_rfnd_stat        := 'Ready for Refd Banker';
      ELSIF l_rfnd_pay_chk  = 1 THEN
        l_rfnd_stat        := 'FAS REFD HOLD';
      END IF;
      IF (L_FILING_MODE       ='PC' AND L_SOURCE IN ('IBA-P','IBA-E')) THEN
        l_global_attribute20 := 'IBA';
      ELSE
        l_global_attribute20 := NULL;
      END IF;
      ---------ADDED FOR CR#611 ON 30-MAR-18-------End-----------
      --------------------------------------------------------------------------
      l_chr_exe_location := 'RPP_0007';
      l_stmt_processing  := 'Inserting into ap_invoices_interface ';
      WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
	  dbms_output.put_line(L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
      -- IF (L_FILING_MODE ='PC' AND L_SOURCE = 'IBA') THEN --added for
      -- hotfix#153321
      --IF (L_FILING_MODE ='PC' AND L_SOURCE LIKE 'IBA%') THEN--added for cr#611 --COMMENTED FOR CR#611 AND ADDED ABOVE WITH l_rfnd_pay_chk =0
      INSERT
      INTO ap_invoices_interface
        (
          invoice_id,
          invoice_num,
          invoice_type_lookup_code,
          invoice_date,
          invoice_amount,
          invoice_currency_code,
          terms_name,
          gl_date,
          last_update_date,
          last_updated_by,
          last_update_login,
          creation_date,
          created_by,
          SOURCE,
          payment_currency_code,
          payment_method_lookup_code,
          payment_cross_rate_date,
          exclusive_payment_flag,
          org_id,
          application_id,
          legal_entity_id,
          vendor_id,
          vendor_site_id,
          attribute3,
          attribute4,
          attribute1,
          attribute7,
          attribute8,
          ATTRIBUTE10,
          ATTRIBUTE14,
          REQUEST_ID ,--To improve Performance - 18-Mar-2015.
          GLobal_attribute20
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          'STANDARD',
          SYSDATE,
          cur_refd_header_rec.refd_amount,
          'INR',
          'IMMEDIATE',
          SYSDATE,
          SYSDATE,
          g_num_user_id,
          g_num_login_id,
          SYSDATE,
          g_num_user_id,
          'MANUAL INVOICE ENTRY',
          'INR',
          'IT_REFD_PAY_METHOD',
          SYSDATE,
          'N',
          g_num_org_id,
          g_pay_application_id,
          g_legal_entity_id,
          g_vendor_id,
          g_vendor_site_id,
          cur_refd_header_rec.customer_number,
          cur_refd_header_rec.assmt_year,
          cur_refd_header_rec.major_head,
          l_rfnd_stat,
          cur_refd_header_rec.refd_seq_number,
          CUR_REFD_HEADER_REC.REFERENCE_ID,
          CUR_REFD_HEADER_REC.REFD_TYPE,
          P_IN_REQ_ID ,        --To improve Performance - 18-Mar-2015
          l_global_attribute20 --commented 'IBA' for CR#611 on 30-Mar-18 to remove if-else condition
        );

      l_chr_exe_location := 'RPP_0008';
      l_stmt_processing  := 'Inserting into ap_invoice_lines_interface ';
	  dbms_output.put_line('Inserting into ap_invoice_lines_interface ');
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      INSERT
      INTO ap_invoice_lines_interface
        (
          invoice_id,
          invoice_line_id,
          line_number,
          line_type_lookup_code,
          amount,
          dist_code_combination_id,
          last_updated_by,
          last_update_date,
          last_update_login,
          created_by,
          creation_date,
          org_id
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          1,
          'ITEM',
          cur_refd_header_rec.refd_amount,
          g_refd_ccid,
          g_num_user_id,
          SYSDATE,
          g_num_login_id,
          g_num_user_id,
          SYSDATE,
          l_orgid
        );
      l_chr_exe_location := 'RPP_0009';
      L_STMT_PROCESSING  := 'calling package AP_IMPORT_INVOICES_PKG.SUBMIT_PAYMENT_REQUEST ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
	  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing ) ;
      AP_IMPORT_INVOICES_PKG.SUBMIT_PAYMENT_REQUEST ( p_api_version => 1.0 , p_invoice_interface_id => l_invoice_interface_id , p_budget_control => 'N' , p_needs_invoice_approval => 'Y', -- 'N' for
      -- testing, 'Y' for production
      p_invoice_id => X_INVOICE_ID , x_return_status => X_RETURN_STATUS , x_msg_count => X_MSG_COUNT , x_msg_data => X_MSG_DATA , x_rejection_list => L_REJECTION_LIST , p_calling_sequence => '.create_refd' , p_commit => 'N'
      --  p_conc_request_id=> p_in_req_id
      ) ;
      l_chr_exe_location := 'RPP_0010';
      L_STMT_PROCESSING  := ' ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      IF X_RETURN_STATUS = 'S' THEN
        write_debug ( G_Debug_Flag,'Creation of AP invoice number ' || l_invoice_number || ' for amount ' || cur_refd_header_rec.refd_amount || ' is ' || x_return_status ) ;
		dbms_output.put_line('Creation of AP invoice number ' || l_invoice_number || ' for amount ' || cur_refd_header_rec.refd_amount || ' is ' || x_return_status ) ;
      END IF;
      l_chr_exe_location := 'RPP_0011';
      l_stmt_processing  := 'Checking the status of the API Submit request ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      IF x_return_status <> FND_API.G_RET_STS_SUCCESS THEN
        FOR i IN l_rejection_list.FIRST .. l_rejection_list.LAST
        LOOP
          write_debug
          (
            G_Debug_Flag, i || ' Errors found interfacing data to AP ...'
          )
          ;
          write_debug ( G_Debug_Flag, l_rejection_list (i).reject_lookup_code ) ;
		  dbms_output.put_line('Errors found interfacing data to AP..'||l_rejection_list (i).reject_lookup_code );
          p_out_chr_errbuff := p_out_chr_errbuff || '-' || l_rejection_list ( i ) .reject_lookup_code ;
        END LOOP; -- LOOP
        p_out_chr_retcode := g_chr_failure_code ;
        RAISE l_exc_exit_error_proc;
      END IF;
    END IF;
    IF cur_refd_header_rec.refd_type = 'IRF NRI TS' THEN
      l_chr_exe_location                := 'RPP_0012';
      L_STMT_PROCESSING                 := ' Requesting for new ap_invoices_interface_s Sequence id';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      SELECT ap_invoices_interface_s.nextval INTO l_invoice_interface_id FROM dual;
      l_chr_exe_location := 'RPP_0013';
      L_STMT_PROCESSING  := ' Requesting for new ap_invoice_lines_interface_s Sequence id';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT ap_invoice_lines_interface_s.NEXTVAL
      INTO l_invoice_line_interface_id
      FROM dual;
      l_invoice_number   := l_invoice_interface_id;
      l_chr_exe_location := 'RPP_0014';
      l_stmt_processing  := 'Inserting into ap_invoices_interface ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      --  IF (L_FILING_MODE ='PC' AND L_SOURCE = 'IBA') THEN --added for
      -- hotfix#153321
      ---------ADDED FOR CR#611 ON 30-MAR-18-------Start-----------
      l_global_attribute20          := NULL;
      IF (L_FILING_MODE              ='PC' AND l_source IN ('IBA-E', 'IBA-P')) THEN
        l_global_attribute20        := 'IBA';
        IF NVL(v_approval_flag, 'X') = 'B' THEN --ADDED FOR CR#611 ON 30-MAR-18
          l_rfnd_stat1              := 'IBA REFD BLOCKED BY AO';
        ELSE
          l_rfnd_stat1 := 'Ready for Refd Banker';
        END IF;
      ELSE
        l_rfnd_stat1         := 'Ready for Refd Banker';
        l_global_attribute20 := NULL;
      END IF;
      l_chr_exe_location := 'RPP_00014_1';
      l_stmt_processing  := 'Inserting into ap_invoices_interface1 ';
      WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
	  dbms_output.put_line(L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
      ---------ADDED FOR CR#611 ON 30-MAR-18-------Start-----------
      --IF (L_FILING_MODE ='PC' AND L_SOURCE LIKE 'IBA%') THEN --added for cr#611 --COMMENTED FOR CR#611 AND ADDED ABOVE ON 30-MAR-18
      INSERT
      INTO ap_invoices_interface
        (
          invoice_id,
          invoice_num,
          invoice_type_lookup_code,
          invoice_date,
          invoice_amount,
          invoice_currency_code,
          terms_name,
          gl_date,
          last_update_date,
          last_updated_by,
          last_update_login,
          creation_date,
          created_by,
          source,
          payment_currency_code,
          payment_method_lookup_code,
          payment_cross_rate_date,
          exclusive_payment_flag,
          org_id,
          application_id,
          legal_entity_id,
          vendor_id,
          vendor_site_id,
          attribute3,
          attribute4,
          attribute1,
          attribute7,
          attribute8,
          ATTRIBUTE10,
          ATTRIBUTE14,
          REQUEST_ID, --To Improve Performance -18-Mar-2015
          global_attribute20
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          'STANDARD',
          SYSDATE,
          cur_refd_header_rec.refd_amount,
          'INR',
          'IMMEDIATE',
          SYSDATE,
          SYSDATE,
          g_num_user_id,
          g_num_login_id,
          SYSDATE,
          g_num_user_id,
          'MANUAL INVOICE ENTRY',
          'INR',
          'IT_REFD_PAY_METHOD',
          SYSDATE,
          'N',
          g_num_org_id,
          g_pay_application_id,
          g_legal_entity_id,
          g_vendor_id,
          g_vendor_site_id,
          cur_refd_header_rec.customer_number,
          cur_refd_header_rec.assmt_year,
          cur_refd_header_rec.major_head,
          l_rfnd_stat1, --'Ready for Refd Banker', --added l_rfnd_stat1 as a part of CR#611 on 30-Mar-18
          cur_refd_header_rec.refd_seq_number,
          cur_refd_header_rec.reference_id,
          CUR_REFD_HEADER_REC.REFD_TYPE,
          p_in_req_id,         --To improve Performance - 18-Mar-2015
          l_global_attribute20 -- commented 'IBA' as a part of CR#611 on 30-Mar-18 to remove if-else condition
        );

      l_chr_exe_location := 'RPP_0015';
      l_stmt_processing  := 'Inserting into ap_invoice_lines_interface ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      INSERT
      INTO ap_invoice_lines_interface
        (
          invoice_id ,
          invoice_line_id ,
          line_number ,
          line_type_lookup_code ,
          amount ,
          dist_code_combination_id ,
          last_updated_by ,
          last_update_date ,
          last_update_login ,
          created_by ,
          creation_date ,
          org_id
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          1,
          'ITEM',
          cur_refd_header_rec.refd_amount,
          g_adjustment_ccid,
          g_num_user_id,
          SYSDATE,
          g_num_login_id,
          g_num_user_id,
          SYSDATE,
          l_orgid
        );
      write_debug ( G_Debug_Flag, 'Calling Import API' ) ;
      l_chr_exe_location := 'RPP_0016';
      l_stmt_processing  := 'Calling package ap_import_invoices_pkg.submit_payment_request ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      AP_IMPORT_INVOICES_PKG.SUBMIT_PAYMENT_REQUEST ( p_api_version => 1.0, p_invoice_interface_id => l_invoice_interface_id , p_budget_control => 'N' , p_needs_invoice_approval => 'Y' -- 'N' for
      -- testing, 'Y' for production
      , p_invoice_id => x_invoice_id , x_return_status => x_return_status , x_msg_count => x_msg_count , x_msg_data => x_msg_data , x_rejection_list => l_rejection_list , p_calling_sequence => '.create_refd', p_commit => 'N'--ADDED AS PART OF HOTFIX#144367
      --,  p_conc_request_id=> p_in_req_id
      ) ;
      l_chr_exe_location := 'RPP_0017';
      l_stmt_processing  := 'Checking return value of x_return_status ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      IF x_return_status = 'S' THEN
        write_debug ( g_debug_flag, 'Creation of AP invoice number ' || l_invoice_number || ' for amount ' || CUR_REFD_HEADER_REC.REFD_AMOUNT || ' is ' || X_RETURN_STATUS ) ;
      END IF;
      IF x_return_status <> fnd_api.g_ret_sts_success THEN
        FOR i IN l_rejection_list.FIRST .. l_rejection_list.LAST
        LOOP
          write_debug
          (
            g_debug_flag, i || ' Errors found interfacing data to AP ...'
          )
          ;
          p_out_chr_errbuff := p_out_chr_errbuff ||'-' ||l_rejection_list ( i ) .reject_lookup_code;
        END LOOP;
        write_msg ( g_write_logfile, P_OUT_CHR_ERRBUFF ) ;
        RAISE l_exc_exit_error_proc;
      END IF;
    END IF;
    IF cur_refd_header_rec.refd_type = 'REFD ADJUSTMENT' THEN
      l_chr_exe_location                := 'RPP_0012';
      L_STMT_PROCESSING                 := ' Requesting for new ap_invoices_interface_s Sequence id';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      SELECT ap_invoices_interface_s.nextval INTO l_invoice_interface_id FROM dual;
      l_chr_exe_location := 'RPP_0013';
      L_STMT_PROCESSING  := ' Requesting for new ap_invoice_lines_interface_s Sequence id';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT ap_invoice_lines_interface_s.NEXTVAL
      INTO l_invoice_line_interface_id
      FROM dual;
      l_invoice_number   := l_invoice_interface_id;
      l_chr_exe_location := 'RPP_0014';
      l_stmt_processing  := 'Inserting into ap_invoices_interface ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      ---------ADDED FOR CR#611 ON 30-MAR-18-------Start-----------
      l_global_attribute20          := NULL;
      IF (L_FILING_MODE              ='PC' AND l_source IN ('IBA-E', 'IBA-P')) THEN
        l_global_attribute20        := 'IBA';
        IF NVL(v_approval_flag, 'X') = 'B' THEN --ADDED FOR CR#611 ON 30-MAR-18
          l_rfnd_stat1              := 'IBA REFD BLOCKED BY AO';
        ELSE
          l_rfnd_stat1 := 'Ready for Refd Banker';
        END IF;
      ELSE
        l_rfnd_stat1         := 'Ready for Refd Banker';
        l_global_attribute20 := NULL;
      END IF;
      l_chr_exe_location := 'RPP_00014_1';
      l_stmt_processing  := 'Inserting into ap_invoices_interface2 ';
      WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
      ---------ADDED FOR CR#611 ON 30-MAR-18-------Start-----------
      -- IF (L_FILING_MODE ='PC' AND L_SOURCE = 'IBA') THEN --added for
      -- hotfix#153321
      --IF (L_FILING_MODE ='PC' AND L_SOURCE LIKE 'IBA%') THEN --added for cr#611 --COMMENTED FOR CR#611 AND ADDED ABOVE ON 30-MAR-18
      -- cr#611
      INSERT
      INTO ap_invoices_interface
        (
          invoice_id,
          invoice_num,
          invoice_type_lookup_code,
          invoice_date,
          invoice_amount,
          invoice_currency_code,
          terms_name,
          gl_date,
          last_update_date,
          last_updated_by,
          last_update_login,
          creation_date,
          created_by,
          source,
          payment_currency_code,
          payment_method_lookup_code,
          payment_cross_rate_date,
          exclusive_payment_flag,
          org_id,
          application_id,
          legal_entity_id,
          vendor_id,
          vendor_site_id,
          attribute3,
          attribute4,
          attribute1,
          attribute7,
          attribute8,
          attribute10,
          ATTRIBUTE14,
          REQUEST_ID ,--To improve Performance 18-Mar-2015
          global_attribute20
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          'STANDARD',
          SYSDATE,
          cur_refd_header_rec.refd_amount,
          'INR',
          'IMMEDIATE',
          SYSDATE,
          SYSDATE,
          g_num_user_id,
          g_num_login_id,
          SYSDATE,
          g_num_user_id,
          'MANUAL INVOICE ENTRY',
          'INR',
          'IT_REFD_PAY_METHOD',
          SYSDATE,
          'N',
          g_num_org_id,
          g_pay_application_id,
          g_legal_entity_id,
          g_vendor_id,
          g_vendor_site_id,
          cur_refd_header_rec.customer_number,
          cur_refd_header_rec.assmt_year,
          cur_refd_header_rec.major_head,
          l_rfnd_stat1,--'Ready for Refd Banker', --added l_rfnd_stat1 as a part of CR#613 on 30-Mar-18,
          cur_refd_header_rec.refd_seq_number,
          cur_refd_header_rec.reference_id,
          CUR_REFD_HEADER_REC.REFD_TYPE,
          p_in_req_id,         --To improve Performance - 18-Mar-2015
          l_global_attribute20 --commented 'IBA' as a part of CR#611 on 30-Mar-18 to remove if-else condition
        );

      --commented as a part of CR#611
      l_chr_exe_location := 'RPP_0015';
      l_stmt_processing  := 'Inserting into ap_invoice_lines_interface ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      INSERT
      INTO ap_invoice_lines_interface
        (
          invoice_id ,
          invoice_line_id ,
          line_number ,
          line_type_lookup_code ,
          amount ,
          dist_code_combination_id ,
          last_updated_by ,
          last_update_date ,
          last_update_login ,
          created_by ,
          creation_date ,
          org_id
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          1,
          'ITEM',
          cur_refd_header_rec.refd_amount,
          g_adjustment_ccid,
          g_num_user_id,
          SYSDATE,
          g_num_login_id,
          g_num_user_id,
          SYSDATE,
          l_orgid
        );
      write_debug ( G_Debug_Flag, 'Calling Import API' ) ;
      l_chr_exe_location := 'RPP_0016';
      l_stmt_processing  := 'Calling package ap_import_invoices_pkg.submit_payment_request ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      AP_IMPORT_INVOICES_PKG.SUBMIT_PAYMENT_REQUEST ( p_api_version => 1.0
      -- , p_api_commit => fnd_api.g_false
      , p_invoice_interface_id => l_invoice_interface_id , p_budget_control => 'N' , p_needs_invoice_approval => 'Y' -- 'N' for testing, 'Y' for
      -- production
      , p_invoice_id => x_invoice_id , x_return_status => x_return_status , x_msg_count => x_msg_count , x_msg_data => x_msg_data , x_rejection_list => l_rejection_list , p_calling_sequence => '.create_refd', p_commit => 'N'--ADDED AS PART OF HOTFIX#144367
      --  ,  p_conc_request_id=> p_in_req_id
      ) ;
      l_chr_exe_location := 'RPP_0017';
      l_stmt_processing  := 'Checking return value of x_return_status ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      IF x_return_status = 'S' THEN
        write_debug ( g_debug_flag, 'Creation of AP invoice number ' || l_invoice_number || ' for amount ' || CUR_REFD_HEADER_REC.REFD_AMOUNT || ' is ' || X_RETURN_STATUS ) ;
      END IF;
      IF x_return_status <> fnd_api.g_ret_sts_success THEN
        FOR i IN l_rejection_list.FIRST .. l_rejection_list.LAST
        LOOP
          write_debug
          (
            g_debug_flag, i || ' Errors found interfacing data to AP ...'
          )
          ;
          p_out_chr_errbuff := p_out_chr_errbuff ||'-' ||l_rejection_list ( i ) .reject_lookup_code;
        END LOOP;
        write_msg ( g_write_logfile, P_OUT_CHR_ERRBUFF ) ;
        RAISE l_exc_exit_error_proc;
      END IF;
    END IF;
    /*Added for CR - 690 on 08-JUN-2018 -- START*/
    --DDT-BBS ABC changes
    IF cur_refd_header_rec.refd_type = 'CROSS HEAD ADJUSTED' THEN
      l_chr_exe_location                := 'RPP_0018';
      L_STMT_PROCESSING                 := ' Requesting for new ap_invoices_interface_s Sequence id';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
	  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing ) ;
      SELECT ap_invoices_interface_s.nextval INTO l_invoice_interface_id FROM dual;
      l_chr_exe_location := 'RPP_0029';
      L_STMT_PROCESSING  := ' Requesting for new ap_invoice_lines_interface_s Sequence id';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT ap_invoice_lines_interface_s.NEXTVAL
      INTO l_invoice_line_interface_id
      FROM dual;
      l_invoice_number   := l_invoice_interface_id;
      l_chr_exe_location := 'RPP_0030';
      l_stmt_processing  := 'Inserting into ap_invoices_interface ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO ap_invoices_interface
        (
          invoice_id,
          invoice_num,
          invoice_type_lookup_code,
          invoice_date,
          invoice_amount,
          invoice_currency_code,
          terms_name,
          gl_date,
          last_update_date,
          last_updated_by,
          last_update_login,
          creation_date,
          created_by,
          source,
          payment_currency_code,
          payment_method_lookup_code,
          payment_cross_rate_date,
          exclusive_payment_flag,
          org_id,
          application_id,
          legal_entity_id,
          vendor_id,
          vendor_site_id,
          attribute3,
          attribute4,
          attribute1,
          attribute7,
          attribute8,
          attribute10,
          ATTRIBUTE14,
          REQUEST_ID --To improve Performance 18-Mar-2015
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          'STANDARD',
          SYSDATE,
          cur_refd_header_rec.refd_amount,
          'INR',
          'IMMEDIATE',
          SYSDATE,
          SYSDATE,
          g_num_user_id,
          g_num_login_id,
          SYSDATE,
          g_num_user_id,
          'MANUAL INVOICE ENTRY',
          'INR',
          'IT_REFD_PAY_METHOD',
          SYSDATE,
          'N',
          g_num_org_id,
          g_pay_application_id,
          g_legal_entity_id,
          g_vendor_id,
          g_vendor_site_id,
          cur_refd_header_rec.customer_number,
          cur_refd_header_rec.assmt_year,
          cur_refd_header_rec.major_head,
          'Ready for Refd Banker',
          cur_refd_header_rec.refd_seq_number,
          cur_refd_header_rec.reference_id,
          CUR_REFD_HEADER_REC.REFD_TYPE,
          p_in_req_id --To improve Performance - 18-Mar-2015
        );
      l_chr_exe_location := 'RPP_0031';
      l_stmt_processing  := 'Inserting into ap_invoice_lines_interface ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing||sql%rowcount ) ;
      INSERT
      INTO ap_invoice_lines_interface
        (
          invoice_id ,
          invoice_line_id ,
          line_number ,
          line_type_lookup_code ,
          amount ,
          dist_code_combination_id ,
          last_updated_by ,
          last_update_date ,
          last_update_login ,
          created_by ,
          creation_date ,
          org_id
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          1,
          'ITEM',
          cur_refd_header_rec.refd_amount,
          g_adjustment_ccid,
          g_num_user_id,
          SYSDATE,
          g_num_login_id,
          g_num_user_id,
          SYSDATE,
          l_orgid
        );
      write_debug ( G_Debug_Flag, 'Calling Import API' ) ;
      l_chr_exe_location := 'RPP_0032';
      l_stmt_processing  := 'Calling package ap_import_invoices_pkg.submit_payment_request ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      AP_IMPORT_INVOICES_PKG.SUBMIT_PAYMENT_REQUEST ( p_api_version => 1.0
      -- , p_api_commit => fnd_api.g_false
      , p_invoice_interface_id => l_invoice_interface_id , p_budget_control => 'N' , p_needs_invoice_approval => 'Y'                                                                                                               -- 'N' for testing, 'Y' for production
      , p_invoice_id => x_invoice_id , x_return_status => x_return_status , x_msg_count => x_msg_count , x_msg_data => x_msg_data , x_rejection_list => l_rejection_list , p_calling_sequence => '.create_refd', p_commit => 'N' --added for HF_184589
      --  ,  p_conc_request_id=> p_in_req_id
      ) ;
      l_chr_exe_location := 'RPP_0033';
      l_stmt_processing  := 'Checking return value of x_return_status ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      IF x_return_status = 'S' THEN
        write_debug ( g_debug_flag, 'Creation of AP invoice number ' || l_invoice_number || ' for amount ' || CUR_REFD_HEADER_REC.REFD_AMOUNT || ' is ' || X_RETURN_STATUS ) ;
		 dbms_output.put_line('Creation of AP invoice number ' || l_invoice_number || ' for amount ' || CUR_REFD_HEADER_REC.REFD_AMOUNT || ' is ' || X_RETURN_STATUS ) ;
      END IF;
      IF x_return_status <> fnd_api.g_ret_sts_success THEN
        FOR i IN l_rejection_list.FIRST .. l_rejection_list.LAST
        LOOP
          write_debug
          (
            g_debug_flag, i || ' Errors found interfacing data to AP ...'
          )
          ;
          p_out_chr_errbuff := p_out_chr_errbuff ||'-' ||l_rejection_list ( i ) .reject_lookup_code;
        END LOOP;
        write_msg ( g_write_logfile, P_OUT_CHR_ERRBUFF ) ;
        RAISE l_exc_exit_error_proc;
      END IF;
    END IF;
    /*Added for CR - 690 on 08-JUN-2018 -- END*/
    --added for CR_661 on 31-Jan-2019--start---
    IF cur_refd_header_rec.refd_type = '115TD CROSSHEAD ADJUSTED' THEN
      l_chr_exe_location                := 'RPP_0034';
      L_STMT_PROCESSING                 := ' Requesting for new ap_invoices_interface_s Sequence id';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      SELECT ap_invoices_interface_s.nextval INTO l_invoice_interface_id FROM dual;
      l_chr_exe_location := 'RPP_0035';
      L_STMT_PROCESSING  := ' Requesting for new ap_invoice_lines_interface_s Sequence id';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      SELECT ap_invoice_lines_interface_s.NEXTVAL
      INTO l_invoice_line_interface_id
      FROM dual;
      l_invoice_number   := l_invoice_interface_id;
      l_chr_exe_location := 'RPP_0036';
      l_stmt_processing  := 'Inserting into ap_invoices_interface ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      INSERT
      INTO ap_invoices_interface
        (
          invoice_id,
          invoice_num,
          invoice_type_lookup_code,
          invoice_date,
          invoice_amount,
          invoice_currency_code,
          terms_name,
          gl_date,
          last_update_date,
          last_updated_by,
          last_update_login,
          creation_date,
          created_by,
          source,
          payment_currency_code,
          payment_method_lookup_code,
          payment_cross_rate_date,
          exclusive_payment_flag,
          org_id,
          application_id,
          legal_entity_id,
          vendor_id,
          vendor_site_id,
          attribute3,
          attribute4,
          attribute1,
          attribute7,
          attribute8,
          attribute10,
          ATTRIBUTE14,
          REQUEST_ID --To improve Performance 18-Mar-2015
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          'STANDARD',
          SYSDATE,
          cur_refd_header_rec.refd_amount,
          'INR',
          'IMMEDIATE',
          SYSDATE,
          SYSDATE,
          g_num_user_id,
          g_num_login_id,
          SYSDATE,
          g_num_user_id,
          'MANUAL INVOICE ENTRY',
          'INR',
          'IT_REFD_PAY_METHOD',
          SYSDATE,
          'N',
          g_num_org_id,
          g_pay_application_id,
          g_legal_entity_id,
          g_vendor_id,
          g_vendor_site_id,
          cur_refd_header_rec.customer_number,
          cur_refd_header_rec.assmt_year,
          cur_refd_header_rec.major_head,
          'Ready for Refd Banker',
          cur_refd_header_rec.refd_seq_number,
          cur_refd_header_rec.reference_id,
          CUR_REFD_HEADER_REC.REFD_TYPE,
          p_in_req_id --To improve Performance - 18-Mar-2015
        );
      l_chr_exe_location := 'RPP_0037';
      l_stmt_processing  := 'Inserting into ap_invoice_lines_interface ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing||sql%rowcount ) ;
      INSERT
      INTO ap_invoice_lines_interface
        (
          invoice_id ,
          invoice_line_id ,
          line_number ,
          line_type_lookup_code ,
          amount ,
          dist_code_combination_id ,
          last_updated_by ,
          last_update_date ,
          last_update_login ,
          created_by ,
          creation_date ,
          org_id
        )
        VALUES
        (
          l_invoice_interface_id,
          l_invoice_line_interface_id,
          1,
          'ITEM',
          cur_refd_header_rec.refd_amount,
          g_adjustment_ccid,
          g_num_user_id,
          SYSDATE,
          g_num_login_id,
          g_num_user_id,
          SYSDATE,
          l_orgid
        );
      write_debug ( G_Debug_Flag, 'Calling Import API' ) ;
      l_chr_exe_location := 'RPP_0038';
      l_stmt_processing  := 'Calling package ap_import_invoices_pkg.submit_payment_request ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      AP_IMPORT_INVOICES_PKG.SUBMIT_PAYMENT_REQUEST ( p_api_version => 1.0
      -- , p_api_commit => fnd_api.g_false
      , p_invoice_interface_id => l_invoice_interface_id , p_budget_control => 'N' , p_needs_invoice_approval => 'Y'                                                                                                               -- 'N' for testing, 'Y' for production
      , p_invoice_id => x_invoice_id , x_return_status => x_return_status , x_msg_count => x_msg_count , x_msg_data => x_msg_data , x_rejection_list => l_rejection_list , p_calling_sequence => '.create_refd', p_commit => 'N' --added for HF_184589
      --  ,  p_conc_request_id=> p_in_req_id
      ) ;
      l_chr_exe_location := 'RPP_0039';
      l_stmt_processing  := 'Checking return value of x_return_status ';
      write_debug ( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing ) ;
      IF x_return_status = 'S' THEN
        write_debug ( g_debug_flag, 'Creation of AP invoice number ' || l_invoice_number || ' for amount ' || CUR_REFD_HEADER_REC.REFD_AMOUNT || ' is ' || X_RETURN_STATUS ) ;
      END IF;
      IF x_return_status <> fnd_api.g_ret_sts_success THEN
        FOR i IN l_rejection_list.FIRST .. l_rejection_list.LAST
        LOOP
          write_debug
          (
            g_debug_flag, i || ' Errors found interfacing data to AP ...'
          )
          ;
          p_out_chr_errbuff := p_out_chr_errbuff ||'-' ||l_rejection_list ( i ) .reject_lookup_code;
        END LOOP;
        write_msg ( g_write_logfile, P_OUT_CHR_ERRBUFF ) ;
        RAISE l_exc_exit_error_proc;
      END IF;
    END IF;
    --added for CR_661 on 31-Jan-2019--end---
    l_num_ref_count                  := l_num_ref_count + 1;
    l_refd_tbl ( l_num_ref_count ) := cur_refd_header_rec.reference_id;
  END LOOP;
  FORALL I IN 1 .. L_NUM_REF_COUNT
  UPDATE xx_refd_headers head
  SET head.refd_status  = DECODE (head.refd_status, 'PAID', 'REFD PROCESSED' , head.refd_status ),
    head.process_flag     = 'Y'
  WHERE head.reference_id = l_refd_tbl (i)
  AND head.refd_status IN ('PAID', 'THRESHOLD LIMIT')
  AND head.process_flag   = 'N';
  write_debug( g_debug_flag, '-------------------------------------------------------------------------------' );
  write_debug( g_debug_flag, '*** Refd Payable Program - ENDS ***' );
  write_debug( g_debug_flag, '-------------------------------------------------------------------------------' );
EXCEPTION
WHEN l_exc_exit_error_proc THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR( p_out_chr_errbuff,1,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  dbms_output.put_line('Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location || p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - ' || l_chr_proc_name );
    END IF;
  END IF;
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
  write_msg( g_write_logfile ,p_out_chr_errbuff );
  Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
  IF l_chr_retcode = g_chr_failure_code THEN
    write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff);
  ELSE
    log_exception ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while writing error data of Procedure - ' || l_chr_proc_name );
    END IF;
  END IF;
END refd_payable;
PROCEDURE irtctrlmaster_proc(
    p_out_chr_errbuff OUT VARCHAR2,
    p_out_chr_retcode OUT VARCHAR2,
    p_in_irt_id  IN VARCHAR2,
    p_in_id_num IN VARCHAR2 )
AS
  /****************************************************************************
  ****************************************
  * Type : Procedure
  * Name : irtctrlmaster_proc
  * Input Parameters : None
  * Output Parameters : p_out_chr_errbuff
  * p_out_chr_retcode
  * Purpose : Procedure to update irtcontrol master
  * Company : Infosys Technologies Ltd.
  * Created By : Infosys
  * Created Date : 23-Jan-2012
  * Last Reviewed By : Infosys
  * Last Reviewed Date : ******************************************************
  **********************************************************
  * Modified Date Modified By Version Modification Type Modification Details
  * ------------- ------------ -------- ----------------- --------------------
  * 23-Jan-2012 Infosys 1.0 O Baseline. ***************************************
  ***************************************************************************/
  -- User defined exception for Commit with Warning
  --
  l_exc_exit_error_proc    EXCEPTION;
  l_out_err_mssg           VARCHAR2 (2000);
  l_chr_proc_name          VARCHAR2(50);
  l_chr_retcode            VARCHAR2(50);
  l_chr_errbuff            VARCHAR2 (2000);
  l_chr_exe_location       VARCHAR2(50) :='';
  l_stmt_processing        VARCHAR2(200);
  l_status                 NUMBER;
  l_num_ref_adj_exists     NUMBER;
  l_num_dmd_exists         NUMBER;
  l_num_ref_exists         NUMBER;
  l_num_ref_hld_exists     NUMBER;
  l_num_ref_adj_hld_exists NUMBER;
  L_NUM_DMD_HLD_EXISTS     NUMBER;
  l_cnt_k                  NUMBER;--- added by kala to debug
  --Cursor Declaration
  -- Cases to Identify NDNR
  CURSOR cur_no_refd_dmd(p_in_id_num IN VARCHAR2)
  IS
    SELECT irt_id
    FROM
      (SELECT rat.interface_header_attribute1 irt_id
      FROM ra_customer_trx_all rat
      WHERE rat.attribute9 = 'PCM CLOSED'
      AND rat.attribute5   = p_in_id_num
    UNION
    SELECT irt_id
    FROM xx_dmd_headers
    WHERE dmd_status                 IN( 'THRESHOLD DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED HOLD')
    AND NVL(avl_Refd_adjust_amount, 0) > 0 -- Added for CR - 690 on 08-JUN-2018 --added for CR_661 on 31-Jan-2019
    AND id_number                       =p_in_id_num
    AND MAJOR_HEAD                      <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    UNION
    SELECT irt_id
    FROM xx_refd_headers
    WHERE refd_status = 'THRESHOLD LIMIT IDENTIFIED'
    AND id_number      =p_in_id_num
      ) x
    WHERE NOT EXISTS
      (SELECT irt_id
      FROM xx_dmd_headers d
      WHERE d.irt_id     = x.irt_id
      AND dmd_status IN( 'DMD IDENTIFIED','FAS DMD HOLD IDENTIFIED')
      AND MAJOR_HEAD    <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      UNION ALL
      SELECT irt_id
      FROM xx_refd_headers r
      WHERE r.irt_id        = x.irt_id
      AND refd_status     = 'TO PAY IDENTIFIED'
      AND net_refd_amount > 100
      );
    -- Refd cases
    CURSOR cur_refd(p_in_irt_id IN VARCHAR2)
    IS
      SELECT DISTINCT irt_id
      FROM xx_refd_headers
      WHERE refd_status   = 'TO PAY IDENTIFIED'
      AND net_refd_amount > 100
      AND id_number        = p_in_id_num ;
    -- Dmd cases
    CURSOR cur_dmd(p_in_irt_id IN VARCHAR2)
    IS
      SELECT DISTINCT irt_id
      FROM xx_dmd_headers
      WHERE DMD_STATUS                IN ('DMD IDENTIFIED', 'FAS DMD HOLD IDENTIFIED')
      AND ID_NUMBER                      = P_IN_ID_NUM
      AND NVL(avl_refd_adjust_amount,0) > 0            -- Added for CR - 690 on 08-JUN-2018 --added for CR_661 on 31-Jan-2019
      AND MAJOR_HEAD                     <> '0032'       --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
      AND IRT_ID                          = p_in_irt_id; --Added as a Part of Hotfix#113275
  BEGIN                                                  -- main program
    p_out_chr_errbuff := ' ';
    p_out_chr_retcode := g_chr_success_code;
    l_chr_proc_name   :='irtctrlmaster_proc';
    write_debug( g_debug_flag , '*** irtctrlmaster_proc : IT control master update Program - STARTS ***' );
	dbms_output.put_line( '*** irtctrlmaster_proc : IT control master update Program - STARTS ***' );
    /****NO REFD NO DMD*****/
    l_chr_exe_location := 'ICMP_0001';
    l_stmt_processing  := 'Fetching cursor1 cur_no_refd_dmd_rec with irt_id ';

	 dbms_output.put_line( 'Fetching cursor1 cur_no_refd_dmd_rec with irt_id ');

    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    FOR cur_no_refd_dmd_rec IN cur_no_refd_dmd(p_in_id_num)
    LOOP --OPEN LOOP1
	dbms_output.put_line( 'Fetching cursor1 cur_no_refd_dmd_rec with irt_id Loop ');
      l_status := NULL;
      BEGIN
        l_chr_exe_location := 'ICMP_0002';
        l_stmt_processing  := 'Checking refd adjustment with NO hold and release flag';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_ref_adj_exists := 0;
        SELECT 1
        INTO l_num_ref_adj_exists
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_refd_headers xrh
          WHERE xrh.irt_id                       = cur_no_refd_dmd_rec.irt_id
          AND (NVL (refd_adjustment_amount, 0) > 0
          OR (NVL(REFD_CROSSADJUST_AMOUNT, 0)  > 0
          AND IRT_SCHEDULE_TYPE                 <> 'FBT')) -- Added for CR# 690 on 08-JUN-2018 --added for CR_661 on 31-Jan-2019
          )
        AND NOT EXISTS
          (SELECT 1
          FROM xx_irt_fas_prcsng_hold xifph
          WHERE xifph.irt_id = cur_no_refd_dmd_rec.irt_id
          AND hold_flag     IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
          AND release_flag  IS NULL
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_num_ref_adj_exists := 0;
        l_chr_exe_location   := 'ICMP_0003';
        l_stmt_processing    := 'No data found in no refd dmd';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      END;
      BEGIN
        l_chr_exe_location := 'ICMP_0005';
        l_stmt_processing  := 'Checking refd adjustment with hold and release flag';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_ref_adj_hld_exists := 0;
        SELECT 1
        INTO l_num_ref_adj_hld_exists
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_refd_headers xrh
          WHERE xrh.irt_id                      = cur_no_refd_dmd_rec.irt_id
          AND NVL (refd_adjustment_amount, 0) > 0
          OR (NVL(REFD_CROSSADJUST_AMOUNT,0)  > 0
          AND IRT_SCHEDULE_TYPE                <> 'FBT') -- added for cr# 690 on 08-JUN-2018 --added for CR_661 on 31-Jan-2019
          )
        AND EXISTS
          (SELECT 1
          FROM xx_irt_fas_prcsng_hold xifph
          WHERE xifph.irt_id = cur_no_refd_dmd_rec.irt_id
          AND hold_flag     IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
          AND release_flag  IS NULL
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_num_ref_adj_hld_exists := 0;
        l_chr_exe_location       := 'ICMP_0006';
        l_stmt_processing        := 'No data found';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      END;
      l_chr_exe_location := 'ICMP_0008';
      l_stmt_processing  := 'Condition to check l_num_ref_adj_exists and finding l_status from PKG_COMMON_APIS_V2.updt_irt_prcs_cntrl_accnt_func' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      WRITE_DEBUG( G_DEBUG_FLAG ,'l_num_ref_adj_exists: '||l_num_ref_adj_exists );
--------------------------------------------------------------------------------------
--Commenting the PCM table status update as it will be taken care by Microservice.
--------------------------------------------------------------------------------------
      IF l_num_ref_adj_exists = 1 THEN
        -- Commented for compiling issue for DB LINK need to revert back
		--Commented for ABC-2.0 Bhagya
       -- L_Status             := PKG_COMMON_APIS_V2.Updt_Irt_Prcs_Cntrl_Accnt_Func ( Cur_No_Refd_Dmd_Rec.Irt_Id, 6, 4, L_Out_Err_Mssg );
	      L_Status  :=0;
        Write_Debug( G_Debug_Flag ,'L_Out_Err_Mssg: '||L_Out_Err_Mssg );
        WRITE_DEBUG( G_DEBUG_FLAG ,'l_status: '||l_status );
        IF l_status          <> 0 THEN
          l_chr_exe_location := 'ICMP_0009';
          l_stmt_processing  := 'Status return is NON ZERO - ERROR';
          p_out_chr_errbuff  := l_out_err_mssg;
          WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| L_STMT_PROCESSING );
		  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
          write_msg( g_write_logfile , 'Error in control master update (IF) no refd/dmd for IRT ID ' || cur_no_refd_dmd_rec.irt_id || l_out_err_mssg);
		  dbms_output.put_line('Error in control master update (IF) no refd/dmd for IRT ID ' || cur_no_refd_dmd_rec.irt_id || l_out_err_mssg);
          RAISE l_exc_exit_error_proc;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: 6,4');
        l_chr_exe_location := 'ICMP_0010';
        l_stmt_processing  := 'Condition to check l_num_ref_adj_hld_exists and finding l_status from PKG_COMMON_APIS_V2.updt_irt_prcs_cntrl_accnt_func' ;
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
      ELSIF l_num_ref_adj_hld_exists = 1 THEN
        -- Commented for compiling issue for DB LINK need to revert back
		--Commented for ABC-2.0 Bhagya
        --L_STATUS             := PKG_COMMON_APIS_V2.UPDT_IRT_PRCS_CNTRL_ACCNT_FUNC ( cur_no_refd_dmd_rec.irt_id, 6, 5, l_out_err_mssg );
		 L_Status  :=0;
         Write_Debug( G_Debug_Flag ,'L_Out_Err_Mssg: '||L_Out_Err_Mssg );
        WRITE_DEBUG( G_DEBUG_FLAG ,'l_status: '||l_status );
        IF l_status          <> 0 THEN
          l_chr_exe_location := 'ICMP_0011';
          l_stmt_processing  := 'Status return is NON ZERO - ERROR';
          p_out_chr_errbuff  := l_out_err_mssg;
          WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| L_STMT_PROCESSING );
		  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
          write_msg( g_write_logfile , 'Error in control master update (IF) no refd/dmd for IRT ID ' || cur_no_refd_dmd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM ) ;
          RAISE l_exc_exit_error_proc;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: 6,5');
      ELSE -- IF l_num_ref_adj_exists = 1 THEN
        -- Commented for compiling issue for DB LINK need to revert back
        Write_Debug( G_Debug_Flag ,'cur_no_refd_dmd_rec.irt_id'||cur_no_refd_dmd_rec.irt_id );
		--Commented for ABC-2.0 Bhagya
        --L_STATUS             := PKG_COMMON_APIS_V2.UPDT_IRT_PRCS_CNTRL_ACCNT_FUNC ( cur_no_refd_dmd_rec.irt_id, 6, 3, l_out_err_mssg );
		 L_Status  :=0;
         Write_Debug( G_Debug_Flag ,'L_Out_Err_Mssg: '||L_Out_Err_Mssg );
		 dbms_output.put_line('L_Out_Err_Mssg: '||L_Out_Err_Mssg );
		 dbms_output.put_line('L_Out_Err_Mssg: '||L_Out_Err_Mssg );
        WRITE_DEBUG( G_DEBUG_FLAG ,'l_status: '||l_status );
        IF l_status          <> 0 THEN
          l_chr_exe_location := 'ICMP_0012';
          L_STMT_PROCESSING  := 'Status return is NON ZERO - ERROR';
          p_out_chr_errbuff  := l_out_err_mssg;
          WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| L_STMT_PROCESSING );
          write_msg( g_write_logfile , 'Error in control master update (IF) no refd/dmd for IRT ID ' || cur_no_refd_dmd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM ) ;
          RAISE l_exc_exit_error_proc;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: 6,3');
      END IF; -- IF l_num_ref_adj_exists = 1 THEN	  
    END LOOP; -- END LOOP1
    l_chr_exe_location := 'ICMP_0013';
    l_stmt_processing  := 'Updating ra_customer_trx_all with attribute9';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
	dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE ra_customer_trx_all
    SET attribute9   = 'CLOSED'
    WHERE attribute9 = 'PCM CLOSED'
    AND attribute5   = p_in_id_num ;
    /**** REFD *****/
    l_chr_exe_location := 'ICMP_0015';
    l_stmt_processing  := 'Fetching cursor2 cur_refd for refd with irt_id';
    WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
    FOR cur_refd_rec IN cur_refd(p_in_irt_id)
    LOOP
      l_status := NULL;
      BEGIN
        l_chr_exe_location := 'ICMP_0016';
        l_stmt_processing  := 'Checking refd headers for NO Hold/Release flag ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_ref_exists := 0;
        SELECT 1
        INTO l_num_ref_exists
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_refd_headers xrh
          WHERE xrh.irt_id = cur_refd_rec.irt_id
          )
        AND NOT EXISTS
          (SELECT 1
          FROM xx_irt_fas_prcsng_hold xifph
          WHERE xifph.irt_id = cur_refd_rec.irt_id
          AND hold_flag     IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
          AND release_flag  IS NULL
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_chr_exe_location := 'ICMP_0017';
        l_stmt_processing  := 'No data found ';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_ref_exists := 0;
      END;
      BEGIN
        l_chr_exe_location := 'ICMP_0019';
        l_stmt_processing  := 'Checking refd headers for Hold/Release flag';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_ref_hld_exists := 0;
        SELECT 1
        INTO l_num_ref_hld_exists
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_refd_headers xrh
          WHERE xrh.irt_id = cur_refd_rec.irt_id
          )
        AND EXISTS
          (SELECT 1
          FROM xx_irt_fas_prcsng_hold xifph
          WHERE xifph.irt_id = cur_refd_rec.irt_id
          AND hold_flag     IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
          AND release_flag  IS NULL
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_chr_exe_location := 'ICMP_0020';
        l_stmt_processing  := 'No data found';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_ref_hld_exists := 0;
      END;
      l_chr_exe_location := 'ICMP_0022';
      l_stmt_processing  := 'checking l_num_ref_exists value';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      IF l_num_ref_exists = 1 THEN
        -- Commented for compiling issue for DB LINK need to revert back
		dbms_output.put_line('cur_refd_rec.irt_id :'||cur_refd_rec.irt_id);
		--Commented for ABC-2.0 Bhagya
       -- L_STATUS    := PKG_COMMON_APIS_V2.UPDT_IRT_PRCS_CNTRL_ACCNT_FUNC ( cur_refd_rec.irt_id, 6, 2, l_out_err_mssg );
	   L_STATUS :=0;
        IF l_status <> 0 THEN
          --- Generating refd_seq_no Sequence no
          l_chr_exe_location := 'ICMP_0022';
          L_STMT_PROCESSING  := 'Status non-zero : Error in control master update (IF) for REFD for IRT ID ' ;
          p_out_chr_errbuff  := l_out_err_mssg;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          write_msg( g_write_logfile , 'Error in control master update (IF) for REFD for IRT ID ' || cur_refd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM );
		  dbms_output.put_line('Error in control master update (IF) for REFD for IRT ID ' || cur_refd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM );
          RAISE l_exc_exit_error_proc;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: 6,2');
      ELSIF l_num_ref_hld_exists =1 THEN
	  --Commented for ABC-2.0 Bhagya
        --l_status                := PKG_COMMON_APIS_V2.updt_irt_prcs_cntrl_accnt_func ( cur_refd_rec.irt_id, 6, 5, l_out_err_mssg );
		L_STATUS :=0;
        IF l_status             <> 0 THEN
          l_chr_exe_location    := 'ICMP_0023';
          L_STMT_PROCESSING     := 'Status non-zero :Error in control master update (IF) for REFD for IRT ID ' ;
          p_out_chr_errbuff     := l_out_err_mssg;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
		  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
          write_msg( g_write_logfile , 'Error in control master update (IF) for REFD for IRT ID ' || cur_refd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM );
          RAISE l_exc_exit_error_proc;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: 6,5 - second');
      END IF;
    END LOOP;
    l_chr_exe_location := 'ICMP_0024';
    l_stmt_processing  := 'Updating xx_refd_headers with refd_status ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_refd_headers
    SET refd_status    = DECODE(refd_status , 'TO PAY IDENTIFIED', 'TO PAY' , 'THRESHOLD LIMIT IDENTIFIED','THRESHOLD LIMIT' ,refd_status )
    WHERE refd_status IN ( 'TO PAY IDENTIFIED','THRESHOLD LIMIT IDENTIFIED')
    AND id_number       = p_in_id_num;
    /*** DMD ***/
    l_chr_exe_location := 'ICMP_0026';
    l_stmt_processing  := 'Fetching cursor3 for DMD';
    WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'||L_STMT_PROCESSING );
    --- below code added by kala to debug
    l_cnt_k:=0;
    SELECT COUNT(1)
    INTO l_cnt_k
    FROM xx_dmd_headers
    WHERE DMD_STATUS IN ('DMD IDENTIFIED', 'FAS DMD HOLD IDENTIFIED')
    AND ID_NUMBER       = P_IN_ID_NUM
    AND IRT_ID           = P_IN_IRT_ID
    AND MAJOR_HEAD      <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    FND_FILE.PUT_LINE (FND_FILE.LOG,'l_cnt_k :'||l_cnt_k);
    FOR I IN
    (SELECT DMD_STATUS,
      customer_Trx_id,
      irt_id
    FROM xx_DMD_HEADERS
    WHERE ID_NUMBER = P_IN_ID_NUM
    AND IRT_ID       = P_IN_IRT_ID
    AND MAJOR_HEAD  <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
    )
    LOOP
      FND_FILE.PUT_LINE (FND_FILE.LOG,'dmd_status:'||I.DMD_STATUS|| 'customer_trx_id is'||I.CUSTOMER_TRX_ID||' irt_id : '||I.IRT_ID);
      FND_FILE.PUT_LINE (FND_FILE.LOG,'p_in_irt_id is :'||P_IN_IRT_ID);
      FND_FILE.PUT_LINE (FND_FILE.LOG,'P_IN_ID_NUM is: '||P_IN_ID_NUM);
    END LOOP;
    --- above code added by kala to debug
    FOR cur_dmd_rec IN cur_dmd(p_in_irt_id)
    LOOP
      l_status := NULL;
      BEGIN
        l_chr_exe_location := 'ICMP_0027';
        l_stmt_processing  := 'Cheching dmd headers non existence for hold/release flag';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_dmd_exists := 0;
        SELECT 1
        INTO l_num_dmd_exists
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_dmd_headers xdh
          WHERE xdh.irt_id = cur_dmd_rec.irt_id
          AND MAJOR_HEAD  <> '0032' --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          )
        AND NOT EXISTS
          (SELECT 1
          FROM xx_irt_fas_prcsng_hold xifph
          WHERE xifph.irt_id = cur_dmd_rec.irt_id
          AND hold_flag     IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
          AND release_flag  IS NULL
          );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_chr_exe_location := 'ICMP_0028';
        l_stmt_processing  := 'No data found';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_dmd_exists := 0;
      END;
      BEGIN
        l_chr_exe_location := 'ICMP_0030';
        l_stmt_processing  := 'Cheching dmd headers existence for hold/release flag';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_dmd_hld_exists := 0;
        SELECT 1
        INTO l_num_dmd_hld_exists
        FROM DUAL
        WHERE EXISTS
          (SELECT 1
          FROM xx_dmd_headers xdh
          WHERE xdh.irt_id     = cur_dmd_rec.irt_id
          AND xdh.MAJOR_HEAD  <> '0032'                      --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
          AND XDH.DMD_STATUS='FAS DMD HOLD IDENTIFIED' -- Added on 21-
            -- May-2012 as per changes in Old 5 to 6 code
          )
          -- The below 4 lines Commented on 21-May-12 as per the changes in old
          -- 5 to 6 code
          /*AND EXISTS
          (SELECT 1
          FROM xx_irt_fas_prcsng_hold xifph
          WHERE xifph.irt_id = cur_dmd_rec.irt_id
          AND hold_flag IN ('IRT REFD HOLD', 'IRT CLAIM HOLD')
          AND release_flag IS NULL
          ) */
          ;
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        l_chr_exe_location := 'ICMP_0031';
        l_stmt_processing  := 'No data found';
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
		dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
        l_num_dmd_hld_exists := 0;
      END;
      l_chr_exe_location := 'ICMP_0033';
      l_stmt_processing  := 'Condition to check l_num_dmd_exists value ';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      IF( l_num_dmd_exists = 1 AND l_num_dmd_hld_exists=0 ) -- Added on 21-May-
        -- 2012 as per changes in Old 5 to 6 code
        THEN
        -- Commented for compiling issue for DB LINK need to revert back
		--Commented for ABC-2.0 Bhagya
        --l_status             := PKG_COMMON_APIS_V2.updt_irt_prcs_cntrl_accnt_func ( cur_dmd_rec.irt_id, 6, 1, l_out_err_mssg );
		L_STATUS :=0;
        IF l_status          <> 0 THEN
          l_chr_exe_location := 'ICMP_0034';
          L_STMT_PROCESSING  := 'Status returned non-zero';
          p_out_chr_errbuff  := l_out_err_mssg;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
          write_msg( g_write_logfile , 'Error in control master update (IF) for DMD for IRT ID ' || cur_dmd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM );
          RAISE l_exc_exit_error_proc;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: 6,1');
      ELSIF l_num_dmd_hld_exists=1 THEN
	  --Commented for ABC-2.0 Bhagya
        --l_status               := PKG_COMMON_APIS_V2.updt_irt_prcs_cntrl_accnt_func ( cur_dmd_rec.irt_id, 6, 5, l_out_err_mssg );
		L_STATUS :=0;
        IF l_status            <> 0 THEN
          l_chr_exe_location   := 'ICMP_0035';
          L_STMT_PROCESSING    := 'Status returned non-zero : hld';
          p_out_chr_errbuff    := l_out_err_mssg;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'|| l_stmt_processing );
		  dbms_output.put_line(l_chr_exe_location ||'-'||l_stmt_processing );
          write_msg( g_write_logfile , 'Error in control master update (IF) for DMD for IRT ID ' || cur_dmd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM );
		  dbms_output.put_line('Error in control master update (IF) for DMD for IRT ID ' || cur_dmd_rec.irt_id || l_out_err_mssg || '-' || SQLERRM );
          RAISE l_exc_exit_error_proc;
        END IF;
        WRITE_DEBUG( G_DEBUG_FLAG ,'Updated: 6,5 - third');
      END IF;
    END LOOP;
    l_chr_exe_location := 'ICMP_0036';
    l_stmt_processing  := 'Updating xx_dmd_headers with dmd_status ';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    UPDATE xx_dmd_headers
    SET dmd_status    = DECODE(dmd_status, 'DMD IDENTIFIED','DMD' , 'THRESHOLD DMD IDENTIFIED', 'THRESHOLD DMD' , 'FAS DMD HOLD IDENTIFIED','FAS DMD HOLD' ,dmd_status)
    WHERE dmd_status IN ( 'DMD IDENTIFIED', 'THRESHOLD DMD IDENTIFIED', 'FAS DMD HOLD IDENTIFIED' )
    AND id_number       = p_in_id_num;
    l_chr_exe_location  := 'ICMP_0040';
    l_stmt_processing   := 'p_out_chr_retcode = g_chr_success_code';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    write_debug( g_debug_flag , '*** IT control master update Program - ENDS ***' );
    write_debug( g_debug_flag , '-------------------------------------------------------------------------------' );
  EXCEPTION
  WHEN l_exc_exit_error_proc THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || L_STMT_PROCESSING ||'-' ||SUBSTR( p_out_chr_errbuff,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
	dbms_output.put_line('Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || L_STMT_PROCESSING ||'-' ||SUBSTR( p_out_chr_errbuff,1,255));
    l_stmt_processing := p_out_chr_errbuff;
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF L_CHR_RETCODE = G_CHR_FAILURE_CODE THEN
      Write_Msg( G_Write_Logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff , p_out_chr_retcode => l_chr_retcode , p_in_err_desc => p_out_chr_errbuff , p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name , p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL , p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id , p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff) ;
      END IF;
    END IF;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || L_CHR_PROC_NAME ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255) ;
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    l_stmt_processing := p_out_chr_errbuff;
    Backup_data ( p_out_chr_errbuff => l_chr_errbuff ,p_out_chr_retcode => l_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_chr_errbuff) ;
    ELSE
      log_exception ( p_out_chr_errbuff => l_chr_errbuff , p_out_chr_retcode => l_chr_retcode , p_in_err_desc => p_out_chr_errbuff , p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name , p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL , p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id , p_in_login_id => g_num_login_id );
      IF l_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_errbuff) ;
      END IF;
    END IF;
  END irtctrlmaster_proc;
  ---******************** End of Procedure / Function *****************
  ------------------
  PROCEDURE xx_DQ_WRAPPER_PROC(
      P_OUT_CHR_ERRBUFF OUT VARCHAR2 ,
      P_OUT_CHR_RETCODE OUT VARCHAR2,
      P_IN_IRT_ID IN VARCHAR2 )
  AS
    /****************************************************************************
    ****************************************
    * Type : Procedure
    * Name : xx_DQ_WRAPPER_PROC
    * Input Parameters : p_in_irt_id
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * Input Parameters :
    * Purpose : Procedure to Carry out Data quality check on Accounting.
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 20-APRIL-2012
    * Last Reviewed By :
    * Last Reviewed Date : ******************************************************
    ***************************************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    ----------------- ----------------------
    * 20-APRIL-2012 Infosys 1.0 Baseline.
    *****************************************************************************
    ****************************************/
    --
    L_CHR_PROC_NAME       VARCHAR2(50) :='xx_DQ_WRAPPER_PROC';
    L_PROC_NAME           VARCHAR2(1000);
    L_CHR_EXE_LOCATION    VARCHAR2(50) :='';
    L_STMT_PROCESSING     VARCHAR2(2000);
    L_id_number              VARCHAR2(50) :='';
    L_IRT_AY              VARCHAR2(50) :='';
    L_IRT_TYPE            VARCHAR2(50) :='';
    L_TS_CNT             NUMBER       :=0;
    p_out_chr_errbuffER   VARCHAR2(2000);
    P_OUT_CHR_RETCD       VARCHAR2(150 byte) :=0;
    l_exc_exit_error_proc EXCEPTION;
  BEGIN
    SELECT "id_number",
      "assessment_year",
      "form_type_code"
      /* CHANGED FROM PROCESS_STATUS_CODE TO form_type_code ON 10 OCT 2012*/
    INTO L_id_number,
      L_IRT_AY,
      L_IRT_TYPE
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id" =P_IN_IRT_ID;
    write_msg( g_write_logfile , ' ID NO. ' || L_id_number );
    write_msg( g_write_logfile , ' IRT AY. ' || L_IRT_AY );
    FOR DQ_PROCS IN
    (SELECT SP_NAME
    FROM xxcus.xx_IRT_ACCNT_CONFIG
    WHERE ACTIVE_FLAG='Y'
    ORDER BY CRITICALITY
    )
    LOOP
      L_PROC_NAME :=NULL;
      L_PROC_NAME :=DQ_PROCS.SP_NAME;
      write_msg( g_write_logfile , ' Procedure Name ' || L_PROC_NAME );
      EXECUTE IMMEDIATE 'BEGIN '||L_PROC_NAME||'(:2,:3,:4,:5,:6,:7); END;' USING OUT p_out_chr_errbuffer,
      OUT P_OUT_CHR_RETCD,
      IN P_IN_IRT_ID,
      IN L_IRT_TYPE,
      IN L_IRT_AY,
      IN L_id_number;
      write_msg( g_write_logfile , ' p_out_chr_retcd ' || P_OUT_CHR_RETCD );
      write_msg( g_write_logfile , ' p_out_chr_errbuffer ' || p_out_chr_errbuffer );
      /* L_PROC_NAME :=DQ_PROCS.SP_NAME||'(p_out_chr_errbuffER,P_OUT_CHR_RETCODE,
      P_IN_IRT_ID,L_IRT_TYPE,L_IRT_AY,L_id_number)';
      EXECUTE IMMEDIATE 'L_PROC_NAME';*/
      IF P_OUT_CHR_RETCD IN('1','2') THEN
        write_msg( g_write_logfile , ' G_CHR_FAILURE_CODE ' || G_CHR_FAILURE_CODE );
        P_OUT_CHR_ERRBUFF :=p_out_chr_errbuffer;
        raise l_exc_exit_error_proc;
      END IF;
    END LOOP;
    l_stmt_processing  :=p_out_chr_errbuffer;
    l_chr_exe_location := 'XDWP_0007';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    write_debug( g_debug_flag , '*** DATA QUALITY WRAPPER Program - ENDS ***' );
    write_debug( g_debug_flag , '-------------------------------------------------------------------------------' );
  EXCEPTION
  WHEN l_exc_exit_error_proc THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'USER Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || L_STMT_PROCESSING ||'-' ||SUBSTR( p_out_chr_errbuffer,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    l_stmt_processing := p_out_chr_errbuff;
    Backup_data ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF p_out_chr_retcode = G_CHR_FAILURE_CODE THEN
      Write_Msg( G_Write_Logfile , ' Error also while Backup of error data of Procedure - '|| p_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode , p_in_err_desc => p_out_chr_errbuffer , p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name , p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL , p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id , p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| p_out_chr_errbuff);
      END IF;
    END IF;
    P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
    P_OUT_CHR_ERRBUFF := p_out_chr_errbuffer;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || L_CHR_PROC_NAME ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    l_stmt_processing := p_out_chr_errbuff;
    P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
    Backup_data ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF p_out_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| p_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode , p_in_err_desc => p_out_chr_errbuff , p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name , p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL , p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id , p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| p_out_chr_errbuff);
      END IF;
    END IF;
  END xx_DQ_WRAPPER_PROC;
  PROCEDURE xx_DQ_WRAPPER_PROC_NEW(
      P_OUT_CHR_ERRBUFF OUT VARCHAR2 ,
      P_OUT_CHR_RETCODE OUT VARCHAR2,
      P_IN_IRT_ID IN VARCHAR2 )
  AS
    /****************************************************************************
    ****************************************
    * Type : Procedure
    * Name : xx_DQ_WRAPPER_PROC
    * Input Parameters : p_in_irt_id
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * Input Parameters :
    * Purpose : Procedure to Carry out Data quality check on Accounting.
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 20-APRIL-2012
    * Last Reviewed By :
    * Last Reviewed Date : ******************************************************
    ***************************************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    ----------------- ----------------------
    * 20-APRIL-2012 Infosys 1.0 Baseline.
    *****************************************************************************
    ****************************************/
    --
    L_CHR_PROC_NAME       VARCHAR2(50) :='xx_DQ_WRAPPER_PROC_NEW';
    L_PROC_NAME           VARCHAR2(1000);
    L_CHR_EXE_LOCATION    VARCHAR2(50) :='';
    L_STMT_PROCESSING     VARCHAR2(200);
    L_id_number              VARCHAR2(50) :='';
    L_IRT_AY              VARCHAR2(50) :='';
    L_IRT_TYPE            VARCHAR2(50) :='';
    L_TS_CNT             NUMBER       :=0;
    p_out_chr_errbuffER   VARCHAR2(1000);
    P_OUT_CHR_RETCD       VARCHAR2(150 byte) :=0;
    l_exc_exit_error_proc EXCEPTION;
  BEGIN
    SELECT "id_number",
      "assessment_year",
      "form_type_code"
      /* CHANGED FROM PROCESS_STATUS_CODE TO form_type_code ON 10 OCT 2012*/
    INTO L_id_number,
      L_IRT_AY,
      L_IRT_TYPE
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id" =P_IN_IRT_ID;
    write_msg( g_write_logfile , ' ID NO. ' || L_id_number );
    write_msg( g_write_logfile , ' IRT AY. ' || L_IRT_AY );
    FOR DQ_PROCS IN
    (SELECT SP_NAME
    FROM xxcus.xx_IRT_ACCNT_CONFIG_NEW
    WHERE ACTIVE_FLAG='Y'
    ORDER BY CRITICALITY
    )
    LOOP
      L_PROC_NAME :=NULL;
      L_PROC_NAME :=DQ_PROCS.SP_NAME;
      write_msg( g_write_logfile , ' Procedure Name ' || L_PROC_NAME );
      EXECUTE IMMEDIATE 'BEGIN '||L_PROC_NAME||'(:2,:3,:4,:5,:6,:7); END;' USING OUT p_out_chr_errbuffer,
      OUT P_OUT_CHR_RETCD,
      IN P_IN_IRT_ID,
      IN L_IRT_TYPE,
      IN L_IRT_AY,
      IN L_id_number;
      write_msg( g_write_logfile , ' p_out_chr_retcd ' || P_OUT_CHR_RETCD );
      write_msg( g_write_logfile , ' p_out_chr_errbuffer ' || p_out_chr_errbuffer );
      /* L_PROC_NAME :=DQ_PROCS.SP_NAME||'(p_out_chr_errbuffER,P_OUT_CHR_RETCODE,
      P_IN_IRT_ID,L_IRT_TYPE,L_IRT_AY,L_id_number)';
      EXECUTE IMMEDIATE 'L_PROC_NAME';*/
      IF P_OUT_CHR_RETCD IN('1','2') THEN
        write_msg( g_write_logfile , ' G_CHR_FAILURE_CODE ' || G_CHR_FAILURE_CODE );
        P_OUT_CHR_ERRBUFF :=p_out_chr_errbuffer;
        raise l_exc_exit_error_proc;
      END IF;
    END LOOP;
    l_stmt_processing  :=p_out_chr_errbuffer;
    l_chr_exe_location := 'XDWP_0007';
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    write_debug( g_debug_flag , '*** DATA QUALITY WRAPPER NEW Program - ENDS ***' );
    write_debug( g_debug_flag , '-------------------------------------------------------------------------------' );
  EXCEPTION
  WHEN l_exc_exit_error_proc THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'USER Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || L_STMT_PROCESSING ||'-' ||SUBSTR( p_out_chr_errbuffer,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    l_stmt_processing := p_out_chr_errbuff;
    Backup_data ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF p_out_chr_retcode = G_CHR_FAILURE_CODE THEN
      Write_Msg( G_Write_Logfile , ' Error also while Backup of error data of Procedure - '|| p_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode , p_in_err_desc => p_out_chr_errbuffer , p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name , p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL , p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id , p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| p_out_chr_errbuff);
      END IF;
    END IF;
    P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
    P_OUT_CHR_ERRBUFF := p_out_chr_errbuffer;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || L_CHR_PROC_NAME ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    l_stmt_processing := p_out_chr_errbuff;
    P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
    Backup_data ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF p_out_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| p_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode , p_in_err_desc => p_out_chr_errbuff , p_in_err_code => l_chr_exe_location , p_in_err_loc => l_chr_proc_name , p_in_irt_id => p_in_irt_id , p_in_cust_trx_id => NULL , p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id , p_in_login_id => g_num_login_id );
      IF p_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| p_out_chr_errbuff);
      END IF;
    END IF;
  END xx_DQ_WRAPPER_PROC_NEW;
/************** Start of proc for the Refd 400 to Open dmd Check**********
*******/
  PROCEDURE refd400_dmd_chk(
      p_out_chr_errbuff OUT VARCHAR2,
      p_out_chr_retcode OUT VARCHAR2,
      p_in_id_number IN VARCHAR2,
      p_in_irt_id     IN VARCHAR2 )
  AS
    CURSOR Refd_400_data(p_in_irt VARCHAR2)
    IS
      SELECT DISTINCT IRT_ID
      FROM xx_REFD_HEADERS
      WHERE IRT_ID         =p_in_irt
      AND TOTAL_400_REF_AMT>0;
    l_exc_exit_error_proc EXCEPTION;
    l_out_err_mssg        VARCHAR2 (2000);
    l_chr_proc_name       VARCHAR2(50);
    l_chr_retcode         VARCHAR2(50);
    l_chr_errbuff         VARCHAR2 (2000);
    l_chr_exe_location    VARCHAR2(50) :='';
    l_stmt_processing     VARCHAR2(200);
    g_exec_location       NUMBER;
    p_out_chr_errbuffER   VARCHAR2(1000);
    P_OUT_CHR_RETCD       VARCHAR2(150 byte) :=0;
    l_out_chr_retcode     VARCHAR2(150 byte) :=0;
    l_out_chr_errbuff     VARCHAR2(1000);
    p_out_ro_status       NUMBER;              --added for CR_HWSW_0226
    v_irt_ay xx_REFD_HEADERS.irt_ay%TYPE; --added for CR_HWSW_0226
    P_SKIP_RO_STATUS  NUMBER;                   --added for cr 602
    p_relaxation_flag NUMBER;                   --added for HF_175742 on 11-Apr-2018
  BEGIN
    FOR Refd_400_chk IN Refd_400_data(P_IN_IRT_ID)
    LOOP
      l_chr_exe_location := '400Ref_Adj';
      l_stmt_processing  :=' Calling RefAdj From 400 Ref';
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      --update to status where it can be processed for refd adj.
      UPDATE xx_REFD_HEADERS
      SET refd_status ='PCM APPROVED',
        -- total_refd_amount= NVL(total_refd_amount,0) + total_400_ref_amt,
        -- commented for CR_HWSW_102
        net_refd_amount = NVL(net_refd_amount,0) -NVL(total_400_ref_amt,0) --
        -- NVL added for hotfix# 26427
      WHERE irt_id =refd_400_chk.irt_id;
      BEGIN
        SELECT IRT_AY
        INTO v_irt_ay
        FROM xx_refd_headers
        WHERE irt_id = refd_400_chk.irt_id
        AND Rownum   =1;
        /* Added line for hot fix #38385 */
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag ,'error: '||sqlerrm );
      END;
      p_out_ro_status := 0;
      ro_skip_check_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_skip_ro_status => p_skip_ro_status, p_relaxation_flag => p_relaxation_flag,p_in_id_number => p_in_id_number, p_in_irt_id => p_in_irt_id, p_in_irt_ay => v_irt_ay );--Added for HF_176638 on 11-Apr-2018
      --ro_skip_check_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_skip_ro_status => p_skip_ro_status, p_in_id_number => p_in_id_number, p_in_irt_id => p_in_irt_id, p_in_irt_ay => v_irt_ay ); --commented for HF_176638 on 11-Apr-2018
      -- ro_status_check_proc ( p_out_chr_errbuff => p_out_chr_errbuff,
      -- p_out_chr_retcode => p_out_chr_retcode, p_out_ro_status =>
      -- p_out_ro_status, p_in_id_number => p_in_id_number, p_in_irt_id =>
      -- p_in_irt_id, P_IN_IRT_AY => v_irt_ay);
      --changes done for cr 602
      IF p_out_chr_retcode  = g_chr_failure_code THEN
        g_exec_location    := 1029;
        l_chr_exe_location := 'ref400_01';
        l_stmt_processing  := ' Call to ro_status_check_proc failed from refd400_dmd_chk';
        RAISE l_exc_exit_error_proc;
      END IF;
      write_debug( g_debug_flag ,'p_out_ro_status from refd400_dmd_chk: '|| p_out_ro_status );
      IF p_out_ro_status <> 2 THEN
        write_debug( g_debug_flag ,' Calling Refd Adj for Refd out of 400 ' ) ;
        --calling RefAdj API to adjust refd out of 400 for dmd.
        refd_adjust_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_number => p_in_id_number, p_in_irt_id => p_in_irt_id );
        IF p_out_chr_retcode= g_chr_failure_code THEN
          g_exec_location  := 1030;
          --p_out_chr_retcode := g_chr_failure_code;
          -- p_out_chr_errbuff := p_out_chr_errbuff;
          l_chr_exe_location := '400RefAdj_01';
          l_stmt_processing  :=' Call to RefAdj Failed from 400 ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          write_debug( g_debug_flag ,p_out_chr_errbuff);
          RAISE l_exc_exit_error_proc;
        END IF;
        write_debug( g_debug_flag ,' Calling Dmd Interest Calc from 400 ' );
        --calling Dmd Interest Invoice Creation.
        dmd_intinv ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => p_in_id_number, p_in_irt_id => p_in_irt_id );
        IF p_out_chr_retcode= g_chr_failure_code THEN
          g_exec_location  := 1031;
          -- p_out_chr_retcode := g_chr_failure_code;
          -- p_out_chr_errbuff := l_chr_ood_errbuff;
          l_chr_exe_location := '400DmdInt_01';
          l_stmt_processing  :=' Call to Dmd Interest ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          write_debug( g_debug_flag ,p_out_chr_errbuff);
          RAISE l_exc_exit_error_proc;
        END IF;
        intdmd_refnd_adj_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => p_in_id_number, p_in_irt_id => p_in_irt_id );
        IF p_out_chr_retcode= g_chr_failure_code THEN
          g_exec_location  := 1032;
          -- p_out_chr_retcode := g_chr_failure_code;
          -- p_out_chr_errbuff := l_chr_ood_errbuff;
          l_chr_exe_location := '400DmdInt_02';
          l_stmt_processing  :=' Call to Dmd Interest Invoice ';
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          write_debug( g_debug_flag ,p_out_chr_errbuff);
          RAISE l_exc_exit_error_proc;
        END IF;
      END IF;
    END LOOP;
    --Update the Status to its Final
    BEGIN
      UPDATE xx_refd_headers
      SET refd_status = (
        CASE
          WHEN NVL (net_refd_amount, 0) = 0
          THEN 'APPROVED'
          WHEN NVL (net_refd_amount, 0) <= 100
          THEN 'THRESHOLD LIMIT IDENTIFIED'
          WHEN NVL (net_refd_amount, 0) > 100
          THEN 'TO PAY IDENTIFIED'
        END )
      WHERE refd_status = 'PCM APPROVED'
        --AND request_id = g_num_request_id
      AND irt_id = p_in_irt_id;
    EXCEPTION
    WHEN OTHERS THEN
      p_out_chr_retcode := g_chr_failure_code;
      p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255) ;
      write_msg( g_write_logfile ,p_out_chr_errbuff );
      Backup_data ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
      IF l_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_out_chr_errbuff);
      ELSE
        log_exception ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
        IF l_out_chr_retcode = g_chr_failure_code THEN
          write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name);
        END IF;
      END IF;
    END;
  EXCEPTION
  WHEN l_exc_exit_error_proc THEN
    p_out_chr_retcode := g_chr_failure_code;
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := 'Error in procedure ' || l_chr_proc_name ||'-' || l_chr_exe_location ||'-' || l_stmt_processing ||'-' ||SUBSTR(sqlerrm,1,255);
    write_msg( g_write_logfile ,p_out_chr_errbuff );
    Backup_data ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_irt_id => p_in_irt_id );
    IF l_out_chr_retcode = g_chr_failure_code THEN
      write_msg( g_write_logfile , ' Error also while Backup of error data of Procedure - '|| l_out_chr_errbuff);
    ELSE
      log_exception ( p_out_chr_errbuff => l_out_chr_errbuff ,p_out_chr_retcode => l_out_chr_retcode ,p_in_err_desc => p_out_chr_errbuff ,p_in_err_code => l_chr_exe_location ,p_in_err_loc => l_chr_proc_name ,p_in_irt_id => p_in_irt_id ,p_in_cust_trx_id => NULL ,p_in_refd_ref_id => NULL , p_in_request_id => g_num_request_id ,p_in_login_id => g_num_login_id );
      IF l_out_chr_retcode = g_chr_failure_code THEN
        write_msg( g_write_logfile , ' Error also while writing error data of Procedure - '|| l_chr_proc_name) ;
      END IF;
    END IF;
  END;
/************** End of proc for the Refd 400 to Open dmd Check************
*****/
---******************** End of Procedure / Function *****************
------------------
---********Start of procedure for Addition to collection report for dmd data
-- - CR_HWSW_0584********---
  PROCEDURE DMD_COLL_REP_PROC(
      P_OUT_CHR_ERRBUFF OUT VARCHAR2 ,
      P_OUT_CHR_RETCODE OUT VARCHAR2,
      P_IN_ID_NUM IN VARCHAR2 )
  AS
    /****************************************************************************
    ****************************************
    * Type : Procedure
    * Name : DMD_COLL_REP_PROC
    * Input Parameters : P_IN_ID_NUM
    * Output Parameters : p_out_chr_errbuff
    * p_out_chr_retcode
    * Purpose : Procedure to populate data for Addition to collection report for
    dmd data.
    * Company : Infosys Limited.
    * Created By : Infosys
    * Created Date : 05-DEC-2016
    * Last Reviewed By :
    * Last Reviewed Date : ******************************************************
    ***************************************************************
    * Modified Date Modified By Version Reviewed By Reviewed Date Modification
    Type Modification Details
    * ------------- ------------ -------- --------------- --------------
    ----------------- ----------------------
    * 05-DEC-2016  Infosys 1.0 Baseline.
    *    13-APR-2017     Infosys 1.1 Applied Amount populated as part of Hotfix
    151218
    *****************************************************************************
    ****************************************/
    L_CHR_PROC_NAME       VARCHAR2(50) :='DMD_COLL_REP_PROC';
    L_PROC_NAME           VARCHAR2(1000);
    L_CHR_EXE_LOCATION    VARCHAR2(50) :='';
    L_STMT_PROCESSING     VARCHAR2(200);
    L_id_number              VARCHAR2(50) :='';
    L_OUTST_DEM_AMT       NUMBER       := 0;
    p_out_chr_errbuffer   VARCHAR2(1000);
    P_OUT_CHR_RETCD       VARCHAR2(150 byte) :=0;
    l_exc_exit_error_proc EXCEPTION;
    L_INT_CALC_MNTH       DATE;
    l_int_period          NUMBER := 0;
    l_notice_date         DATE;
    l_diff_amt            NUMBER := 0; --Added for Hotfix 151218
    l_amt_applied         NUMBER := 0; --Added for Hotfix 151218
    CURSOR C_GET_DEM_DET(P_IN_ID_NUM IN VARCHAR2)
    IS
      SELECT ID_NUMBER ,
        irt_ay ,
        dmd_identification_number ,
        dmd_original_amount ,
        avl_refd_adjust_amount ,
        dmd_interest_amount ,
        dmd_identified_date ,
        sec_code ,
        dmd_status ,
        dmd_service_date ,
        irt_id ,
        customer_trx_id ,
        last_update_date
      FROM xx_DMD_HEADERS
      WHERE ID_NUMBER   = P_IN_ID_NUM
      AND dmd_status IN ('DMD','INT DMD')
      AND MAJOR_HEAD    <> '0032'; --Hotfix_170006 Added on 1-Jan-2018 to skip WTR_ID
  BEGIN
    L_CHR_EXE_LOCATION := 'XDC_001';
    L_STMT_PROCESSING  := 'Entering DMD_COLL_REP_PROC ' ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
    write_debug( g_debug_flag , '-----------------------------------------------------------------------');
    write_debug( g_debug_flag , '*** Addition to collection report for dmd data - STARTS ***');
    write_debug( g_debug_flag , '-----------------------------------------------------------------------');
    FOR c_rec IN c_get_dem_det(P_IN_ID_NUM)
    LOOP
      L_CHR_EXE_LOCATION := 'XDC_002';
      L_STMT_PROCESSING  := 'Entering FOR LOOP ' ;
      write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
      BEGIN
        BEGIN
          SELECT NVL(outstanding_dem_amt,0)
          INTO L_OUTST_DEM_AMT
          FROM xxcus.xx_DEM_COLL_REP_GTT
          WHERE din       = c_rec.dmd_identification_number
          AND id_number  = P_IN_ID_NUM
          AND cust_trx_id = c_rec.customer_trx_id;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          --p_out_chr_retcode := 1;
          L_OUTST_DEM_AMT   := 0;
          p_out_chr_errbuff := 'No Data Found for Outstanding Dmd Amount';
          write_debug( g_debug_flag , 'No Data Found for Outstanding Dmd Amount for ID: '||P_IN_ID_NUM|| ' DIN: '|| c_rec.dmd_identification_number);
        WHEN OTHERS THEN
          L_OUTST_DEM_AMT   := 0;
          p_out_chr_retcode := 1;
          p_out_chr_errbuff := SQLERRM ;
          write_debug( g_debug_flag , 'Some error occurred. Select failed for Outstanding Dmd for ID: ' ||P_IN_ID_NUM|| ' DIN: '|| c_rec.dmd_identification_number|| ' Error: '||SQLERRM );
        END;
        l_diff_amt           := L_OUTST_DEM_AMT - c_rec.avl_refd_adjust_amount;
        IF l_diff_amt        <> 0 THEN
          L_CHR_EXE_LOCATION := 'XDC_003';
          L_STMT_PROCESSING  := 'Entering IF Condition ' ;
          write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
          BEGIN
            SELECT TRUNC(MIN(inu.NOTICE_DATE))
            INTO l_notice_date
            FROM xxcus.irt_notice_us_245 inu
            WHERE din       = C_REC.dmd_identification_number
            AND etl_rd_flag = 'Y';
          EXCEPTION
          WHEN NO_DATA_FOUND THEN
            --p_out_chr_retcode := 1;
            p_out_chr_errbuff := 'No Data Found for 245 Notice date';
            write_debug( g_debug_flag , 'No Data Found for 245 Notice date for ID: '||P_IN_ID_NUM);
            l_notice_date := NULL;
          WHEN OTHERS THEN
            --p_out_chr_retcode := 1;
            p_out_chr_errbuff := SQLERRM ;
            write_debug( g_debug_flag , 'Some error occurred. Select failed for 245 Notice date for ID: ' ||P_IN_ID_NUM||' Error: '||SQLERRM );
          END;
          ----------Below IF Block Added for Hotfix 151218-------
          IF l_diff_amt    > 0 THEN
            l_amt_applied := l_diff_amt;
          ELSE
            l_amt_applied := 0;
          END IF;
          INSERT
          INTO xxcus.xx_DEM_COLL_REP_DATA
            (
              id_number ,
              ay ,
              din ,
              orig_dem_amt ,
              outstanding_dem_amt ,
              dem_interest_amt ,
              dem_created_date ,
              sec_code ,
              dem_status ,
              dem_uploaded_by ,
              dem_service_date ,
              last_update_date ,
              irt_id ,
              cust_trx_id ,
              SENT_DATE_245_NOTICE ,
              applied_amount --Added for Hotfix 151218
            )
            VALUES
            (
              C_REC.ID_NUMBER ,
              c_rec.irt_ay ,
              c_rec.dmd_identification_number ,
              c_rec.dmd_original_amount ,
              c_rec.avl_refd_adjust_amount ,
              c_rec.dmd_interest_amount ,
              c_rec.dmd_identified_date ,
              c_rec.sec_code ,
              c_rec.dmd_status ,
              DECODE( SUBSTR( c_rec.dmd_identification_number,9,2) ,10,'AST' , 37,'ABC' ,51,'DCR' ,40,'PENALTY' ) ,
              c_rec.dmd_service_date ,
              c_rec.last_update_date ,
              c_rec.irt_id ,
              c_rec.customer_trx_id ,
              l_notice_date ,
              l_amt_applied --Added for Hotfix 151218
            );
          --changes for dmd headers flag starts
          BEGIN
            UPDATE xx_dmd_headers
            SET attribute12                 ='N' --CR 590 changes
            WHERE ID_NUMBER                = C_REC.ID_NUMBER
            AND dmd_identification_number=c_rec.dmd_identification_number
            AND dmd_status              IN ('DMD','INT DMD', 'THRESHOLD DMD'); --CR 590 changes
          EXCEPTION
          WHEN OTHERS THEN
            fnd_file.put_line ( fnd_file.LOG, 'errored while updating attribute12 flag in dmd headers' || sql%rowcount ) ;
            P_OUT_CHR_ERRBUFF := P_OUT_CHR_ERRBUFF || 'Error in updation of xx_dmd_headers' || SQLERRM;
          END;
          --changes for dmd headers flag ends
        END IF; --IF c_rec.avl_refd_adjust_amount <> L_OUTST_DEM_AMT
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
        p_out_chr_retcode := 1;
        p_out_chr_errbuff := 'No Data Found. Insert in xx_DEM_COLL_REP_DATA failed';
        write_debug( g_debug_flag ,'Insert failed for ID: '||P_IN_ID_NUM|| ' DIN: '|| c_rec.dmd_identification_number);
      WHEN OTHERS THEN
        p_out_chr_retcode := 1;
        p_out_chr_errbuff := SQLERRM ;
        write_debug( g_debug_flag ,'Some error occurred. Insert failed for ID: ' ||P_IN_ID_NUM|| ' DIN: '|| c_rec.dmd_identification_number|| ' Error: '||SQLERRM);
      END;
    END LOOP;
    L_CHR_EXE_LOCATION := 'XDC_004';
    L_STMT_PROCESSING  := 'Outside FOR LOOP ' ;
    write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  EXCEPTION
  WHEN OTHERS THEN
    p_out_chr_retcode := g_chr_failure_code;
    p_out_chr_errbuff := SQLERRM ;
    write_debug( g_debug_flag ,'Some error occurred in outermost loop. '||SQLERRM );
  END DMD_COLL_REP_PROC;
---******************** End of Procedure DMD_COLL_REP_PROC - CR_HWSW_0584 **
-- ***************------
  PROCEDURE wrapper_api(
      p_out_chr_errbuff OUT NOCOPY VARCHAR2 ,
      P_OUT_CHR_RETCODE OUT NOCOPY VARCHAR2 ,
      p_in_request_id IN OUT NUMBER ,
      p_in_irt_id     IN VARCHAR2 )
  AS
    /****************************************************************************
    ***********
    * Type : Procedure
    * Name : wrapper_API
    * Input Parameters : p_in_irt_id, p_in_request_id
    * Output Parameters : out_chr_errbuff
    * out_chr_retcode
    * Purpose : Wrapper API which the master program calls to process the IRT's
    *
    * Company : Infosys Technologies Ltd.
    * Created By : Infosys
    * Created Date : 19-Dec-2011
    * Last Reviewed By : Infosys
    * Last Reviewed Date :
    *****************************************************************************
    ***********
    * Modified Date Modified By Version Modification Type Modification Details *
    * ------------- ------------ -------- - -----------------
    -------------------------- *
    * 19-Dec-2011 Infosys 1.0 O Baseline. *
    *****************************************************************************
    ***********/
    l_stmt_processing   VARCHAR2(200);
    l_batch_size        NUMBER := FND_PROFILE.VALUE('xx_IRT_ACCT_BATCH_SIZE');
    l_irt_process_cnt   NUMBER := 0;
    l_irt_failure_cnt   NUMBER := 0;
    l_commit_int_cnt    NUMBER := NVL(FND_PROFILE.VALUE( 'xx_IRT_ACCT_COMMIT_INTERVAL'),1);
    l_commit_rec_cnt    NUMBER := 0;
    l_commit_freq       NUMBER := NVL(FND_PROFILE.VALUE( 'xx_IRT_ACCT_COMMIT_FREQUENCY'),1);
    l_prev_commit_time  NUMBER := 0;
    l_application_id    NUMBER;
    l_resp_id           NUMBER;
    l_parent_request_id NUMBER;
    l_chr_proc_name     VARCHAR2(50) :='wrapper_API';
    l_chr_exe_location  VARCHAR2(50) :='';
    l_strt_time         DATE         := SYSTIMESTAMP;
    l_end_time          DATE ;
    L_IBA_FLAG         VARCHAR2(1);--added for 611
    -- v_400_cnt_chk NUMBER; --400 commented 8 JAN13
    l_chk_revised       NUMBER; --added for check for latest revised
    l_cnt               NUMBER := 0;
    p_out_ro_status     NUMBER; --added for CR_HWSW_0226
    p_skip_ro_status    NUMBER; --cr 602
    P_RELAXATION_FLAG   NUMBER; --added for HF_175742 on 11-Apr-2018
    p_skip_ro_status_1  NUMBER; --added for HF_176638 on 16-May-2018
    p_relaxation_flag_1 NUMBER; --added for HF_176638 on 18-June-2018
    custom_exception    EXCEPTION;
    L_CURR_AY           NUMBER :=0;  -- Added for Hot Fix#77468
    v_month_exists      NUMBER :=0;  --added for CR_HW_0224
    v_rec_count         NUMBER :=0;  --added for CR_HW_0224
    P_RECT_CHECK        NUMBER := 0; --added as a part of CR_HWSW_0228
    L_CHK_REVISED1      NUMBER := 0; --added as a part of CR_HWSW_0228
    V_DELAY_MONTHS      NUMBER :=0;  --Addes FOR 542
    -- Table type to for bulk processing of IRT_ID
    /*HOTFIX#139429*/
    L_55_ROLLBACK    NUMBER       :=0;
    L_PRCSSNG_CD     NUMBER       :=0;
    L_OUT_RETURN_CD  NUMBER       :=0;
    L_OUT_RETURN_MSG VARCHAR2(200):='';
    /*HOTFIX#139429 END*/
    L_SOURCE "process_store"."irt_process_control_mstr"."x_source_name"@psql_process_fas%TYPE;                -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018
    v_approval_flag IRT_STDCMP.IBA_REFD_RETURNS.approval_flag%TYPE; -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018
    -- Added for CR#729 - 241a - 22-Oct-2018 -- starts
    l_241a_flag "process_store"."irt_process_control_mstr"."x_flag_241a"@psql_process_fas%TYPE;
    v_approval_x_flag_241a IRT_STDCMP.IBA_REFD_RETURNS.approval_flag%TYPE;
    l_241a_rec    VARCHAR2(1) := 'N';
    L_AO_BLCK_REC VARCHAR2(1) := 'N';
    -- Added for CR#729 - 241a - 22-Oct-2018 -- ends
    l_irt_approval_date DATE;--Added for Hotfix_199485 on 13-MAR-2019
  TYPE tbl_pcm_irt
IS
  TABLE OF VARCHAR2(240) INDEX BY BINARY_INTEGER;
  l_irt_tbl tbl_pcm_irt;
  -- cursor to pick up irt_id's eligible for the request_id for processing
  CURSOR cur_irt_id(p_request_id IN NUMBER)
  IS
    SELECT DISTINCT xats.transaction_number IRT_ID ,
      xats.bill_to_customer_number Id_num,
      xats.assessment_year ay --added for check for latest revised
    FROM xx_AR_TRANS_STG xats
    WHERE request_id = p_request_id;
  -- Start of changes for 1.13 version on 15-OCT-2014
  -- To pick up the l_batch_size records for marking request IDs
  -- FOR UPDATE OF to lock the fetched records so the remaining records are
  -- available for processing.
  --Start of changes for 1.14 version
  CURSOR process_irt_rcrds( p_request_id NUMBER)
  IS
    SELECT XATS1.transaction_number IRT_ID
    FROM xx_ar_trans_stg XATS1
    WHERE XATS1.transaction_number IN
      ( SELECT DISTINCT XATS.transaction_number "irt_id"
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM,
        xx_ar_trans_stg XATS,
        xx_5TO6_PROCESS_TEMP X56PT
      WHERE PCM."process_status_code"       = 5
      AND PCM."x_irt_ctl_flag"           = 'C'
      AND NVL(PCM."x_source_name", 'X') <> 'IBA-WS' --Added on 25-jun-2018 Hotfix#183194
        -- AND PCM."x_val_filing_status_cd" in ('O','R') --ADDED ON 03-08-2012
      AND XATS.transaction_number     = pcm."irt_id"
      AND NVL(XATS.status_code,'NEW') = 'NEW'
      AND XATS.request_id            IS NULL
      AND XATS.transaction_number     = X56PT.TRANSACTION_NUMBER
      AND X56PT.request_id            = p_request_id
      ) FOR UPDATE OF XATS1.request_id,
    XATS1.STATUS_CODE;

BEGIN
  l_chr_proc_name     := 'wrapper_API';
  p_out_chr_retcode   := g_chr_success_code ;
  P_OUT_CHR_ERRBUFF   := '';
 -- l_parent_request_id := p_in_request_id;
--  p_in_request_id     := fnd_global.conc_request_id;-- by ganesh for running from jar file
  l_parent_request_id := p_in_irt_id;
  p_in_request_id     := p_in_irt_id;-- by ganesh for running from jar file


  /*
			  create_process_log ( p_out_chr_errbuff => p_out_chr_errbuff ,
			  P_OUT_CHR_RETCODE => P_OUT_CHR_RETCODE ,
			  p_in_request_id => p_in_request_id ,
			  P_IN_PROCESS_CNT => NULL ,
			  P_IN_FAILURE_CNT => NULL ,
			  P_STATUS => 'RUNNING' ,
			  p_parent_request_id => l_parent_request_id
			  );
			*/  

  write_msg( g_write_logfile , ' parent Request ' || l_parent_request_id || ' child ' || p_in_request_id);
  l_strt_time := SYSTIMESTAMP;
  write_debug( g_debug_flag , 'Entering Procedure ' || l_chr_proc_name || ' -' ||p_in_request_id || '-' || l_strt_time);
  write_msg( g_write_logfile ,' Batch Size '|| l_batch_size ||' Record ');
  write_msg( g_write_logfile ,' Commit Every '|| l_commit_int_cnt||' Record ');
  write_msg( g_write_logfile ,' Commit Record Interval '|| l_commit_freq);
  dbms_output.put_line('Debuging  Step1');
  -- Tags the request_id to the records which needs to be processed by the
  -- wrapper
  -- program
  --Added for Hotfix_199485 on 13-MAR-2019 START
  BEGIN
    SELECT DISTINCT IRT_APPROVAL_DATE,BILL_TO_CUSTOMER_NUMBER --g_id_number Added By kulasekhar fas2.0
    INTO L_IRT_APPROVAL_DATE,g_id_number
    FROM xx_AR_TRANS_STG XATSA
    WHERE NVL(XATSA.STATUS_CODE ,'NEW') NOT IN ('ERROR','INV_SUCCESS','NOT_TO_BE_PROC','FAS IRT STG HOLD')
    AND xatsa.transaction_number             = p_in_irt_id
	and rownum=1;
  END;

--Added for Hotfix_199485 on 13-MAR-2019 END
IF p_in_irt_id      IS NOT NULL THEN
  l_stmt_processing := ' IRT_ID To processed is ' || p_in_irt_id ;
  Write_Debug( G_Debug_Flag ,L_Chr_Exe_Location ||'-'||L_Stmt_Processing );
  write_debug( g_debug_flag ,l_chr_exe_location ||'- Added by Sudha..' );
  -- Updating request_id of the program for the IRT in staging table
 dbms_output.put_line('Debug  Approval Date '||L_IRT_APPROVAL_DATE||' Id Number :'||g_id_number);

  UPDATE xx_AR_TRANS_STG xats
  SET xats.status_code = 'NEW',
    xats.attribute2    = 'NEW',
    --xats.IRT_APPROVAL_DATE = g_dte_sys_date , -- CR_HW_0224 updating  --Commented for Hotfix_199485 on 13-MAR-2019
    -- IRT_APPROVAL_DATE to SYSDATE
    xats.request_id                       = p_in_request_id
  WHERE NVL(xats.status_code ,'NEW') NOT IN ('ERROR','INV_SUCCESS', 'NOT_TO_BE_PROC','FAS IRT STG HOLD')
  AND xats.transaction_number             = p_in_irt_id
  AND EXISTS
    (SELECT 'x'
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM
    WHERE PCM."process_status_code"       = 5
  --  AND PCM."x_irt_ctl_flag"           = 'C'
    AND pcm."irt_id"                 = XATS.TRANSACTION_NUMBER
    AND NVL(PCM."x_source_name", 'X') <> 'IBA-WS' --Added on 25-jun-2018 Hotfix#183194
    ) ;

	--COMMIT;
	dbms_output.put_line('Debug After Approval Date '||L_IRT_APPROVAL_DATE||' Id Number :'||g_id_number||SQLERRM);

  IF SQL%ROWCOUNT      = 0 THEN

		dbms_output.put_line('Debug Zero rows updated for IRT ID '||p_in_irt_id);

			l_stmt_processing := '0 record(s) updated ';
			write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
			P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE ;
			P_OUT_CHR_ERRBUFF := 'Unable to Find and update the IRT record, ensure that IRT Number Provided is correct' ;
		  /*  create_process_log ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_request_id => p_in_request_id ,p_in_process_cnt => 0 ,P_IN_FAILURE_CNT => 0 ,P_STATUS => 'COMPLETED' );
		   */
		   write_msg( g_write_outfile , p_out_chr_errbuff);
			RETURN;
		  END IF;
       dbms_output.put_line('Debug  Step335');
ELSE -- IF in_irt_id IS NOT NULL THEN
  l_stmt_processing := ' Gathering records to be Proceesed Request_id -' || p_in_request_id ;
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  l_irt_tbl.DELETE;

   dbms_output.put_line('Debug  Else Case for IRT ID updataion done...');


  UPDATE xxcus.xx_5TO6_PROCESS_TEMP
  SET REQUEST_ID    = P_IN_REQUEST_ID
  WHERE REQUEST_ID IS NULL
  AND ROWNUM       <= l_batch_size;
  COMMIT; -- Marked records and release the temp table lock --29-Oct-2014--
  -- 1.14
  -- Added the below logic to bulk collect the locked records from
  -- process_irt_rcrds cursor
  dbms_output.put_line('Debug  Step336');
  OPEN process_irt_rcrds (p_in_request_id) ;
  FETCH process_irt_rcrds BULK COLLECT INTO l_irt_tbl;
  CLOSE process_irt_rcrds;
  -- End of changes for 1.13 version on 15-OCT-2014
  l_stmt_processing := 'Checking if any records had been identifed for processing';
  -- Check if any record is available for processing
						  IF l_irt_tbl.COUNT   > 0 THEN
							l_stmt_processing := 'Setting the request_id for records identifed for processing';
							-- Set's the master program request_id for records to be processed
							FORALL i IN 1..l_irt_tbl.COUNT
							UPDATE xx_AR_TRANS_STG xats
							SET xats.status_code = 'NEW',
							  xats.attribute2    = 'NEW',
							  --xats.IRT_APPROVAL_DATE = g_dte_sys_date , -- CR_HW_0224 updating  --Commented for Hotfix_199485 on 13-MAR-2019
							  -- IRT_APPROVAL_DATE to SYSDATE
							  xats.request_id                       = p_in_request_id
							WHERE NVL(xats.status_code ,'NEW') NOT IN ('ERROR','INV_SUCCESS', 'NOT_TO_BE_PROC','FAS IRT STG HOLD')
							  -- Start of changes for 1.13 version on 15-OCT-2014
							  -- Added the below condition to avoid multiple childs to update the
							  -- same record.
							AND xats.request_id IS NULL
							  -- End of changes for 1.13 version on 15-OCT-2014
							AND xats.transaction_number = l_irt_tbl(i);
							write_debug( g_debug_flag , l_stmt_processing || '. Eligible records [' || l_irt_tbl.count ||'] identified ' );
						  ELSE --IF l_irt_tbl.COUNT > 0 THEN
							p_out_chr_retcode := g_chr_failure_code ;
							p_out_chr_errbuff := ' No records available for processing in the Invoice Staging table' ;
							write_msg( g_write_logfile , p_out_chr_errbuff );
							write_msg( g_write_outfile , p_out_chr_errbuff );
						   /* create_process_log ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_request_id => p_in_request_id ,p_in_process_cnt => 0 ,P_IN_FAILURE_CNT => 0 ,p_status => 'COMPLETED' );
						   */ RETURN;
						  END IF; -- IF l_irt_tbl.COUNT > 0 THEN
END IF;   -- IF in_irt_id IS NOT NULL THEN
-- Introducing the commit to make the request_id update permanent and release
-- lock on staging table
-- Start of changes for 1.13 version on 15-OCT-2014
/*create_process_log ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_request_id => p_in_request_id , p_in_process_cnt => 0 ,P_IN_FAILURE_CNT => 0 ,p_status => 'MARKED' );
*/-- End of changes for 1.13 version on 15-OCT-2014
COMMIT;
 dbms_output.put_line('Debug  Step3');
l_stmt_processing := ' Getting User, Resp, Application Id for Initializing ';
SELECT application_id,
  responsibility_id
INTO l_application_id,
  l_resp_id
FROM fnd_responsibility_tl
WHERE responsibility_name = 'Receivables Manager';
write_msg( g_write_logfile , ' Apps Initialization Complte User_id [' || g_num_user_id ||'] resp_id [' || l_resp_id ||'] Application_id [' || l_application_id ||']');
dbms_output.put_line(' Apps Initialization Complte User_id [' || g_num_user_id ||'] resp_id [' || l_resp_id ||'] Application_id [' || l_application_id ||']'||'] org_id [' || g_num_org_id ||']');
l_stmt_processing := ' Calling standard API for application Initialization ' || g_num_org_id;
mo_global.init('AR');
--mo_global.set_policy_context('S',g_num_org_id);
mo_global.set_policy_context('S',81);
--fnd_global.apps_initialize (g_num_user_id, l_resp_id, l_application_id , 0);
fnd_global.apps_initialize (1092, 20678, 222 , 0);
dbms_output.put_line('Calling routine to derive default values for IRT Accounting');
-- Calling routine to derive default values for IRT Accounting
get_dflt_value(p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_request_id => p_in_request_id );
-- Check if any error encountered while deriving default values
dbms_output.put_line('Debug  Step4');
IF p_out_chr_retcode = g_chr_failure_code THEN
  write_msg( g_write_logfile ,' Error in Default Routine ');
  dbms_output.put_line('Debug Error  Step4');
  RAISE custom_exception;
END IF;
dbms_output.put_line('Debug  Step5');
-- Main step of the wrapper starts here by calling individual Accouting API's
l_stmt_processing := 'Starting the Wrapper call to Accounting routines ';
FOR cur_irt_id_rec IN cur_irt_id(p_in_request_id)
LOOP
  l_241a_rec           := 'N';  --added for HF_193063 on 1-Mar-18
  L_AO_BLCK_REC        := 'N';  --added for HF_193063 on 1-Mar-18
  V_APPROVAL_x_flag_241a := NULL; --added for HF_193063 on 8-Mar-18
  v_approval_flag      := NULL; --added for HF_193063 on 8-Mar-18
  L_241A_FLAG          := NULL; --added for HF_193063 on 8-Mar-18
  l_cnt                := l_cnt + 1;
  /* Start of Changes Added Hot Fix#77468 */
  SELECT EXTRACT (YEAR FROM SYSDATE)
  INTO L_CURR_AY
  FROM dual;
  UPDATE xx_ar_trans_stg
  SET STATUS_CODE         ='ERROR' ,
    ERROR_MESSAGE         ='Invalid AY '
  WHERE TRANSACTION_NUMBER=CUR_IRT_ID_REC.IRT_ID
  AND ( ASSESSMENT_YEAR  <= 1960
  OR ASSESSMENT_YEAR      > L_CURR_AY );
  /* End of Changes Added for Hot Fix#77468  */
  /* Start of Changes Added for Dmd Collection Report - CR_HWSW_0584 */
  INSERT
  INTO xxcus.xx_DEM_COLL_REP_GTT
    (
      ID_NUMBER ,
      AY ,
      DIN ,
      ORIG_DEM_AMT ,
      OUTSTANDING_DEM_AMT ,
      DEM_INTEREST_AMT ,
      DEM_CREATED_DATE ,
      SEC_CODE ,
      DEM_STATUS ,
      DEM_SERVICE_DATE ,
      IRT_ID ,
      CUST_TRX_ID
    )
    (SELECT ID_NUMBER ,
        IRT_AY ,
        DMD_IDENTIFICATION_NUMBER ,
        DMD_ORIGINAL_AMOUNT ,
        AVL_REFD_ADJUST_AMOUNT ,
        DMD_INTEREST_AMOUNT ,
        DMD_IDENTIFIED_DATE ,
        SEC_CODE ,
        DMD_STATUS ,
        DMD_SERVICE_DATE ,
        IRT_ID ,
        CUSTOMER_TRX_ID
      FROM xx_DMD_HEADERS
      WHERE ID_NUMBER   = cur_irt_id_rec.id_num
      AND DMD_STATUS IN ('DMD','INT DMD')
    );
 

  FND_FILE.PUT_LINE ( FND_FILE.LOG, 'Save point check' ) ;
  SAVEPOINT irt_rec_acc; --irt_rec
  write_msg ( g_write_logfile , ' ************************* IRT Processing **************** ' ) ;
  write_msg ( g_write_logfile ,' Picking IRT_ID ' || cur_irt_id_rec.irt_id || ' for Processing ' ) ;
  write_msg ( g_write_logfile , ' ********************************************************* ' ) ;
  l_irt_process_cnt := l_irt_process_cnt + 1;
  l_commit_rec_cnt  := l_commit_rec_cnt  + 1;
  l_stmt_processing := ' Calling standard API for application Initialization '|| g_num_org_id;
  mo_global.init ( 'AR' ) ;
  mo_global.set_policy_context ( 'S',g_num_org_id ) ;
  fnd_global.apps_initialize ( g_num_user_id, l_resp_id, l_application_id , 0 ) ;
  -- Main step of the wrapper starts here by calling individual Accouting API
  -- 's
  -- Interest 234B calculation till sysdate proc for CR_HW_0224
  --****************** Update_ar_trans_stg_tbl API **********************--
  l_stmt_processing := ' Calling Update_ar_trans_stg_tbl proc ';
  write_msg ( g_write_logfile , ' Calling Update_ar_trans_stg_tbl proc ' ) ;
  /* start of Checking months>0 for calculating 234B_calc_date for CR_HW_0224
  */
  dbms_output.put_line('Debug  Step6');
  SELECT COUNT(1)
  INTO v_rec_count
  FROM apps.xx_ar_trans_stg
  WHERE request_id       =p_in_request_id
  AND transaction_number = cur_irt_id_rec.irt_id
  AND STATUS_CODE        = 'NEW'
  AND MINOR_HEAD        IN ('Rev Interest 234B','Interest 234B', 'Rec Interest 234B');
  write_msg( g_write_logfile , ' v_rec_count :  '|| v_rec_count );
  IF v_rec_count > 0 THEN
    --Commented for Hotfix_199485 on 13-MAR-2019--START
    /*SELECT MONTHS_BETWEEN (TO_DATE (TO_CHAR (TRUNC (SYSDATE),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR (X_B234_CALC_DT, 'MON-YYYY'), 'MON-YYYY')) AS months
    INTO v_month_exists
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE IRT_ID =CUR_IRT_ID_REC.IRT_ID;*/
    --Commented for Hotfix_199485 on 13-MAR-2019--END
    --added for Hotfix_199485 on 13-MAR-2019--START
   BEGIN
   SELECT MONTHS_BETWEEN (TO_DATE (TO_CHAR (TRUNC (to_date(L_IRT_APPROVAL_DATE,'DD-MM-RRRR')),'MON-YYYY'), 'MON-YYYY'), TO_DATE (TO_CHAR ("x_b234_calc_dt", 'MON-YYYY'), 'MON-YYYY')) AS months
    INTO v_month_exists
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id" =CUR_IRT_ID_REC.IRT_ID;
	Exception When No_data_found then
				v_month_exists		:= Null;
				When Others then 
				v_month_exists		:= Null;
	END;

	Dbms_output.put_line('v_month_exists'||v_month_exists);

    --added for Hotfix_199485 on 13-MAR-2019--END
    write_msg( g_write_logfile , ' v_month_exists :  '|| v_month_exists );
    IF v_month_exists>0 THEN
      --  Update_ar_trans_stg_tbl ( p_out_chr_errbuff => p_out_chr_errbuff ,
      -- p_out_chr_retcode => p_out_chr_retcode , p_in_irt_id =>
      -- cur_irt_id_rec.irt_id , p_in_request_id => p_in_request_id );
      Update_ar_trans_stg_tbl ( p_out_chr_errbuff => p_out_chr_errbuff ,
	  p_out_chr_retcode => p_out_chr_retcode ,
	  p_in_irt_id => cur_irt_id_rec.irt_id , 
	  p_in_request_id => p_in_request_id, 
	  p_in_months_exists => v_month_exists);
      write_msg( g_write_logfile , ' Validate API return Status '|| p_out_chr_retcode );
      -- check if a failure in update_trans_stg_tble procedure
      IF p_out_chr_retcode = g_chr_failure_code THEN
        GOTO ROLLBACK_REC;
      END IF;
    END IF; --v_month_exists>0
  END IF;   --v_rec_count >0
  dbms_output.put_line('Calling Validate API');
  /* end of Checking months>0 for calculating 234B_calc_date for CR_HW_0224
  */
  --****************** Validate and create Invoice API **********************
  --
  l_stmt_processing := ' Calling Validate API ';
  write_msg( g_write_logfile , ' Calling Validate API ');

  validate_create_invoice ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode , p_in_irt_id => cur_irt_id_rec.irt_id , p_in_request_id => p_in_request_id );
  write_msg( g_write_logfile , ' Validate API return Status '|| p_out_chr_retcode );
  -- check if a failure in Invoice creation
  IF p_out_chr_retcode = g_chr_failure_code THEN
  dbms_output.put_line('Calling Validate API  GOTO ROLLBACK_REC..');
    GOTO ROLLBACK_REC;
  END IF;
  --****************** Apply Invoice To Receipt API **********************--
  l_stmt_processing := ' Calling Apply Invoice To Receipt API ';
  dbms_output.put_line(' Calling Apply Invoice To Receipt API ');
  write_msg( g_write_logfile , ' Calling Apply Invoice To Receipt API ');
	inv_apply ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode , p_in_irt_id => cur_irt_id_rec.irt_id );
  write_msg( g_write_logfile , ' Apply Invoice To Receipt API return Status ' || p_out_chr_retcode );
  dbms_output.put_line(' Apply Invoice To Receipt API return Status ' || p_out_chr_retcode );
  -- check if a failure in Invoice creation
  IF p_out_chr_retcode = g_chr_failure_code THEN
  dbms_output.put_line(' rollback nvoice To Receipt API return Status ' || p_out_chr_retcode );
    GOTO ROLLBACK_REC;
  END IF;
  --****************** Excess Collect API **********************--
  write_msg( g_write_logfile , ' Calling Excess Collect API ');
  dbms_output.put_line( ' Calling Excess Collect API ');
	excess_collect ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id );
  write_msg( g_write_logfile , ' Excess Collect API return stauts '|| p_out_chr_retcode );
  dbms_output.put_line(' Excess Collect API return stauts '|| p_out_chr_retcode );
  -- check if a failure in Excess collect API
  IF p_out_chr_retcode = g_chr_failure_code THEN
    GOTO ROLLBACK_REC;
  END IF;
  --****************** Refd Interest API **********************--
  write_msg( g_write_logfile , ' Calling Refd Interest API ');
  dbms_output.put_line(' Calling Refd Interest API ');
  refd_interest( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id );
  write_msg( g_write_logfile , ' Refd Interest API return status '|| p_out_chr_retcode );
  dbms_output.put_line(' Refd Interest API return status '|| p_out_chr_retcode );
  -- check if a failure in Refd Interest API
  IF p_out_chr_retcode = g_chr_failure_code THEN
    GOTO ROLLBACK_REC;
  END IF;
  dbms_output.put_line('Debug  Step8');

  --****************** Delay Interest API **********************--

  BEGIN
    SELECT NVL("x_flag_241a",'X')
    INTO L_241A_FLAG
    FROM "process_store"."irt_process_control_mstr"@psql_process_fas
    WHERE "irt_id"              =cur_irt_id_rec.irt_id
    AND NVL("x_source_name",'X') <> 'IBA-WS';
  EXCEPTION
  WHEN OTHERS THEN
    WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'UNABLE TO FIND SOURCE_NAME');
    p_out_chr_retcode := g_chr_failure_code;
  END;
  IF p_out_chr_retcode = g_chr_failure_code THEN
    GOTO ROLLBACK_REC;
  END IF;
  IF l_241a_flag = 'Y' THEN
    BEGIN
      SELECT NVL(APPROVAL_FLAG,'X')
      INTO v_approval_x_flag_241a
      FROM irt_stdcmp.IBA_refd_returns
      WHERE irt_id = cur_irt_id_rec.irt_id;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_approval_x_flag_241a := 'X';
      FND_FILE.PUT_LINE (FND_FILE.LOG, 'No approval_flag found for IRT_ID: '||P_IN_IRT_ID);
      dbms_output.put_line('No approval_flag found for IRT_ID: '||P_IN_IRT_ID);
    END;
	dbms_output.put_line('Debug  Step9');
    IF NVL(V_APPROVAL_x_flag_241a,'X') = 'H' THEN
      l_241a_rec                    := 'Y';
      FND_FILE.PUT_LINE (FND_FILE.LOG, 'Its a 241a case. 245 notice will not be issued to Xxpayer. No adjustment will happen');
    END IF;
  ELSE
    -- Added for CR#729 - 241a - 22-Oct-2018 - ends
    -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018 -- starts
    --****************** Blocked refd cases **********************--
    BEGIN
      SELECT NVL("x_source_name", 'X')
      INTO L_SOURCE
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas
      WHERE "irt_id" =cur_irt_id_rec.irt_id;
    EXCEPTION
    WHEN OTHERS THEN
      WRITE_DEBUG( G_DEBUG_FLAG ,L_CHR_EXE_LOCATION ||'-'|| 'UNABLE TO FIND SOURCE_NAME');
      p_out_chr_retcode := g_chr_failure_code;
    END;
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    IF L_SOURCE IN ('IBA-P', 'IBA-E') THEN
      BEGIN
        SELECT approval_flag
        INTO v_approval_flag
        FROM irt_stdcmp.IBA_refd_returns
        WHERE irt_id = cur_irt_id_rec.irt_id;
      EXCEPTION
      WHEN no_data_found THEN
        v_approval_flag := 'X';
        FND_FILE.PUT_LINE (FND_FILE.LOG, 'No approval_flag found for the source_name: '||L_SOURCE);
        dbms_output.put_line('No approval_flag found for the source_name: '||L_SOURCE);
        --        p_out_chr_retcode := g_chr_failure_code;
      END;
      IF p_out_chr_retcode = g_chr_failure_code THEN
        GOTO ROLLBACK_REC;
      END IF;
    END IF;
	dbms_output.put_line('Debug  Step10');
    IF NVL(V_APPROVAL_FLAG,'X') = 'B' THEN
      L_AO_BLCK_REC            := 'Y'; -- Added for CR#729 - 241a - 22-Oct-2018
      FND_FILE.PUT_LINE (FND_FILE.LOG, 'Its a IBA-P/IBA-E refd blocked case. 245 notice will not be issued to Xxpayer. No adjustment will happen');
	  dbms_output.put_line('Its a IBA-P/IBA-E refd blocked case. 245 notice will not be issued to Xxpayer. No adjustment will happen');
    END IF;
  END IF;                                             -- l_241a_flag = 'Y' THEN -- Added for CR#729 - 241a - 22-Oct-2018
  IF (l_241a_rec = 'Y') OR (l_ao_blck_rec = 'Y') THEN -- Added for CR#729 - 241a - 22-Oct-2018
    FND_FILE.PUT_LINE (FND_FILE.LOG, 'Its a IBA-P/IBA-E refd blocked case OR 241A compliant case. 245 notice will not be issued to Xxpayer. No adjustment will happen');
	dbms_output.put_line('Its a IBA-P/IBA-E refd blocked case OR 241A compliant case. 245 notice will not be issued to Xxpayer. No adjustment will happen');
  ELSE
    -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018 -- ends, Added for CR#729 - 241a - 22-Oct-2018 ends
    --****************** TS xx rate deduct API **********************--
    write_msg( g_write_logfile , ' Calling TS xx rate API ');
	dbms_output.put_line(' Calling TS xx rate API ');
    ts_xx_rate ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id );
    write_msg( g_write_logfile , ' Refd TS xx Rate API return status '|| p_out_chr_retcode );
    -- check if a failure in Refd Interest API
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    --****************** Refd Cross Schedule Type/Major Head Adjustment API *
    -- *************--
    l_stmt_processing := ' Calling Refd Cross Schedule Type/Major Head Adjustment API with ID ';
	dbms_output.put_line(' Calling Refd Cross Schedule Type/Major Head Adjustment API with ID ');
    crosssched_adjust( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
    write_msg( g_write_logfile , ' Refd Cross Schedule Type/Major Head API return '|| p_out_chr_retcode );
	dbms_output.put_line(' Refd Cross Schedule Type/Major Head API return '|| p_out_chr_retcode );
    -- check if a failure in Cross Adjustment API
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
	dbms_output.put_line('Debug  Step11');

    l_stmt_processing := ' Calling Prior Refd Adjustment API';
    write_msg( g_write_logfile , ' Calling Prior Refd Adjustment API ');
	dbms_output.put_line(' Calling Prior Refd Adjustment API ');
    Prior_refd_receipt_adjust ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id);
    -- check if a failure in Prior Refd Adjustment API call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    --****************** Dmd Identify API **********************--
    l_stmt_processing := ' Calling Dmd Identify API';
    write_msg( g_write_logfile , ' Calling Dmd Identify API');
	dbms_output.put_line(' Calling Dmd Identify API');
    dmd_populate_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_irt_id => cur_irt_id_rec.irt_id );
    -- check if a failure in Dmd Identify API API call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    /*Added as part of CR#583 phase2*/
    --*******************XX CREDIT MISATCH API*****************************
    ------
    l_stmt_processing := ' CALLING XX CREDIT MISMATCH API';
    write_msg( g_write_logfile , ' Calling XX CREDIT MISMATCH');
	dbms_output.put_line(' Calling XX CREDIT MISMATCH');
    XX_CREDIT_MISMATCH_API( P_OUT_CHR_ERRBUFF => P_OUT_CHR_ERRBUFF, P_OUT_CHR_RETCODE => P_OUT_CHR_RETCODE, P_IN_IRT_ID => cur_irt_id_rec.irt_id, P_IN_ID_NUMBER => cur_irt_id_rec.id_num );
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
	dbms_output.put_line('Debug  Step12');

    write_msg( g_write_logfile , ' Calling RO skip Check API');
    p_skip_ro_status  := 0;
    p_relaxation_flag :=0; --added for HF_175742 on 11-Apr-2018
    l_stmt_processing := 'Calling RO Skip Check API ';
	dbms_output.put_line('Calling RO Skip Check API ');
    ro_skip_check_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_skip_ro_status => p_skip_ro_status,p_relaxation_flag => p_relaxation_flag ,p_in_id_number => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id, p_in_irt_ay => cur_irt_id_rec.ay ); --added for HF_175742 on 11-Apr-2018
    --ro_skip_check_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_skip_ro_status => p_skip_ro_status, p_in_id_number => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id, p_in_irt_ay => cur_irt_id_rec.ay ); --commented for HF_175742 on 11-Apr-2018
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    IF (p_skip_ro_status=0) THEN
      p_out_ro_status  :=3; -- adjust
    ELSE
      p_out_ro_status:=2; -- do notadjust
    END IF;

    IF p_out_ro_status = 2 THEN
      BEGIN
        UPDATE xx_refd_headers head
        SET HEAD.NET_REFD_AMOUNT = NVL (HEAD.TOTAL_REFD_AMOUNT, 0) - NVL ( HEAD.REFD_ADJUSTMENT_AMOUNT, 0)
        WHERE head.irt_id          = cur_irt_id_rec.irt_id;
        write_debug( g_debug_flag ,'No of rows updated in refd headers:'|| sql%rowcount);
		dbms_output.put_line('No of rows updated in refd headers:'|| sql%rowcount);
      EXCEPTION
      WHEN OTHERS THEN
        write_debug( g_debug_flag , 'Error while updating refd headers table:'||sqlerrm );
		dbms_output.put_line('p_out_ro_status = 2 :Error while updating refd headers table:'||sqlerrm );
      END;
    END IF;
	dbms_output.put_line('Debug  Step13');
    --Code is uncommented to enable RO-5000 Rule - Ends here. -
    --Below Code is uncommented as a part of Hotfix#59466   -- - 20-OCT-2014
    --IF p_out_ro_status <> 2 -- for CR_HWSW_0226
    --THEN
    --Code is uncommented to enable RO-5000 Rule - Ends here. -
    --Below Code is uncommented as a part of Hotfix#59466   -- - 20-OCT-2014
    --Below Code is commented as a part of Hotfix#77840
    IF p_out_ro_status <> 2 THEN --Uncommented as a Part of Hotfix#99289
      --****************** Threshold Dmd Update API **********************--
      l_stmt_processing := ' Calling Threshold Dmd Update API';
      write_msg( g_write_logfile , 'Threshold Dmd Update API');
	  dbms_output.put_line(' Calling Threshold Dmd Update API');
      threshold_dmd_update_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_number => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
      -- check if a failure in Threshold Dmd Update API call
      IF p_out_chr_retcode = g_chr_failure_code THEN
        GOTO ROLLBACK_REC;
      END IF;
	  dbms_output.put_line('Debug  Step14');
      --****************** Refd adjustment API **********************--
      l_stmt_processing := ' Calling Refd Adjustment API';
      write_msg( g_write_logfile , ' Calling Refd Adjustment API');
	   dbms_output.put_line(' Calling Refd Adjustment API');
      refd_adjust_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_number => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
      -- check if a failure in Refd adjustmen API call
      IF p_out_chr_retcode = g_chr_failure_code THEN
        GOTO ROLLBACK_REC;
      END IF;
	  dbms_output.put_line('Debug  Step15');
      --****************** Dmd interest invoice API **********************--
      l_stmt_processing := ' Calling Dmd Interest Invoice API';
      write_msg( g_write_logfile , ' Calling Dmd Interest Invoice API');
	  dbms_output.put_line(' Calling Dmd Interest Invoice API');
      dmd_intinv ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
      -- check if a failure in Dmd interest invoice API call
      IF p_out_chr_retcode = g_chr_failure_code THEN
        GOTO ROLLBACK_REC;
      END IF;
      --****************** Refd Adjustment for Dmd Interest API **********
      -- ************--
      l_stmt_processing := ' Calling Interest Dmd Refd Adjustment API';
      write_msg( g_write_logfile , ' Calling Interest Dmd Refd Adjustment API');
	  dbms_output.put_line(' Calling Interest Dmd Refd Adjustment API');
      intdmd_refnd_adj_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
      -- check if a failure in Refd Adjustment for Dmd Interest API call
      IF p_out_chr_retcode = g_chr_failure_code THEN
        GOTO ROLLBACK_REC;
      END IF;
	  dbms_output.put_line('Debug  Step16');
    END IF; -- uncommented as a Part of CR_HWSW_0558  - On 27-Jul-2016
    --****************** Refd Excess Collection with Minor Head 400 API *****
    -- *****************--
    l_stmt_processing := ' Calling Dmd Collect API';
    write_msg( g_write_logfile , ' Calling Dmd Collect API');
	dbms_output.put_line(' Calling Dmd Collect API');
    dmd_collect_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode,
    -- p_in_id_num => cur_irt_id_rec.id_num,
    p_in_irt_id => cur_irt_id_rec.irt_id );
    -- check if a failure in Refd Excess Collection with Minor Head 400 API
    -- call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
	dbms_output.put_line('Debug  Step17');
    --****************** Dmd interest invoice API **********************--
    l_stmt_processing := ' Calling Dmd Interest Invoice API';
    write_msg( g_write_logfile , ' Calling Dmd Interest Invoice API');
    dmd_intinv ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
    -- check if a failure in Dmd interest invoice API call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    --****************** Refd Adjustment for Dmd Interest API ************
    -- **********--
    l_stmt_processing := ' Calling Interest Dmd Refd Adjustment API';
    write_msg( g_write_logfile , ' Calling Interest Dmd Refd Adjustment API');
	dbms_output.put_line(' Calling Interest Dmd Refd Adjustment API');
    intdmd_refnd_adj_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
    -- check if a failure in Refd Adjustment for Dmd Interest API call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
	dbms_output.put_line('Debug  Step18');
    -- Uncommented as a Part of Hotfix#59466  -- 20-OCT-2014
    --****************** Refd Excess Collection with Minor Head 400 API *****
    -- *****************--
    l_stmt_processing := ' Calling Dmd Collect API';
    write_msg( g_write_logfile , ' Calling Dmd Collect API');
    dmd_collect_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode,
    -- p_in_id_num => cur_irt_id_rec.id_num,
    p_in_irt_id => cur_irt_id_rec.irt_id );
    -- check if a failure in Refd Excess Collection with Minor Head 400 API
    -- call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    --****************** Dmd interest invoice API **********************--
    l_stmt_processing := ' Calling Dmd Interest Invoice API';
    write_msg( g_write_logfile , ' Calling Dmd Interest Invoice API');
	dbms_output.put_line(' Calling Dmd Interest Invoice API');
    dmd_intinv ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
    -- check if a failure in Dmd interest invoice API call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
	dbms_output.put_line('Debug  Step19');
    --****************** Dmd Interest Invoice Creation API *****************
    -- *****--
    l_stmt_processing := ' Calling Dmd Interest Invoice Creation API';
    write_msg( g_write_logfile , ' Calling Dmd Interest Invoice Creation API');
    intdmd_collect ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_proc_type => 'R', p_in_irt_id => cur_irt_id_rec.irt_id );
    -- check if a failure in Dmd Interest Invoice Creation API call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
	dbms_output.put_line('Debug  Step20');
    --****************** Excess 400 API **********************--
    l_stmt_processing := ' Calling Excess 400 API';
    WRITE_MSG( G_WRITE_LOGFILE , ' Calling Excess 400 API');
    -- commented the excess 400 application routine as the functionality
    -- had changed and development of the same is in WIP
    excess_400_proc ( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode,p_skip_ro_status_1=>p_skip_ro_status_1,p_relaxation_flag_1=>p_relaxation_flag_1, p_in_id_num => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id ); --added p_skip_ro_status_1 for HF_176638 on 16-May-2018 --added p_relaxation_flag_1 for HF_176638 on 18-June-18
    -- check if a failure in Dmd interest invoice API call
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
	dbms_output.put_line('Debug  Step21');
  
  END IF; --IF (l_241a_rec = 'Y') OR (l_ao_blck_rec = 'Y') THEN -- Added for CR#729 - 241a - 22-Oct-2018
  --****************** IRT Control Master Update API -- Need to change ******
  -- ****************--
  l_stmt_processing := 'Calling IRT Control Master Update API';

  dbms_output.put_line('Calling IRT Control Master Update API');
  write_msg( g_write_logfile , ' Calling IRT Control Master Update API ');
  irtctrlmaster_proc( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id ,p_in_id_num => cur_irt_id_rec.id_num );
  dbms_output.put_line( ' IRT Control Master Update API return status '|| p_out_chr_retcode );
  write_msg( g_write_logfile , ' IRT Control Master Update API return status '|| p_out_chr_retcode );
  -- check if a failure in Refd Interest API
  IF p_out_chr_retcode = g_chr_failure_code THEN
  dbms_output.put_line('Rollback Calling IRT Control Master Update API');

    GOTO ROLLBACK_REC;
  END IF;
  ---*********ADDITION TO COLLECTION REPORT FOR DMD DATA - CR_HWSW_0584***
  -- *******---
  l_stmt_processing := ' Calling Dmd Collection Report API ';
  dbms_output.put_line(' Calling Dmd Collection Report API ');
  WRITE_MSG( G_WRITE_LOGFILE , ' Calling Dmd Collection Report API ');
  DMD_COLL_REP_PROC( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_num => cur_irt_id_rec.id_num);
  write_msg( g_write_logfile , ' Insert in table for Dmd Collection report status '|| p_out_chr_retcode );
  IF p_out_chr_retcode = g_chr_failure_code THEN
   dbms_output.put_line(' Calling Dmd Collection Report API ROLLBACK_REC');
    GOTO ROLLBACK_REC;
  END IF;
  dbms_output.put_line('Debug  Step22');
  --****************** DATA QUALITY CHECK API **********************--
  write_msg( g_write_logfile , ' Calling DATA QUALITY CHECK API ');
  xx_DQ_WRAPPER_PROC( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id );
  write_msg( g_write_logfile , ' DATA QUALITY CHECK API return status '|| p_out_chr_retcode );
  IF p_out_chr_retcode = g_chr_failure_code THEN
    GOTO ROLLBACK_REC;
  END IF;
  dbms_output.put_line('Debug  Step23');
  --****************** Receipt Writeoff API **********************--
  l_stmt_processing := 'Calling receipt_writeoff API ';
  write_msg( g_write_logfile , ' Calling receipt_writeoff API ');
  dbms_output.put_line(' Calling receipt_writeoff API ');
  receipt_writeoff( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id );
  write_msg( g_write_logfile , ' Refd TS xx Rate API return status '|| p_out_chr_retcode );
  -- check if a failure in Refd Interest API
  IF p_out_chr_retcode = g_chr_failure_code THEN
    GOTO ROLLBACK_REC;
  END IF;
  dbms_output.put_line('Debug  Step24');
  --****************** Receipt Writeoff API **********************--
  l_stmt_processing := ' Calling refd_payable API ';
  write_msg( g_write_logfile , ' Calling refd_payable API ');
  dbms_output.put_line(' Calling refd_payable API ');
  refd_payable ( p_out_chr_errbuff => p_out_chr_errbuff ,p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id,p_in_req_id=> p_in_request_id );
  write_msg( g_write_logfile , ' Refd TS xx Rate API return status '|| p_out_chr_retcode );
  dbms_output.put_line(' Refd TS xx Rate API return status '|| p_out_chr_retcode );
  -- check if a failure in Refd Interest API
  IF p_out_chr_retcode = g_chr_failure_code THEN
    GOTO ROLLBACK_REC;
  END IF;
  dbms_output.put_line('Debug  Step25');
  -- Added for CR#611 - Blocked refd from AO - 6-Jun-2018 -- starts
  --IF NVL(v_approval_flag,'X') = 'B' THEN
  IF (l_241a_rec = 'Y') OR (l_ao_blck_rec = 'Y') THEN -- Added for CR#729 - 241a - 22-Oct-2018
    --FND_FILE.PUT_LINE (FND_FILE.LOG, 'Its a IBA-P/IBA-E refd blocked case. 245 notice will not be issued to Xxpayer');
    NULL;
  ELSE

    write_msg( g_write_logfile , ' L_IBA_FLAG: '|| L_IBA_FLAG );
    write_msg( g_write_logfile , ' p_skip_ro_status: '|| p_skip_ro_status );
    write_msg( g_write_logfile , ' P_RELAXATION_FLAG: '|| P_RELAXATION_FLAG );
    write_msg( g_write_logfile , ' G_RELAX_FLAG: '|| G_RELAX_FLAG );
    write_msg( g_write_logfile , ' p_skip_ro_status_1: '|| p_skip_ro_status_1 );
    write_msg( g_write_logfile , ' P_RELAXATION_FLAG_1: '|| P_RELAXATION_FLAG_1 );
    IF (p_skip_ro_status=2 AND NVL(L_IBA_FLAG,'X') <>'B' AND P_RELAXATION_FLAG <>1 AND G_RELAX_FLAG <>1)THEN --l_IBA for cr611    -- adjustment case but not adjusted--added p_relaxation_flag<>1 as a part of HF_175742 on 11-Apr-2018 --added g_relax_flag<>1 as a part of hotfix#176638 on 11-Apr-2018
      BEGIN
        write_msg( g_write_logfile , 'Before AP_invoices_all update for refd hold for 245 ' );
        UPDATE ap_invoices_all
        SET attribute7 ='REFD HOLD FOR 245', ---------------HOTFIX#162792
          -- CHANGED FROM STOP PAYMENT TO REFD HOLD FOR 245
          last_update_date =sysdate,
          ATTRIBUTE15      ='Adjustment case,hence hold the record'
        WHERE ATTRIBUTE10 IN
          (SELECT TO_CHAR(reference_id)
          FROM xx_refd_headers
          WHERE net_refd_amount     >0
          AND REFD_ADJUSTMENT_AMOUNT=0
          AND irt_id                  = cur_irt_id_rec.irt_id
          )
        AND attribute14='NET REFD';
        write_msg( g_write_logfile , 'recs updated for ap_invoices_all is='|| sql%rowcount);
		dbms_output.put_line('recs updated for ap_invoices_all is='|| sql%rowcount);
      EXCEPTION
      WHEN OTHERS THEN
        write_msg( g_write_logfile , 'Error while updating invoice table'|| sqlerrm);
        P_OUT_CHR_ERRBUFF :='Error while updating invoice table';
        p_out_chr_retcode := g_chr_failure_code;
        GOTO ROLLBACK_REC;
      END;
      --------added for HF_176638 on 16-May-2018----START----------
    ELSIF (p_skip_ro_status_1=2 AND NVL(L_IBA_FLAG,'X') <>'B' AND P_RELAXATION_FLAG_1 <>1 AND G_RELAX_FLAG <>1)THEN --added p_relaxation_flag_1<>1 as a part of HF_175742 on 11-Apr-2018 --added g_relax_flag<>1 as a part of hotfix#176638 on 11-Apr-2018 --added p_skip_ro_status_1=2 as a part of hotfix#176638 on 16-May-2018
      BEGIN
        WRITE_MSG( G_WRITE_LOGFILE , 'BEFORE AP_INVOICES_ALL UPDATE IN ELSIF FOR REFD HOLD FOR 245 ' );
        UPDATE ap_invoices_all
        SET attribute7 ='REFD HOLD FOR 245', ---------------HOTFIX#162792
          -- CHANGED FROM STOP PAYMENT TO REFD HOLD FOR 245
          last_update_date =sysdate,
          ATTRIBUTE15      ='Adjustment case,hence hold the record'
        WHERE ATTRIBUTE10 IN
          (SELECT TO_CHAR(reference_id)
          FROM xx_refd_headers
          WHERE net_refd_amount     >0
          AND REFD_ADJUSTMENT_AMOUNT=0
          AND irt_id                  = cur_irt_id_rec.irt_id
          )
        AND ATTRIBUTE14='NET REFD';
        WRITE_MSG( G_WRITE_LOGFILE , 'IN ELSEIF RECS UPDATED FOR AP_INVOICES_ALL IS='|| SQL%ROWCOUNT);
      EXCEPTION
      WHEN OTHERS THEN
        WRITE_MSG( G_WRITE_LOGFILE , 'ERROR WHILE UPDATING INVOICE TABLE1'|| SQLERRM);
        P_OUT_CHR_ERRBUFF :='Error while updating invoice table1';
        p_out_chr_retcode := g_chr_failure_code;
        GOTO ROLLBACK_REC;
      END;
    
    END IF;
	dbms_output.put_line('Debug  Step26');
    --added for cr 602 ends
    /*HOTFIX#127737*/
    --**********************MARKING_RECORDS_RORLX_PROC*************************
    -- **---------
    l_stmt_processing := ' Calling refd_payable API ';
    write_msg( g_write_logfile , ' Calling refd_payable API ');
    MARKING_RECORDS_RORLX_PROC( p_out_chr_errbuff => p_out_chr_errbuff, p_out_chr_retcode => p_out_chr_retcode, p_in_id_number => cur_irt_id_rec.id_num, p_in_irt_id => cur_irt_id_rec.irt_id );
    write_msg( g_write_logfile , ' Refd TS xx Rate API return status '|| p_out_chr_retcode );
    -- check if a failure in Refd Interest API
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    --*************************************************************************
    -- *******----
    /*18-AUG-2016*/
    /*Added as part of CR#583 phase 2*/
    --*******************XX_CREDIT_MISMATCH_REVERT_API************************
    -- *****------
    l_stmt_processing := ' CALLING XX CREDIT MISMATCH REVERT API';
    write_msg( g_write_logfile , ' Calling XX CREDIT MISMATCH REVERT ');
    XX_CREDIT_MISMATCH_REVERT_API( P_OUT_CHR_ERRBUFF => P_OUT_CHR_ERRBUFF, P_OUT_CHR_RETCODE => P_OUT_CHR_RETCODE, P_IN_IRT_ID => cur_irt_id_rec.irt_id, P_IN_ID_NUMBER => cur_irt_id_rec.id_num );
    IF p_out_chr_retcode = g_chr_failure_code THEN
      GOTO ROLLBACK_REC;
    END IF;
    --********************************END*************************************
    -----
  END IF; -- IF (l_241a_rec = 'Y') OR (l_ao_blck_rec = 'Y') THEN -- Added for CR#729 - 241a - 22-Oct-2018
  --****************** DATA QUALITY CHECK API **********************--
  write_msg( g_write_logfile , ' Calling DATA QUALITY CHECK API ');
  dbms_output.put_line(' Calling DATA QUALITY CHECK API ');
  xx_DQ_WRAPPER_PROC_NEW( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_irt_id => cur_irt_id_rec.irt_id );
  write_msg( g_write_logfile , ' DATA QUALITY CHECK API return status '|| p_out_chr_retcode );
  dbms_output.put_line(' DATA QUALITY CHECK API return status '|| p_out_chr_retcode );
  IF p_out_chr_retcode = g_chr_failure_code THEN
    GOTO ROLLBACK_REC;
  END IF;

  <<ROLLBACK_REC>>
  IF p_out_chr_retcode = g_chr_failure_code THEN
    l_irt_failure_cnt := l_irt_failure_cnt +1;
    write_msg( g_write_logfile , ' Error '|| l_stmt_processing ||'-'|| p_out_chr_retcode );
    l_stmt_processing := 'Rollback transaction to savepoint as one of routines had error';
    write_msg( g_write_outfile , ' Records Rollbacked ' || l_commit_rec_cnt ) ;
    -- Rollback transaction if any error encountered in any of the routines
    ROLLBACK TO SAVEPOINT irt_rec_acc; --irt_rec
    -- Any interim rollback between 2 commit would rollback transaction which
    -- was success
    -- hencereducing the number of processed records
    l_irt_process_cnt  := l_irt_process_cnt - l_commit_rec_cnt ;
    l_commit_rec_cnt   := 0;
    l_prev_commit_time := TO_CHAR(SYSTIMESTAMP,'MI');
    UPDATE xx_AR_TRANS_STG xats
    SET status_code = 'ERROR' ,
      error_message = error_message
      ||' - '
      ||p_out_chr_errbuff
    WHERE transaction_number = cur_irt_id_rec.IRT_ID;
    -- COMMIT; -- Don't remove as rollback next time would remove the error
    -- status Updated
    --ADDED AS PART OF CR#0583
    IF p_out_ro_status IN (1,3,4)--1 and 3 is added as part of CR#583 Phase 2
      THEN
      UPDATE xx_AR_TRANS_STG xats
      SET RELAX_FLAG           ='RELAX'
      WHERE transaction_number = cur_irt_id_rec.IRT_ID;
    END IF;
    --END OF CODE CHANGES CR#0583
    /*HOTFIX#139429 STARTS*/
    L_55_ROLLBACK:=0;
    L_PRCSSNG_CD :=0;
    BEGIN
      SELECT COUNT(*)
      INTO L_55_ROLLBACK
      FROM xx_AR_TRANS_STG
      WHERE transaction_number = cur_irt_id_rec.IRT_ID
      AND status_code          ='ERROR'
      AND ERROR_MESSAGE       IN (' - RECORDS WITH Refd Adj Rollback', ' - Customer/AO Partial Confirmation Records Exists');
    EXCEPTION
    WHEN OTHERS THEN
      P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
      P_OUT_CHR_ERRBUFF := SQLERRM;
      write_msg( g_write_logfile ,' Error in -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm);
    END;
    IF (L_55_ROLLBACK>0) THEN
      BEGIN
        SELECT "process_status_code"
        INTO L_PRCSSNG_CD
        FROM "process_store"."irt_process_control_mstr"@psql_process_fas
        WHERE "irt_id"=cur_irt_id_rec.IRT_ID;
      EXCEPTION
      WHEN OTHERS THEN
        P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
        P_OUT_CHR_ERRBUFF := SQLERRM;
        WRITE_MSG( G_WRITE_LOGFILE ,' Error in -' || L_CHR_PROC_NAME || ' - ' || L_STMT_PROCESSING || ' - ' || SQLERRM);
		dbms_output.put_line(' Error in -' || L_CHR_PROC_NAME || ' - ' || L_STMT_PROCESSING || ' - ' || SQLERRM);
      END;
	  --Commented for ABC-2.0 Bhagya
      --L_OUT_RETURN_CD := PKG_COMMON_APIS_V2.pcm_prcssng_cd_update_func( cur_irt_id_rec.IRT_ID,L_PRCSSNG_CD,L_OUT_RETURN_MSG);
	  L_OUT_RETURN_CD := 0;
      --PKG_COMMON_APIS_V2.UPDT_IRT_PRCS_CNTRL_ACCNT_FUNC (
      -- cur_no_refd_dmd_rec.irt_id, 6, 4, l_out_err_mssg );
      IF (L_OUT_RETURN_CD<>0) THEN
        UPDATE xx_AR_TRANS_STG xats
        SET status_code = 'ERROR' ,
          error_message = error_message
          ||' - '
          || L_OUT_RETURN_MSG
        WHERE transaction_number = cur_irt_id_rec.IRT_ID;
      END IF;
    END IF;
    /*HOTFIX#139429 ENDS*/
  ELSE -- IF out_chr_retcode = -2 THEN
    l_stmt_processing := ' Setting the records status to Processed if record had got processed';
    UPDATE xx_AR_TRANS_STG xats
    SET status_code          = 'PROCESSED'
    WHERE transaction_number = cur_irt_id_rec.IRT_ID;
    l_stmt_processing       := ' Setting the records status to Processed if record had got processed';
    -- Check the frequency at which the commit has to be performed
    IF l_commit_rec_cnt >= l_commit_int_cnt OR TO_NUMBER(TO_CHAR(SYSTIMESTAMP ,'MI') -l_prev_commit_time) >= l_commit_freq THEN
      COMMIT;
      l_commit_rec_cnt   := 0;
      l_prev_commit_time :=TO_CHAR(SYSTIMESTAMP,'MI');
    END IF; -- IF l_commit_rec_cnt >=
  END IF;   -- IF out_chr_retcode = -2 THEN
END LOOP;   --FOR cur_irt_id_rec IN cur_irt_id
l_stmt_processing := ' After exiting the Wrapper APi loop ';
DELETE xxcus.xx_5TO6_PROCESS_TEMP WHERE request_id = p_in_request_id;
-- Commit to make the last set of changes permanent
COMMIT;
-- Call the archive routine only if atleast one record is processed
IF l_irt_process_cnt > 0 THEN
  l_stmt_processing := ' Calling the Archive routine to backup the processed data for request '|| p_in_request_id ;
  write_msg( g_write_logfile ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Calling the archive routine
  archieve_processed_data ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_request_id => p_in_request_id) ;
ELSE
  write_msg( g_write_outfile , ' NO Valid IRT(s) found for processing / 0 Records Processed in Current Run ' );
  write_msg( g_write_logfile , ' NO Valid IRT(s) found for processing / 0 Records Processed in Current Run ' );
END IF; --IF l_irt_process_cnt > 0 THEN
l_stmt_processing := ' Writing Log record into the Process Log Table';
-- Create Process Log
write_msg( g_write_logfile ,l_chr_exe_location ||'-'||l_stmt_processing );
create_process_log ( p_out_chr_errbuff => p_out_chr_errbuff , p_out_chr_retcode => p_out_chr_retcode ,p_in_request_id => p_in_request_id , p_in_process_cnt => l_irt_process_cnt ,P_IN_FAILURE_CNT => L_IRT_FAILURE_CNT ,p_status => 'COMPLETED' );
-- Check if any error encountered while deriving default values
IF p_out_chr_retcode = g_chr_failure_code THEN
  RAISE custom_exception;
END IF;
l_end_time        := SYSTIMESTAMP ;
l_stmt_processing := 'Moving out from Procedure ' || l_chr_proc_name || '-' ||l_end_time ;
write_debug( g_write_logfile ,l_chr_exe_location ||'-'||l_stmt_processing );
EXCEPTION
WHEN custom_exception THEN
  write_msg( g_write_logfile ,' Unexpected Error in -' || l_chr_proc_name || ' - ' || l_stmt_processing);
  ROLLBACK;
WHEN OTHERS THEN
  p_out_chr_retcode := g_chr_failure_code;
  p_out_chr_errbuff := sqlerrm;
  write_msg( g_write_logfile ,' Error in -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm);
  ROLLBACK;
END wrapper_API;
PROCEDURE irt_accounting_mstr(
    p_out_chr_errbuff OUT VARCHAR2 ,
    p_out_chr_retcode OUT VARCHAR2 ,
    p_in_irt_id     IN VARCHAR2 ,
    p_in_max_thread IN NUMBER )
AS

  l_stmt_processing  VARCHAR2(200);
  l_chr_proc_name    VARCHAR2(50)   :='irt_accounting_mstr';
  l_chr_exe_location VARCHAR2(50)   :='';
  l_chr_prog         VARCHAR2 (50)  :='xx_IRT_ACCOUNTING_CHILD';
  l_chr_app          VARCHAR2 (100) := 'xxcus';
  l_thread_cnt       NUMBER ;
  l_num_request_id   NUMBER ;
  l_num_conc_req_id  NUMBER ;
  l_running_request  NUMBER;
  l_request_started  NUMBER := 0;
  l_chk              NUMBER;
  l_rec_cnt          NUMBER;
  l_chr_status       VARCHAR2 (80);
  l_chr_dev_status   VARCHAR2 (20);
  l_chr_message      VARCHAR2 (80);
  l_chr_phase        VARCHAR2 (80);
  l_chr_dev_phase    VARCHAR2 (20);
  --  Following variables added on 28-Oct-2014--1.14
  l_batch_size       NUMBER := FND_PROFILE.VALUE('xx_IRT_ACCT_BATCH_SIZE');
  l_subset_data_load NUMBER := 0;
  l_temp_tbl_cnt     NUMBER := 0;
  l_temp_rec_cnt     NUMBER := 0;
     l_out_chr_errbuff  VARCHAR2(3000);
      l_OUT_CHR_RETCODE VARCHAR2(3000);
	  V_ITE_ID	 VARCHAR2(3000);
TYPE tbl_pcm_irt
IS
  TABLE OF VARCHAR2(240) INDEX BY BINARY_INTEGER;
  l_irt_tbl tbl_pcm_irt;
  --  End of variables added on 28-Oct-2014--1.14
  l_bol_success_flag BOOLEAN;
  --  Start of changes  on 28-Oct-2014--1.14
  CURSOR cur_get_5to6_recs
  IS
    SELECT "irt_id"
    FROM
      ( SELECT DISTINCT XATS.transaction_number "irt_id",
        "x_priority_cd"
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM ,
        xx_ar_trans_stg XATS
      WHERE PCM."process_status_code"        = 5
      AND PCM."x_irt_ctl_flag"            = 'C'
      AND NVL(PCM."x_source_name", 'X')  <> 'IBA-WS' --Added on 25-jun-2018 Hotfix#183194
      AND XATS.transaction_number     = pcm."irt_id"
      AND NVL(XATS.status_code,'NEW') = 'NEW'
      AND XATS.REQUEST_ID            IS NULL
      ORDER BY "x_priority_cd"
      );

BEGIN
dbms_output.put_line( 'Start  -irt_accounting_mstr  procedure'|| p_in_irt_id );
 BEGIn
 SELECT "irt_id" INTO V_ITE_ID  
    FROM
      ( SELECT DISTINCT XATS.transaction_number "irt_id",
        "x_priority_cd"
      FROM "process_store"."irt_process_control_mstr"@psql_process_fas PCM ,
        xx_ar_trans_stg XATS
      WHERE PCM."process_status_code"        = 5
      AND PCM."x_irt_ctl_flag"            = 'C'
      AND NVL(PCM."x_source_name", 'X')  <> 'IBA-WS' --Added on 25-jun-2018 Hotfix#183194
      AND XATS.transaction_number     = pcm."irt_id"
      AND NVL(XATS.status_code,'NEW') = 'NEW'
	  and ROWNUm =1);
	  Exception when others then
	  dbms_output.put_line( 'Exception Error '|| SQLERRM );
	  ENd;
dbms_output.put_line( 'V_ITE_ID  -irt_accounting_mstr  V_ITE_ID'|| V_ITE_ID );


  l_chr_proc_name   := 'irt_accounting_mstr';
  l_stmt_processing := ' Starting of IRT Accounting ' ;
  p_out_chr_retcode := g_chr_success_code ;
  --l_num_request_id  := fnd_global.conc_request_id;
  l_num_request_id  :=p_in_irt_id;--Added by venkat on 22/July/2019 for removing Request id validation.
  write_msg( g_write_outfile , l_stmt_processing );
  write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
  -- Checking if the Master Program is submitted for a IRT_ID
  IF p_in_irt_id      IS NOT NULL THEN
    l_stmt_processing := ' Marking the record to process for the specified IRT_ID -'|| p_in_irt_id ;
 dbms_output.put_line( 'Marking the record to process for the specified IRT_ID -'|| p_in_irt_id );
    write_debug( g_debug_flag , l_stmt_processing );
  
	ACCOUNTING_PKG_2.wrapper_api(
      l_out_chr_errbuff  ,
      l_OUT_CHR_RETCODE  ,
      l_num_request_id  ,
      P_IN_IRT_ID  
      --P_IN_CONFIRM_FLAG in varchar2 default 'N'
    );


    IF L_NUM_CONC_REQ_ID > 0 THEN
      write_msg( g_write_logfile , ' Submitted the Child Job : - ' || L_NUM_CONC_REQ_ID);
    END IF;
  ELSE -- IF in_irt_id IS NOT NULL
    l_stmt_processing := ' When IRT_ID Parameter is NULL ' ;
    write_debug( g_debug_flag , l_stmt_processing );
    --  Start of changes  on 28-Oct-2014--1.14
    -- Statement to identify 4 times the Master load data in temp table -- 28-
    -- Oct-2014--1.14
    l_subset_data_load := l_batch_size * p_in_max_thread * 4;
    -- Check the volume of records in the temp table which is not processed
    SELECT COUNT('x')
    INTO l_temp_tbl_cnt
    FROM xx_5TO6_PROCESS_TEMP
    WHERE request_id IS NULL;
    write_msg( g_write_logfile , ' Temp Table data ' || l_temp_tbl_cnt );
    -- if the records available in temp area
    IF l_temp_tbl_cnt = 0 THEN
      l_temp_rec_cnt := 0;
      OPEN cur_get_5to6_recs ;
      LOOP
        l_irt_tbl.DELETE;
        FETCH cur_get_5to6_recs BULK COLLECT INTO l_irt_tbl LIMIT 10000;
        -- End of changes for 1.13 version on 15-OCT-2014
        l_stmt_processing := 'Checking if any records had been identifed';
        -- Check if any record is available for processing
        l_temp_rec_cnt      := l_temp_rec_cnt + l_irt_tbl.COUNT;
        IF l_irt_tbl.COUNT   > 0 THEN
          l_stmt_processing := 'Setting the request_id for records identifed for processing';
          -- Inserting the IRTS records into temp table which to be processed
          FORALL i IN 1..l_irt_tbl.COUNT
          INSERT
          INTO xx_5TO6_PROCESS_TEMP
            (
              TRANSACTION_NUMBER
            )
            VALUES
            (
              l_irt_tbl(i)
            );
          write_debug ( g_debug_flag , l_stmt_processing || '. Eligible records [' || l_irt_tbl.count ||'] identified ' ) ;
        END IF; -- IF l_irt_tbl.COUNT > 0 THEN
        EXIT
      WHEN ( cur_get_5to6_recs%NOTFOUND OR l_temp_rec_cnt >= l_subset_data_load ) ;
      END LOOP;
      COMMIT;
      CLOSE cur_get_5to6_recs;
    END IF; -- IF l_temp_tbl_cnt < l_subset_data_cnt THEN
    -- End of Changes in the new logic 1.14
    FOR I IN 1..p_in_max_thread
    LOOP
      -- Start of changes for 1.13 version on 15-OCT-2014
      l_chk := 0;
      -- End of changes for 1.13 version on 15-OCT-2014
      --  Start of changes  on 28-Oct-2014--1.14
      -- Check any IRT Exists in 5 and C
      --   OPEN cur_chk_5to6_exists;
      --  FETCH cur_chk_5to6_exists INTO l_rec_cnt;
      --  CLOSE cur_chk_5to6_exists ;
      -- Check the volume of records in the temp table which is not processed
      SELECT COUNT('x')
      INTO l_temp_tbl_cnt
      FROM xx_5TO6_PROCESS_TEMP
      WHERE request_id IS NULL;
      --  End of changes  on 28-Oct-2014--1.14
      fnd_file.put_line ( fnd_file.LOG, ' Records Available for processing ' || l_temp_tbl_cnt ) ;
      IF l_temp_tbl_cnt = 0 THEN
        fnd_file.put_line ( fnd_file.LOG, ' No IRT Found for processing ' ) ;
        fnd_file.put_line ( fnd_file.output, ' No IRT Found for processing ' ) ;
        EXIT;
      END IF;
      WHILE (l_chk=0 )
      LOOP
        SELECT COUNT( DISTINCT request_id)
        INTO l_request_started
        FROM xx_ar_trans_stg
        WHERE REQUEST_ID IN
          ( SELECT DISTINCT request_id
          FROM fnd_concurrent_requests
          WHERE concurrent_program_id IN
            (SELECT concurrent_program_id
            FROM fnd_concurrent_programs_Vl
            WHERE concurrent_program_name ='xx_IRT_ACCOUNTING_CHILD'
            )
          AND phase_code IN ('P', 'R')
          );
        fnd_file.put_line(fnd_file.LOG,' Request executing are ' || l_request_started);
        -- Start of changes for 1.13 version on 15-OCT-2014
        -- Computes the instance of IRT Accounting Child program currently
        -- running
        SELECT COUNT('x')
        INTO l_thread_cnt
        FROM fnd_concurrent_programs_vl FCP ,
          fnd_concurrent_requests FCR
        WHERE FCP.concurrent_program_id = FCR.concurrent_program_id
        AND FCp.concurrent_program_name = 'xx_IRT_ACCOUNTING_CHILD'
        AND FCR.phase_code              ='R' ;
        fnd_file.put_line(fnd_file.LOG,' Thread Running ' || l_thread_cnt);
        -- End of changes for 1.13 version on 15-OCT-2014
        IF l_request_started < l_thread_cnt AND l_thread_cnt != 0 THEN
          -- Start of changes for 1.13 version on 15-OCT-2014
          dbms_lock.sleep(20.00); -- Sleep 20 seconds and check if the new
          -- request
          --dbms_lock.sleep(40.00); -- Sleep 40 seconds and check if the new
          -- request
          -- End of changes for 1.13 version on 15-OCT-2014
          -- has marked its records for processing
        ELSE
          l_chk := 1;
        END IF;
      END LOOP;
      -- Check's the Max number of instance of Accounting program currently
      -- Running
      -- and spawns a new instance of wrapper
      IF p_in_max_thread   > l_thread_cnt THEN
        l_stmt_processing := ' Calling Wrapper API with Request_id, IRT_id as parameter' ;
        write_debug( g_write_logfile , l_stmt_processing );
        l_num_conc_req_id := NULL;
        L_NUM_CONC_REQ_ID := FND_REQUEST.SUBMIT_REQUEST (application => l_chr_app, program => l_chr_prog, start_time => SYSDATE, SUB_REQUEST => FALSE, argument1 => l_num_request_id, -- Parent Request ID
        ARGUMENT2 => P_IN_IRT_ID                                                                                                                                                      -- IRT_ID
        );
        COMMIT;
        IF L_NUM_CONC_REQ_ID > 0 THEN
          write_msg( g_write_logfile , ' Submitted the Child Job : - ' || L_NUM_CONC_REQ_ID);
          l_bol_success_flag := fnd_concurrent.wait_for_request (request_id => L_NUM_CONC_REQ_ID , INTERVAL => 2 , max_wait => 20 , phase => l_chr_phase , status => l_chr_status , dev_phase => l_chr_dev_phase , dev_status => l_chr_dev_status , MESSAGE => l_chr_message );
        END IF;
      ELSE -- IF in_max_thread >= l_thread_cnto
        write_debug( g_debug_flag ,l_chr_exe_location ||'-'||l_stmt_processing );
        write_msg( g_write_logfile , ' Unable to submit a new thread as already running at Max Limit of [' || p_in_max_thread ||']' );
        EXIT;
      END IF; -- IF in_max_thread >= l_thread_cnt
    END LOOP; -- FOR I IN 1..p_in_max_thread
  END IF;     -- IF in_irt_id IS NOT NULL
  write_msg( g_write_outfile , ' IRT Accounting program - End ' );
EXCEPTION
WHEN OTHERS THEN
  P_OUT_CHR_RETCODE := G_CHR_FAILURE_CODE;
  p_out_chr_errbuff := sqlerrm;
  write_msg( g_write_logfile ,' Unexpected Error in -' || l_chr_proc_name || ' - ' || l_stmt_processing || ' - ' || sqlerrm);
  ROLLBACK;
END IRT_ACCOUNTING_MSTR;
END ACCOUNTING_PKG;